                            V9 DESIGN CONSIDERATIONS
                            ------------------------
                $Id$


PURPOSE

Provide a vector-based persistent storage engine with support for a wide range
of data querying and manipulation operators. To be called "V9".

Note: most items in this document are in historical order. Additions at the end.


BACKGROUND

This is the conclusion of numerous "Vlerq" projects that have been explored over
the years, which in turn build upon experiences from the Metakit database.


CONCEPTS

The basic high-level data structure is the "view", a rectangular collection of
cells, with numbered rows and named columns. Each cell contains either a basic
data value such as an int, float, string, or a nested "subview". The cell type
is fixed within a column and can vary between different columns, i.e. per row.

The basic internal low-level building block for views is the "vector".

Persistent data is managed as a "storage" object, this is a mutable view (often
stored on disk), with optional subviews and arbitrarily deep nested structures.

The structure of a view is again a view, this is called a "meta-view". There is
one special recursive view to represent the canonical "meta-meta-view", i.e. the
meta-view of meta-views. There is exactly one such meta-meta-view.

A concept which is planned for implementation a bit later on is "unified types":
each view has a "keys" integer parameter and a "uniq" flag associated with it.
Keys defines how many of the leading columns are to be treated as primary key,
and uniq is set to 1 if the keys must be unique or 0 if duplicates are allowed.
There are a number of important edge cases such as view width = keys = 0, most
of this will be worked out later on.

Likewise, the concept of "rank" is planned but postponed for now. Rank allows
treating a view as a multi-dimensional structure with a reconfigurable shape.


TCL BINDING

The development and test environment for V9 is Tcl. The code is set up in such a
way that a basic subset of V9 is implemented in pure Tcl and can be used without
ever loading the compiled C extension (which is called "V9x").

All view operators are defined as commands in the ::v9 namespace. The compiled
extension simply adds extra commands to this namespace, and also replaces some
commands previously defined as procs in Tcl, so "V9x" must be loaded after "V9".

The conversion to an efficient internal representation is automatic, using Tcl's
dual object representation mechanism. In the pure Tcl case, all operations are
done on plain Tcl strings and list - this is slower and uses up more memory.

V9's core engine is written in C - it's portable and independent of Tcl itself.
The core is contained in the files "v9.h", "v9.priv.h", and "v9_*.c", the Tcl
extension code is in the files "v9x.h" and "v9x*.c" - they only include "v9.h".


TCL REPRESENTATION

There is an exact mapping from each view to a Tcl string / list representation.
For example, this view with two integer columns and 3 rows:

    A    B
    ===  ===
      1    2
     11   22
    111  222

... is equivalent to the following Tcl string:

    vdat A:I,B:I {1 11 111} {2 22 222}

There are a number of special representations:

  - the view with N duplicate rows of 0 columns is represented as the int "N"
  - not a special case really: the empty string is a meta-view with 0 columns
  - if all else fails, a list of length 1 will be interpreted as a meta-view
  - conversely, a meta-view is always converted to string form, e.g. "A:I,B:I"


ITEMS

The "V9Item" C union is for passing around different types of data at run time.
There are 9 primitive data types:

  - nil       missing value, no data
  - int       signed integers, up to 32 bits
  - long      signed integers, up to 64 bits
  - float     floating point value, 32 bits
  - double    floating point value, 64 bits
  - string    UTF-8 text string, 0-terminated (C-style)
  - bytes     arbitrary size binary data
  - cell      a tuple, containing a vector pointer and an integer
  - vector    a pointer to a vector (or view)

The V9Item does *not* contain the type of the current value stored in it - this
must be passed separately, implicitly or as an explicit "V9Types" enum constant.


VECTORS

Vectors are the foundation of V9. They consist of a header which precedes the
actual vector data and is accessed as "((VectorHead*) p)[-1]" using the Head(p)
macro. The vector data consists of various data fields, depending on the "mode"
of vector allocation used:

  - inline    the data follows the header, it's mutable but not resizable
  - fixed     the readonly data is pointed to but not managed or free'd by V9
  - dynamic   the data is stored in a separately allocated area, and resizable
  - mapped    the data comes from a file mapped readonly into memory
  - shared    the R/O data comes from another vector, with given offset/length

The vector "type" is independent of this allocation mode. It determines how the
data bytes are interpreted, i.e. what representation is used within the vector.
So you can have an inline vector of 32-bit ints, a mapped vector of floats, and
a shared vector of strings, for example.

Vectors are reference-counted. The "shares" field is > 0 for vectors with more
than 1 reference to them. When the shares field drops to negative, the vector
is released and all associated memory free'd. New vectors are returned with the
shares fields set to 0, i.e. preset to having a single reference to them. The
V9IncRef() and V9DecRef() functions are used to adjust the reference count.

Views are implemented as inline vectors with a collection of column references,
(an array of "items"), plus some more fields such as a pointer to the meta-view.


REPRESENTATIONS

Views are about data representations. With two languages involved, C and Tcl,
there is also the issue of transforming representations over time (or Tcl's
variant of undesired behavior: "shimmering"), and how to get a consistent as
well as efficient conceptual model which can be used in both languages.

The basic Tcl format has already been described, using the example:

    vdat A:I,B:I {1 11 111} {2 22 222}

This is a 4-element list: a type, a meta-view description, and two data columns.
There is an underlying more general mechanism: any list of 2 or more elements
can be used as view, if the first word matches a known "type" and if the other
elements are valid parameters for that type.

The rules to transform a Tcl string into a C-type "V9View" are as follows:

    1. the empty string is equivalent to a meta-view with no rows
    2. a non-negative integer is equivalent to a 0-column view of that size
    3. a meta-view description is converted to a C-type meta-view structure
    4. else the string is treated as a list which must have at least 2 elements

Case 4 is the most elaborate one: the first element of the list is looked up in
a list of fixed "handlers". If found, the corresponding C function is called to
perform the conversion to a C data structure. So as a minimum, there is an entry
named "vdat" which leads to the C code that can turn the Tcl list into a C view.

But there can be many more handlers. For example, "iota 123" could be treated as
the definition of a column of 123 integers with values 0 .. 122. Unlike earlier
versions of V9, handlers will only be implemented in C because a callback into
Tcl in "setFromAnyProc" is so tricky - and will cause even more problems with
the new NRE design of Tcl 8.6 anyway. Fortunately, it looks like sticking to C
at this point is not really an important limitation.

There's a subtle interaction between the view "handlers" and operators placed in
the "::v9" namespace (such commands can be implemented in Tcl as well as in C).
With a "iota" handler as example, a useful view operator definition might be:

    proc ::v9::iota {n} {
        return [list iota $n]
    }
    
(or alternately as "interp alias {} v9::iota {} list iota")

Here is an example of constructing a new view which illustrates what's going on:

    set v [v9 reverse [v9 iota 123]]

In other words: take the number 123, apply the "iota" operator to it, apply the
the "reverse" operator to the outcome, then store that result in variable "v".

With the above definition, the "iota" operator returns the Tcl list "iota 123".
This in turn then becomes the input argument passed to the "reverse" operator.
Now suppose "reverse" is defined as follows:

    proc ::v9::reverse {v} {
        return [list reverse $v]
    }

Obviously, variable "v" will end up containing "reverse {iota 123}".

If on the other hand "reverse" is defined as an operator which wants to treat
its input as a C-type view, then something else happens: a call will be made in
C to the "setFromAnyProc" function defined in "v9x.c" (probably indirectly, via
a call to "Tcl_ConvertToType"). There, the value is recognized as being a list
with a leading "iota" element. This causes an internal call to be made to the
corresponding C handler. Presumably, that C-code handler will then interpret the
second list element as an integer and set up a C-type view which behaves as a
"iota", with the proper meta-view and 123 rows with (virtual) entries 0 .. 122.

View operators and view handlers are quite similar. Both take input argments and
convert these to a result. View operators are called from Tcl scripts and may be
implemented either in Tcl or in C. They can return any type of value, which gets
converted to a Tcl_Obj result. View handlers are called by SetV9ObjFromAnyRep()
and can only be implemented in C. They always return a V9View (or fail). A fair
number of view operators will do nothing but create a list, to be turned into a
V9View later on, by a view handler with the same name as the operator.

The above describes how Tcl list structures can automatically turn into C-type
view structures, using Tcl's dual-object representation mechanism.


EVERYTHING IS A STRING (EIAS)

Tcl also needs a hard guarantee that any Tcl_Obj can be represented as a string.
It will probably be clear that a string such as "vmap /my/datafile.db r" could
be used as view description *if* there is a view handler named "vmap" which can
map the file into memory and return a corresponding V9View structure for it.

IOW, the string "vmap /my/datafile.db r" can represent a dataset stored on disk
and V9 can automatically set up the internal view data structures whenever that
string is used as view, e.g. when doing "v9 size {vmap /my/datafile.db r}".

Extracting data out of that dataset is straightforward, V9 can simply return the
proper Tcl_Obj, containing ints, strings, whatever.

This doesn't work well when extracting a subview from that dataset, though. That
subview could be a huge collection of strings and the *worst* thing to do would
be to create a string representation of the form "vdat <meta> <columns...>" for
these subviews. Such a string might take a lot of memory and processing power to
construct, and worst of all: it's redundant as far as V9 data manipulation is
concerned, since V9 would use its own efficient internal representation anyway.
In the case of memory-mapped files, naive string representations are a bad idea.

A solution is to adopt another string rep, based on the list which was used to
locate and apply the view handler. Let's take this command to extract something
out of a view stored on file as example:

    set v [v9 at {vmap /my/datafile.db r} 1 2]

This is the element in the first row / second column of the view stored in the
file "/my/datafile.db". If that is an int, string, etc - we simply return it.
But if that value is a subview, then V9 returns this instead:

    at {vmap /my/datafile.db r} 1 2

This small string can be passed around as needed. It represents the subview in
the specified position of the specified datafile. When that string is accessed
as a view, perhaps by taking its size or extracting some values from it, then
the view handler mechanism kicks in. A view handler named "at" will be called,
which then returns the internal C-type view by extracting the actual subview.

So the trick for dealing with Tcl's everything-is-a-string requirement for views
is to keep the original operation around which was used to create that view, and
to have view handlers take care of string -> C view conversion whenever needed:

    There is never a need to "invent" a string rep for views loaded into Tcl.

There are some assumptions and limitations:

  - the mapped datafile must remain read-only so the data in it doesn't change
  - everything is in fact read-only, this treats views as immutable values
  - vmaps should be re-used to avoid mapping the same file more than once

So the essential design issue is to make sure there are small string reps for
all the different types of views supported in V9. The view handler concept does
just that, even with a fair amount of view operator nesting.


EIAS SUBTLETIES

Two exceptions where the string rep is not always maintained are the "meta" and
the "at" operators - because both can generate their string rep on-demand. This
is done for performance reasons as these two operations are extremely common.

The meta-view case is simple: since there's a well-defined string representation
for meta-views, UpdateV9ObjStrRep can simply generate that string when needed.

Subviews require more collaboration from different parts of the code:

  - the V9_Get function (v9_getter.c) is special-cased for subview access and
    will store the owner and owning row and column in each returned subview
  - this means that a C-level subview has almost enough information to create a
    Tcl-level string on-demand, i.e. "at <view> <row> <col>"
  - the missing bit is the Tcl_Obj* of the parent view, since the V9_View only
    stores the V9View owner (the C core doesn't know about Tcl at that level)
  - the "atOp" operator (v9x_ops.c) is also special-cased for subview access, so
    that it can keep a reference to the parent Tcl_Obj* in the child Tcl_Obj*
  - this Tcl_Obj* reference is stored in the ptr2 field, and is ref-counted
  
To summarize, there are three different ways a V9View is managed in Tcl:

  - meta-views are stored as V9View, with the string generated as needed, this
    is the standard way of managing "internal" objects in C extensions for Tcl
  - sub-views are views which were obtained via a V9_Get on a view-type column,
    these have their owner/orow/ocol fields set in the V9View at the C level
    (the string rep of subviews is generated from that plus a parent Tcl_Obj*)
  - other views are created via *some* view operator and for these the string
    rep is kept around right from the start, using the view handler mechanism


STORAGES AND CHANGES

So far, this has been about creating new views from scratch and treating these
views as fixed values, extracting data and introspecting them.

A "storage" is a container which can hold a mutable view, i.e. a view which can
be changed. Changes consist of adding, replacing, or deleting rows, changing a 
single item in the view, or changing the column structure of a view. Since views
can be nested, similar changes can be made to any of the subviews in a storage.

Storages will usually be associated with a file, making its view persistent. In
that case, changes can be committed to file as an ACID compliant transaction.
Storages can be serialized to/from a file or any I/O stream, this is independent
of transactions.

In Tcl, a storage is a command object which is created and destroyed explicitly.
Views located inside a storage are accessed via "view references". There is a
string representation for this: "vref <cmdname>". The view handler mechanism
will automatically create an efficient internal view representations on-demand.

Another way to look at storages is as a facade behind which views can be managed
which do not have a string rep - such as memory-mapped views and mutable views.
The string rep for all views inside a storage are based on "vref ..." strings.

Subviews inside a storage are treated like all subviews using "at ..." strings,
as described earlier. So a simple subview located in row 123, column 456 of a
storage called "db" might look like this:

    at {vref ::db} 123 456

Views in a storage can be changed using specific view operators. To change the
"name" item of row 123 of view v, you would use "v9 put $v 123 name newvalue".
This is only allowed for views inside the storage (called "storage views") and
if the storage has not been set up as read-only.

Storage views are handles for views or subviews inside a storage.

Storage views can change. When you ask the size of a storage view with "v9 size
$v", then you may get different answers at different times. Compare this to
variable names in Tcl ("set name") or file handles ("tell file7"), which can
also return different results at different times. Storage views live inside
storages which represent mutable state, just as variables and file descriptors
have a state in Tcl.

When you change a view with "v9 put $v ...", v must be a storage view, and hence
be of the form "vref ..." or a subview inside of the form "at {vref ...} ...".
View changes will be carried out inside the storage object, but the view string
will *not* change, it'll be that same "vref ..." or "at ..." string as before.
That's why storage views are called "handles": it's not the string of the view
that gets changed, but the data *behind* that descriptive string.

A view is just a descriptive string. With non-storage views, the string is
equivalent to the data inside that view - it can in fact be treated as shortand.
Storage views also have a descriptive string, but now the data collection is
part of a storage object. That data might come from a file on disk, it might be
modifiable, and changes might be committed back to disk: then it's a database.

Storages and storage views are part of the Tcl binding. The concept of storage
views does not exist in the V9 core, where everything is copy-on-write unless
there are no shared references - the same as Tcl at the Tcl_Obj level.


DERIVED VIEWS

Many view operators in the core are implemented virtually, as "derived views".
Sorting a view for example, is implemented as permutation of the original view.
The permutation vector is constructed and kept along with a reference to the
original input view. Whenever an access is done through the "at" operator, the
row index is internally re-adjusted and then access is repeated on the original
view instead. The memory use for a sorted view is just its permutation vector.

Derived views are consistent because views are values which do not change. The
reference to underlying views guarantees that underlying views never change.

Derived views can be combined and nested at will. On the Tcl level, this can
also use views in storages, even combining views from different storages.


DEPENDENCY TRACKING

The combination of storage views and derived views requires extra care, because
storage views *can* change at will. Such changes may affect the validity of the
derived views built on them - inserting a row for example, and working with the
sorted derived view on top.

The solution is to invalidate cached view representations. So when a change to
a storage view is made, all dependent derived views will have their internal
view representation invalidated. A subsequent access from Tcl to these views
then causes a new V9View to be constructed using up-to-date input views.

Invalidation hinges on tracking which Tcl_Obj views depend on other Tcl_Obj
views, and doing so with all the nesting involved. A shotgun approach would be
to always invalidate all view reps, but the cost of that would be prohibititive.

A slightly more refined approach is to invalidate only the views which depend on
a particular storage, i.e. derived views which are based on some storage views.
This is still very coarse, since not all changes to underlying views will affect
the views "dependent" on them. Changing a non-key value in a sorted view doesn't
affect its sort order for example, and would not require invalidating the sort.
But as first step, this coarse approach is the one currently implemented in V9.

The actual implementation is quite tricky. It hinges on three different ways to
represent derived views: as strings, as lists, and as internal representation.
Let's take a non-trivial nested derived view as example:

    sort {join {vref ::S} {at {vref ::T} 1 2} A} B

This is a sort on the "B" column, of a join over two views on the "A" column.
The two views are: a storage view and a subview of a storage view. When either
storage is changed, the join and the sort both need to be re-calculated.

The interesting bit is the join, which is a view derived from two other views:
it has to provide results for the sort view, it has to track storage changes,
and it has to somehow cause the "upstream" sort to be invalidated when needed.

Let's follow the construction of Tcl_Obj's when the above view structure is
accessed as a view for the first time (by doing a "v9 size" on it for example):

    - "sort {join {vref ::S} {at {vref ::T} 1 2} A} B" is a string
    - this is converted to a 3-item list by SetV9ObjFromAnyRep():
            sort
            join {vref ::S} {at {vref ::T} 1 2} A
            B
    - the "sort" view handler is called
    - that handler expects a view as first argument, so the process repeats:
        - "join {vref ::S} {at {vref ::T} 1 2} A" is a string
        - this is converted to a 4-item list by SetV9ObjFromAnyRep():
            join
            vref ::S
            at {vref ::T} 1 2
            A
        - the "join" view handler is called
        - that handler expects views as first two arguments, so we repeat again:
            - let's assume we got two Tcl_Obj's back with view reps in them
        - the "join" handler does its thing, returning a V9View
        - so SetV9ObjFromAnyRep() now has a V9View to set up for the join
            - it constructs a Tcl_Obj, details will follow below
            - at also "attaches" to its two input views, also described below
        - now SetV9ObjFromAnyRep() returns a Tcl_Obj with a view rep inside
    - the "sort" handler does its thing, returning a V9View
    - again, SetV9ObjFromAnyRep() now has a V9View to set up for the sort
        - it constructs a Tcl_Obj, details will follow below
        - at also "attaches" to the join Tcl_Obj, also described below
    - finally, SetV9ObjFromAnyRep() returns a Tcl_Obj with a view rep inside

Done, now a "v9 size" or other view op can perform the requested operation.


TCL OBJECT REPRESENTATIONS

For our purposes, a Tcl_Obj has four pieces of information:

    - a string representation, may or may not be present
    - an internal type, may or may not be set
    - two pointers, available when the type is set

When SetV9ObjFromAnyRep() is done, it returns a fully set-up Tcl_Obj with the
following values in each of the Tcl_Obj fields:

    - the string rep is left as is, may or may not be present
    - the internal type is set to "view"
    - ptr1 points to a V9View, and holds a reference to it (via V9_AddRef)
    - ptr2 points to an allocated C structure of type ViewDep

In the case of non-storage views, when there are no dependencies, ptr2 is null.
In that case, the string representation must be present.
    
The ViewDep structure is needed because there is not enough room in each Tcl_Obj
to store everything in it. It will be free'd again when the Tcl_Obj is released.
The following information is stored in a ViewDep:

    1) a pointer to the view handler entry
    2) the arguments to the view operator as a Tcl list
        (this is known in SetV9ObjFromAnyRep, which sets all this up)
    3) a list of the Tcl_Obj's which depend on this tcl_Obj
        (e.g. for the join Tcl_Obj, this would be the sort Tcl_Obj)

The ViewDep holds a reference to a list (2), which in turns holds references to
all its arguments, hence also all the Tcl_Obj's with view reps in them.

The Tcl_Obj's tracked as dependency (3) does *not* hold references to them since
there is already a refcount the other way, e.g. from "sort" to "join" Tcl_Obj.

Note that the Tcl list of arguments will be held on to in the ViewDep structure.
This is used for two different tasks:

    - to be able to construct the string rep if needed (in non-interactive use,
      many string reps will never be needed)
    - to hold on to all the Tcl_Obj's which provide input views

Dependencies form a directed acyclic graph (DAG), they are not always a tree.


ATTACH / DETACH

It should now be clear how SetV9ObjFromAnyRep() attaches to input views: it does
a scan over all the Tcl_Obj's in the list (2), and if that Tcl_Obj has a type
"view", then it adds itself to the Tcl_Obj's dependency list (3).

Conversely, when a Tcl_Obj of type "view" is freed, FreeV9ObjIntRep() will again
scan the list (2) and remove itself from all dependency lists (3).

Due to the fact that a higher Tcl_Obj (e.g. "sort") holds a reference to all its 
input view Tcl_Obj's (e.g. "join"), it is impossible for that join to be free'd
before the sort. This attach/detach mechanism works under all conditions.


INVALIDATION

With the above data structures in place, invalidation is now possible. Whenever
a storage view changes, it invalidates all its immediate dependents - storage
views also contain a dependency list (3).

Each immediate dependency in turn escalates that invalidation request to all of
its immediate dependents, and so on: "turtles all the way down" as they say (or
up in this case, depending how you look at it). Since dependencies are a DAG,
the recursion of these invalidations can never become infinite.

One more trick is used as optimization. It would be simplest to merely remove 
all the cached information and revert to a string representation for invalidated
views. But that loses lots of work which is bound to be redone again thereafter,
i.e. constructing a list and setting up all the dependencies again.

Therefore another variant of internal representation could also be used. Instead
of removing all information, the V9View reference (i.e. ptr1 in the Tcl_Obj) is
cleared, leaving the ViewDep struct intact. There's no need to generate a string
representation, that can still be done on-demand.

When accessing a V9View inside a Tcl_obj, we check whether it's present. If not,
and if there's a ViewDep struct then we can omit much of the work. The V9View
will have to be recalculated of course, but all dependency setup can be skipped.
A Tcl_Obj always has either a V9View reference or a ViewDep struct, or both.

The end effect of this is that view invalidation can progress quickly, fanning
out over all dependencies to remove their V9View references.

Likewise, restoring a view after a change consists of recalculating that view
and then storing a reference to it in ptr1 again. Often, view recalculations
will require other input views, which can trigger more restores. This argument
conversion to views is part of the generic view handler calling sequence.

That's it: storage changes lead to invalidations, while view accesses lead to
view construction or view re-construction. Interestingly, these processes take
place from "opposite ends" of the DAG. And lazily, i.e. only when requested.


POSSIBLE REFINEMENT

The invalidation mechanism described above is still a bit of a shotgun appraoch:
any change to a storage invalidates all derived views, as well as all subviews.

A better way would be to propagate the change details, so that derived views can
decide for themselves whether the change affects them. The problem is that these
derived views must then also propagate such similarly detailed changes to their
dependents. That gets complicated very quickly: a changed key in a sort becomes
a row move, a simple change could become quite complex in a join, etc.

As compromise, it would be possible to propagate just the extent of the change:
min/max values for the rows and columns affected by this change. For insertions
and deletions all rows starting at the first modified row would be flagged as
changed. IOW, such changes propagate as "rectangles" over a view. When it gets
too complex, that rectangle would simply cover the entire view again, as before.

Dealing with subviews properly is actually a bit more involved. The "rectangle"
becomes an access "path" plus a rectangle, i.e. an integer sequence of the form:

    row1 col1 row2 col2 ... top bottom left right

Each propagation level can then shorten that path and/or adjust the rectangle.
And "at" view handlers can filter out changes which don't affect them and halt
further propagation. This can probably avoid a lot of unnecessary invalidations.

This refinement isn't being implemented at this stage.


SCRIPTS AND TEST FILES

There are two script files, called "v9.tcl" and "v9x.tcl". These are loaded with
the "package require" mechanism. Requiring "V9" will load just v9.tcl, which is
usable as a minimal implementation of some of the core functions of V9. There is
no C code involved, so this should be usable on any platform having Tcl >= 8.5.

With "package require V9x", the full system is loaded: both Tcl scripts as well
as the compiled C extension, called "V9x". The load order is as follows:

    - package require V9x will source the "v9x.tcl" script
    - v9x.tcl then does a "package require V9"
    - package require V9 will source the "v9.tcl" script
    - v9.tcl defines the ::v9 namespace as ensemble, with some procs in it
    - v9x.tcl then loads the compiled C extension dynamically
    - lastly, some more procs are defined which depend on the V9x extension

So a complete installation of V9 requires at least these four files:

    - libV9x<VERSION>.dylib     (or .dll, or .so)
    - pkgIndex.tcl
    - v9.tcl
    - v9x.tcl

There is a global array called "v9" with info used by "v9.tcl" and "v9x.tcl".
This array should be considered private data, and is needed for loading to work.

The different test files in the "tests/" subdirectory exercise various parts of
the system. You can run all of them using "all.tcl" (or "make test") or just a
specific one - either way, initialization is done via the "setup.tcl" script.

The "basic" tests do just what they say. This test suite is special in that it
can be used with or without the "V9x" extension loaded. There is a "basicx" test
which loads V9x and then sources the basic test. Both should work identically,
but there is some logic to display which case is running, and a timing value to
let you verify that the C-based versions take much less time. The name "basic"
was chosen so that this is the first test picked up by "all.tcl".

The "l.perf" test is not really a test but a basic performance check, it prints
some timing results on stdout and is excluded from normal "all.tcl" test runs.
