# V9 general tests for the V9x C extension
# 2009-05-08 <jcw@equi4.com> http://opensource.org/licenses/mit-license.php
# $Id$
# %renumber<^\s*test vqx->%

source [file join [file dirname [info script]] setup.tcl]

test vqx-0 {load and check V9x package} { package require V9x } $version

test vqx-1 {check contents of the ::v9 array} -body {
    puts ""
    parray v9
} -output [string map [list #LIB $v9(libfile) #VSN $version] {
v9(libfile) = #LIB
v9(typemap) =  N 0  I 1  L 2  F 3  D 4  S 5  B 6  V 7 
v9(typerev) =  0 N  1 I  2 L  3 F  4 D  5 S  6 B  7 V 
v9(version) = #VSN
}]

set V {vdat A:I,B:I {1 11 111} {2 22 222}}

test vqx-2 {V9x should now be loaded} {
    foreach {X Y} {*}[info loaded] {
        if {$Y eq "V9x"} {
            return [file exists $X]
        }
    }
} 1

test vqx-3 {size of a 0-column view} {
    v9 size 123
} 123

test vqx-4 {meta-view of a 0-column view} {
    v9 meta 123
} ""

test vqx-5 {size of the empty meta-view} {
    v9 size ""
} 0

test vqx-6 {size of the meta-meta-view} {
    v9 size [v9 meta ""]
} 3

test vqx-7 {size of a data view} {
    v9 size {vdat x {1 2 3}}
} 3

test vqx-8 {get allocation mode of the empty meta-view} {
    v9 valloc ""
} inline

test vqx-9 {get type of the empty meta-view} {
    v9 vtype ""
} view

test vqx-10 {meta-vmeta-view as string} {
    v9 meta ""
} name:S,type:I,subv:V

test vqx-11 {meta-view of a subview access} {
    v9 meta [list at [v9 meta ""] 0 2]
} name:S,type:I,subv:V

test vqx-12 {meta-view of a data view} {
    v9 meta "at abc:S 0 2"
} name:S,type:I,subv:V

test vqx-13 {name access into a new meta-view} {
    v9 at abc:S 0 0
} abc

test vqx-14 {type access into a new meta-view} {
    v9 at abc:S 0 1
} 5

test vqx-15 {sub-view access is not lazy if the result is a meta-view} {
    v9 at abc:S 0 2
} "" ;# not "at abc:S 0 2", because the subview is a meta-view

test vqx-16 {combined Tcl and C operator calls} {
    v9 get abc:S,def:S * 0
} {abc def}

test vqx-17 {combined Tcl and C, with input forced into a C view} {
    # make sure the view inside is really a C data structure
    v9 get [v9 meta {vdat abc:S,def:S {} {}}] * 0
} {abc def}

test vqx-18 {column names of the empty meta-view} {
    v9 names ""
} {name type subv}

test vqx-19 {column types of the empty meta-view} {
    v9 types ""
} {S I V}

test vqx-20 {size of a nested meta-view} {
    v9 size {a[b]}
} 1

test vqx-21 {size of an empty nested view} {
    v9 size {vdat a[b] {}}
} 0

test vqx-22 {size a nested view with contents} {
    set Z {vdat a[b] {{vdat b {x xx}} {vdat b {y yy yyy}} {vdat b {z zz}}}}
    v9 size $Z
} 3

test vqx-23 {meta-view of a nested view} {
    v9 meta $Z
} {a[b:S]}

test vqx-24 {subview access into a nested view is lazy} {
    v9 at $Z 1 0
} [list at $Z 1 0] ;# not {vdat b {y yy yyy}} !

test vqx-25 {meta-view of subview} {
    v9 meta [v9 at $Z 1 0]
} b:S

test vqx-26 {size of subview} {
    v9 size [v9 at $Z 1 0]
} 3

test vqx-27 {contents of subview} {
    v9 get [v9 at $Z 1 0] * *
} {y yy yyy}

test vqx-28 {size of example data view} {
    v9 size $V
} 3

test vqx-29 {cannot change an item in a data view} {
    list [catch { v9 atset $V 1 0 999 } E] $E
} {1 {not a storage view: vdat A:I,B:I {1 11 111} {2 22 222}}}

test vqx-30 {cannot replace rows in a data view} {
    list [catch { v9 replace $V 1 0 0 } E] $E
} {1 {not a storage view: vdat A:I,B:I {1 11 111} {2 22 222}}}

test vqx-31 {create a storage from the data view} {
    v9 storage $V S
} {vref ::S}

test vqx-32 {make sure it returns a vref} {
    set S [S]
} {vref ::S}

test vqx-33 {make sure contents is still the original view} {
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 3 {{1 2} {11 22} {111 222}}}

test vqx-34 {set item in a storage, return is still same vref} {
    v9 atset $S 1 0 888
} $S

test vqx-35 {check that the change has been applied inside the storage} {
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 3 {{1 2} {888 22} {111 222}}}

test vqx-36 {make a second change} {
    v9 atset $S 1 1 999
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 3 {{1 2} {888 999} {111 222}}}

test vqx-37 {replace 0 rows by 0 rows, i.e. no op} {
    v9 replace $S 1 0 0
} $S

test vqx-38 {check that the storage contents is still the same} {
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 3 {{1 2} {888 999} {111 222}}}

test vqx-39 {replace 1 row with default values} {
    v9 replace $S 1 1 1
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 3 {{1 2} {0 0} {111 222}}}

test vqx-40 {replace 1 row with 1 new row} {
    v9 replace $S 1 1 [v9 def A:I,B:I 666 777]
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 3 {{1 2} {666 777} {111 222}}}

test vqx-41 {delete 1 row} {
    v9 replace $S 1 1 0
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 2 {{1 2} {111 222}}}

test vqx-42 {insert 1 row} {
    v9 replace $S 1 0 [v9 def A:I,B:I 444 555]
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 3 {{1 2} {444 555} {111 222}}}

test vqx-43 {replace 1 row by 2} {
    v9 replace $S 1 1 [v9 def A:I,B:I 66 77 88 99]
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 4 {{1 2} {66 77} {88 99} {111 222}}}

test vqx-44 {replace 2 rows by 1} {
    v9 replace $S 1 2 [v9 def A:I,B:I 44 55]
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 3 {{1 2} {44 55} {111 222}}}

test vqx-45 {replace all 3 rows by 4} {
    v9 replace $S 0 3 [v9 def A:I,B:I 7 8 5 6 3 4 1 2]
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 4 {{7 8} {5 6} {3 4} {1 2}}}

test vqx-46 {delete first 3 rows} {
    v9 replace $S 0 3 0
    list [v9 meta $S] [v9 size $S] [v9 get $S *]
} {A:I,B:I 1 {{1 2}}}

test vqx-47 {set up a storage with a nested view} {
    set T [v9 storage $Z T]
} {vref ::T}

test vqx-48 {verify contents returns lazy subviews} {
    list [v9 meta $T] [v9 size $T] [v9 get $T *]
} {{a[b:S]} 3 {{{at {vref ::T} 0 0}}\
               {{at {vref ::T} 1 0}}\
               {{at {vref ::T} 2 0}}}}

test vqx-49 {extract all subviews values} {
    list [v9 get [v9 at $T 0 0]] [v9 get [v9 at $T 1 0]] [v9 get [v9 at $T 2 0]]
} {{x xx} {y yy yyy} {z zz}}

test vqx-50 {change an item inside a subview} {
    v9 atset [v9 at $T 1 0] 1 0 YY
} {at {vref ::T} 1 0}

test vqx-51 {shorthand for access to subview} {
    set U [v9 at $T 1 0]
} {at {vref ::T} 1 0}

test vqx-52 {verify changed subview} {
    list [v9 meta $U *] [v9 size $U *] [v9 get $U *]
} {b:S 3 {y YY yyy}}

test vqx-53 {extract all subviews values} {
    list [v9 get [v9 at $T 0 0]] [v9 get [v9 at $T 1 0]] [v9 get [v9 at $T 2 0]]
} {{x xx} {y YY yyy} {z zz}}

test vqx-54 {replace a row inside a subview by 3 new ones} {
    v9 replace [v9 at $T 1 0] 1 1 [v9 def b:S a b c]
} {at {vref ::T} 1 0}

test vqx-55 {shorthand for access to subview} {
    set U [v9 at $T 1 0]
} {at {vref ::T} 1 0}

test vqx-56 {verify changed subview} {
    list [v9 meta $U *] [v9 size $U *] [v9 get $U *]
} {b:S 5 {y a b c yyy}}

test vqx-57 {extract all subviews values} {
    list [v9 get [v9 at $T 0 0]] [v9 get [v9 at $T 1 0]] [v9 get [v9 at $T 2 0]]
} {{x xx} {y a b c yyy} {z zz}}

test vqx-58 {keep a reference to row 1 subview} {
    set S [v9 at $T 1 0]
} {at {vref ::T} 1 0}

test vqx-59 {check its contents} {
    v9 get $S
} {y a b c yyy}

test vqx-60 {delete row 1 subview} {
    v9 replace $T 1 1 0
    list [v9 size $T] [v9 get [v9 at $T 0 0]] [v9 get [v9 at $T 1 0]]]
} {2 {x xx} {z zz]}}

test vqx-61 {the saved view ref will now show row 1, confirms proper invalidation} {
    v9 get $S
} {z zz}

cleanup {E S T U V X Y Z} {S T}
