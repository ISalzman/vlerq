VLERQ TECH NOTES
================

These work-in-progress notes describe various design aspects of Vlerq.

The functionality of Vlerq is divided into two layers: _views_ and _dataflow_.
The views layer does the "real" processing. The dataflow layer is built on top
and is responsible for lazy evaluation and change propagation.

The views layer doesn't know about the dataflow layer and has no pointers to it.


Basic data types
----------------

**Views** are a general purpose data structure. At the views level, there are
many fairly straightforward functions, implementing operations on views and
dealing with their construction and destruction.

Views are manually reference-counted, using `IncViewRef` and `DecViewRef`.

Views are made up of columns, the C struct name for that is `Sequence`, which
are also reference-counted using `AdjustSeqRefs`.

A view is also a sequence, i.e. a sequence of columns. The `{Inc,Dec}ViewRef`
functions are thin wrappers around `AdjustSeqRefs`. Which also means that there
is only one ref-counted type of object, and that a single uniform ref-counting
mechanism is used for both views and columns.

A **column** is a (seqptr, colnum) tuple, i.e. a sequence pointer and a column
index. The C struct name is `Column`, they are usually passed around by value.

An **item** is a union which holds all sorts of values. Items are used to pass
data around which can have varying types. Items are not used inside columns,
only between functions - to get around static typing in C. The `Item` struct is
a C union without type tag - these are either implicit in each context or they
must be passed around separately. The `ItemTypes` enum defines `IT_*` constants
for all the possible types.

To extract an item from a column `c` at row `r`, when its type is _not_ known:

    Item item;
    ItemTypes type;
    
    item.c = column;
    type = GetItem(r, &item);

The result is left in the `item` variable, and the type is returned.

If the type is known to be -say- a string, things become a lot more convenient:

    const char* s = GetColItem(r, c, IT_string).s;

The `IT_string` type is only passed in for debugging purposes, failure to match
will throw an error during development.


The Views layer
---------------

The views layer can be used by itself, without any dataflow. In this mode, the
Vlerq code becomes very similar to Metakit: a set of operators on views.

This has been used to implement a basic Vlerq binding for Python. It does not
know about lazy evaluation or dataflow, it just interfaces to view operators.

Views are sequences of columns.  Views with zero columns are allowed, in which 
case they can only have a non-negative size.  To represent such views, a fake
column is used since it is the column which provides a row count.

Columns are used by views, but they can be shared by more than one view.
Operators such as `cremap` do nothing but shuffle columns around. As another
example, the `pair` operator takes the columns of two input views and constructs
a new view with all columns combined side-by-side. The sequences in these
columns are not copied - the same column gets used in both its original view and
the result. Reference counts on columns (on sequences, to be precise) make sure
that no bad things happen when the original view is no longer in use.

An **indirect view** is a view which uses one common sequence for all columns.
These are used for views which are based on other views, but which need to apply
some common processing for all accesses, i.e. regardless of which column. One
example of this is the `remap` operator, which applies a mapping to the row
before passing an access request on to an underlying view. In this case, a
special remapping sequence is used to pass-through all accesses. It has the map
and the reference to the parent view. The crucial point here is that the
incoming access column index is available and gets passed on after the row
number has been adjusted through the map.

All sequences, i.e. both for views and for columns, have a number of spare slots
which can be used depending on the type of view or column involved. This number
is currently set to 4, which seems sufficient to handle all cases. Each slot can
hold either an integer or a pointer. Again, it is up to the specific view or
column implementation to use these slots in whatever way they like.


The Dataflow layer
------------------

The dataflow layer is currently (early 2007) only being implemented for Tcl.
All dataflow objects are based on `Tcl_obj*` pointers (a.k.a. `Object_p`).

Dataflow is based on a simple "lazy instantiation" mechanism: an `Object_p`
initially contains a **description** of a view, as a Tcl list. This can be
either a materialized view, in the form of a `def` or a `data` view operator
with data provided in Tcl lists, or it is a view derived from other views, such
as joins, sorts, slices. In this case too, the `Object_p` contains a Tcl list,
naming the operator and all its operands - some of which may be views.

The instantiation aspect is brought in when a `View_p` is requested from the
`Object_p` using the `ObjAsView` C function.   Several things happen next:

  * the list is converted or the requested view operator is evaluated
  * the resulting `View_p` will be stored in `internalRep.twoPtrValue.ptr1`
  * the list is converted to a `Seq_p` before its internal rep is lost
  * that `Seq_p` will be stored in `internalRep.twoPtrValue.ptr2`
  * add this object as dependency to all arguments which are view objects
  * finish off by setting the Tcl `typePtr` of this object to "view"

After these steps, the `Object_p` will have transformed itself from a Tcl list
to a Tcl view object. An essential aspect for dataflow is that this object has
now also become _dependent_ on all the view objects it is based on.

Whenever a view changes (this complicated topic is treated separately below),
the logic is such that changes are always initiated from the dataflow layer.
What the change will do is to invalidate all dependent views, by asking each
dependent object to revert to its original Tcl list representation. As a result,
this removes all dependencies and will recursively trigger invalidation of all
_their_ dependencies as well.

The next time a `View_p` is needed, the whole process repeats itself: i.e.
reconstruct the view, and add all dependencies back in again.


Mutable views
-------------

All changes to views are handled by special "mutable views". On the outside,
these look like the original view with all changes applied, but internally
mutable views track all changes as _differences_ w.r.t. the original.

Mutable views come into existence when one of two modifying view operators is
applied to a view. The two operators are `set` and `replace` - with `insert`,
`append`, and `delete` built on top as special cases of `replace`.

When a modification is made to a non-mutable view, a new empty mutable view is
created, pointing to the original view but with no changes yet. Once mutable,
the requested operation is applied to it. All further modifications will be
accumulated in that same mutable view.

**MORE INFO TO BE ADDED LATER**


Building and testing
--------------------

Vlerq needs to run in many different configurations. The darcs repository is
only intended for use on my own personal machine, although several targets in
the top-level `Makefile` will probably work elsewhere. Out of the box, `make`
and `make test` will build and run a test suite on Linux, respectively.

By setting a special `ARCHSUFFIX` environment variable appropriately, this same
makefile should also work as is on two other systems:

  * `export ARCHSUFFIX=.macosx` - build on Mac OS X (ppc or intel)
  * `export ARCHSUFFIX=.win32` - build on Windows using Mingw and MSYS

For general use, the idea is to _generate_ a more conventional portable project.
For example: for Tcl, `make tea` will generate a single C source file
which ends up as `generic/vlerq.c` inside a standard TEA3-based Tcl extension,
called "vqtcl". This generated source code ends up in a public CVS repository
which can be accessed as follows:

    cvs -d :pserver:anonymous@equi4.com:/home/cvs co -d vqtcl vlerq/tcl

The reason for these paths and naming choices is to support more languages, each
with their own different source tree and build conventions. Early versions exist
for Ruby, Python, and Objective-C, using make targets `ruby`, `python`, and
`objc`, respectively.

Version numbers are used in a very specific way: the development version is
always built with a _fixed_ version number of "4". True releases will always
have a fractional part in the version number. This is "4.0" as of early Dec
2006, it will probably progress as both "4.0.1" and so on for bug fixes, and as
"4.1", "4.1.1", ... for functionality changes & additions. That way, development
builds do not constantly change versions, while sources and binaries which are
likely to end up all over the place will be properly tagged. This translates
directly to: sources in darcs have one fixed version number, whereas sources in
cvs have properly tracked version number changes.
