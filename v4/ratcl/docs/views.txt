'''Views''' are the central concept in Ratcl. A view represents a rectangular
data structure, consisting of ''rows'' and ''columns'' of ''cells''.

Views are a generalization of arrays, structs, dictionaries, tables, and more:

* a view with one column is like an array / vector / list of elements
* a view with two columns can be used as a dictionary, with keys and values
* a view with a single row is like a struct, with named fields
* a view with N rows and M columns is like a database table

Views have the following properties:

* rows are identified by an integer index, starting at zero
* columns can be identified either by name or by index
* cells can be numbers, strings, or other views
* each column is typed: all its cells must have the same type

** Datatypes **

Columns are strongly typed: the type is part of the definition of the view. It
determines both the type of cells and the data representations used in memory
and on disk.

The following datatypes are available:

   I - integer:   32-bit integer values in the range -2147483648 .. 2147483647
   L - long:   64-bit long integers, equivalent to the "long long" type in C
   F - float:   32-bit floating point numbers, approx. 6 digits precision
   D - double:   64-bit floating point numbers, approx. 17 digits precision
   S - string:   text strings encoded as UTF-8, can be empty
   B - bytes:   byte arrays of zero or more unsigned 8-bit bytes
   V - view:   a cell itself can be a view, i.e. a subview of the parent view

Each datatype implies a natural order which is used for comparisons and sorting.

** Subviews **

TBD

** Meta-views **

TBD

** Unusual views **

Views need not contain any data. One type of empty view is a view with no rows -
which can still contain columns. The meta-view of a view lists all the columns
of that view, whether it has any rows or not.

The other type of empty view is a view with no columns. Such a view can still
"contain" rows, even though each row is empty. A 3-row empty view is not the
same as a 5-row empty view: the size of the former is 3 and the size of the
latter is 5. There are a occasional uses for such views and they produce quite
normal results when view operators are applied to them: the product of two empty
3- and 5-row views is the empty 15-row view, so the name of the relational
"product" operator is quite appropriate - even in such a special case.

All 0-column views in Ratcl are represented by a non-negative integer, namely
their row count. This further reinforces the analogy with natural numbers.

There is one other special view: the empty meta-view, i.e. the view with the
same structure as all meta-views, but with no rows. Although rarely used in
application code, this is crucial for the inner workings of Ratcl. The empty
meta-view is represented in Ratcl as the empty string.

** Views vs. database tables **

Views can represent DB tables, but there are a few details to be aware of:

* a view can have duplicate rows
* column names need not be unique
* there is currently no representation for NULL

Views can be used as ''SQL tables'' by never allowing duplicate column names and
by introducing an extra ''flag column'' for each column that is ''nullable'' in
the SQL table.

Views can be used as ''relations'' - in the strict sense of Chris Date's "The
Third Manifesto" - by never allowing duplicate rows or duplicate column names.

** Choice of terminology **

The word "view" is used in many ways, by GUIs as well as databases. The choice
of this term in Ratcl is somewhat unfortunate because of the many different
meanings associated with this term.

There are nevertheless good reasons for choosing this word. The implementation
of Ratcl is based on a highly ''virtual'' mechanism which applies a variety of
operations on views to produce other views ''without copying much data''. A
sorted view, for example, is implemented as a permutation with "maps" the rows
of the original view to their sorted positions. One could say that Ratcl is all
smoke and mirrors really: a view constructed from other views will look like a
new collection of cells, yet in many cases it is just an elaborate trick to make
the result ''appear'' as a view even though it is implemented as a set of
re-mappings and indirections which still access the original view contents.

''Views are indeed really views'': they are a way of looking at data.  It does not matter whether that data "exists" in memory or on disk, as long as it is consistent with the expected result.  In other words, as long as the number of rows and columns are what you expect and as long as they contain the values you expect, it is unimportant how Ratcl produced them.  You are viewing a data collection.  And Ratcl provides operators to let you view new / derived results.