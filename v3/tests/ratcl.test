#!/usr/bin/env tclkit
# ratcl basic tests

source [file join [file dir [info script]] initests.tcl]

# %renumber<^\s*test >%

test 0 {load ratcl} {
  package require ratcl
} 3

test 1 {view exists} -body {
  view
} -returnCodes error -result {wrong # args: should be "view v ... | ..."}

set v [view {A B C} vdef {1 2 3 11 22 33 111 222 333}]

test 2 {} {
  view $v names
} {A B C}

test 3 {} {
  view $v types
} {S S S}
  
test 4 {} {
  view $v width
} 3

test 5 {} {
  vget $v *
} {{1 2 3} {11 22 33} {111 222 333}}

test 6 {} {
  view $v first 2 | get *
} {{1 2 3} {11 22 33}}

test 7 {} {
  view $v last 2 | get *
} {{11 22 33} {111 222 333}}

test 8 {} {
  view $v reverse | get *
} {{111 222 333} {11 22 33} {1 2 3}}

test 9 {} {
  view $v repeat 2 | get *
} {{1 2 3} {11 22 33} {111 222 333} {1 2 3} {11 22 33} {111 222 333}}

test 10 {} {
  view $v spread 2 | get *
} {{1 2 3} {1 2 3} {11 22 33} {11 22 33} {111 222 333} {111 222 333}}

test 11 {} {
  view $v dump
} { \
  A    B    C  
  ---  ---  ---
  1    2    3  
  11   22   33 
  111  222  333}

test 12 {} {
  view $v html
} {<table><style type="text/css"><!-- table {border-spacing:0; border:1px solid #aaa; margin:0 0 2px 0} th {background-color:#eee; font-weight:normal} td {vertical-align:top} th,td {padding:0 2px} th.row,td.row {color:#aaa; font-size:75%} --></style>
<tr><th class="row"></th><th>A</th><th>B</th><th>C</th></tr>
<tr><td align="right" class="row">0</td><td>1</td><td>2</td><td>3</td></tr>
<tr><td align="right" class="row">1</td><td>11</td><td>22</td><td>33</td></tr>
<tr><td align="right" class="row">2</td><td>111</td><td>222</td><td>333</td></tr>
</table>
}

test 13 {} {
  namespace eval blah {
    namespace import ::ratcl::vopdef
    vopdef haha {v} { return abc }
  }
  view - haha
} {abc}

namespace forget blah

test 14 {setup test data} {
  set R [view {A B C}   vdef {a b c d a f c b d}]
  set S [view {D E F}   vdef {b g a d a f}]
  set T [view {A B C D} vdef {a b c d a b e f b c e f e d c d e d e f a b d e}]
  set U [view {C D E}   vdef {c d e c d f d e f}]
  set V [view {C D}     vdef {c d e f}]
  set W [view {A B C}   vdef {1 2 3 a b c}]
  set X [view {D E:I F} vdef {a 100 aa b 20 bb c 3 cc}]
  set Y [view D         vdef {y}]
  set Z [view E         vdef {}]
  set r {}
  foreach v {R S T U V W X Y Z} { lappend r [vget [set $v] #] }
  set r
} {3 2 6 3 2 2 3 1 0}

test 15 {concat} {
  set v [view $R concat $W]
  list [view $v names] [view $v structure] [vget $v]
} {{A B C} SSS {a b c d a f c b d 1 2 3 a b c}}

test 16 {concat compatible columns} {
  view $R concat $S | get
} {a b c d a f c b d b g a d a f}

test 17 {concat different column types} -body {
  view $S concat $X | get #
} -returnCodes error -result {incompatible columns}

test 18 {concat more columns} -body {
  view $R concat $T | get #
} -returnCodes error -result {incompatible columns}

test 19 {pair} {
  set v [view $W pair $X] 
  list [view $v names] [view $v structure] [vget $v]
} {{A B C D E F} SSSSIS {1 2 3 a 100 aa a b c b 20 bb}}

test 20 {product} {
  set v [view $W product $S] 
  list [view $v names] [view $v structure] [vget $v]
} {{A B C D E F} SSSSSS {1 2 3 b g a 1 2 3 d a f a b c b g a a b c d a f}}

test 21 {product with one row} {
  set v [view $W product $Y] 
  list [view $v names] [view $v structure] [vget $v]
} {{A B C D} SSSS {1 2 3 y a b c y}}

test 22 {product with no rows} {
  set v [view $W product $Z] 
  list [view $v names] [view $v structure] [vget $v]
} {{A B C E} SSSS {}}

test 23 {remap} {
  set v [view $T remap {2 1 0 4 5}] 
  list [view $v names] [view $v structure] [vget $v]
} {{A B C D} SSSS {b c e f a b e f a b c d e d e f a b d e}}

test 24 {mapcols} {
  set v [view $T mapcols 0 1] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B} SS {a b a b b c e d e d a b}}

test 25 {mapcols by name} {
  set v [view $T mapcols A B] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B} SS {a b a b b c e d e d a b}}

test 26 {columns unique} {
  set v [view $T mapcols 0 1 | unique] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B} SS {a b b c e d}}

test 27 {omit} {
  set v [view $T mapcols -omit 2 3] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B} SS {a b a b b c e d e d a b}}

test 28 {omit reorder} {
  set v [view $T mapcols -omit 3 2] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B} SS {a b a b b c e d e d a b}}

test 29 {unique on unique} {
  set v [view $R unique] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {a b c d a f c b d}}

test 30 {unique on dups} {
  set v [view {A B C D} vdef {e d e f e d e f e d e f} | unique] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B C D} SSSS {e d e f}}

test 31 {unique on first col} {
  set v [view {A B} vdef {a 0 b 1 c 2 a 3 a 4 b 5 d 6 d 7 e 8}]
  view $v unique A | get
} {a 0 b 1 c 2 d 6 e 8}

test 32 {unique on second col} {
  set v [view {A B} vdef {0 a 1 b 2 c 3 a 4 a 5 b 6 d 7 d 8 e}]
  view $v unique B | get
} {0 a 1 b 2 c 6 d 8 e}

test 33 {unique on two cols} {
  set v [view {A B C} vdef {A a 0 A a 1 B b 2 B c 3 B c 4 C c 5}]
  view $v unique A B | get
} {A a 0 B b 2 B c 3 C c 5}

test 34 {unique on two cols reversed} {
  set v [view {A B C} vdef {A a 0 A a 1 B b 2 B c 3 B c 4 C c 5}]
  view $v unique B A | get
} {A a 0 B b 2 B c 3 C c 5}

test 35 {project reorder by name} {
  set v [view $T project C A B] 
  list [view $v names] [view $v structure] [vget $v]
} {{C A B} SSS {c a b e a b e b c c e d e e d d a b}}

test 36 {project reorder by position} {
  set v [view $T project 2 0 1] 
  list [view $v names] [view $v structure] [vget $v]
} {{C A B} SSS {c a b e a b e b c c e d e e d d a b}}

test 37 {project reduce} {
  set v [view $T project A B] 
  list [view $v names] [view $v structure] [vget $v]
} {{A B} SS {a b b c e d}}

test 38 {project on no cols} {
  set v [view $T project] 
  list [view $v names] [view $v structure] [vget $v]
} {{} {} {}}

test 39 {omit} {
  set v [view $T project -omit C D] 
  list [view $v names] [view $v structure] [vget $v]
} {{A B} SS {a b b c e d}}

test 40 {omit reorder} {
  set v [view $T project -omit D C] 
  list [view $v names] [view $v structure] [vget $v]
} {{A B} SS {a b b c e d}}

test 41 {as} {
  view $R as view-R
  list [view-R names] [view-R structure] [view-R get]
} {{A B C} SSS {a b c d a f c b d}}

test 42 {as view access} {
  set v [view-R]
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {a b c d a f c b d}}

test 43 {as pass through} {
  view $S as view-S | get
} {b g a d a f}

test 44 {as when orig is gone} {
  unset S
  view-S get
} {b g a d a f}

test 45 {as from different ns} {
  namespace eval dummy {
    view-S get
  }
} {b g a d a f}

test 46 {orig when as is cleaned up} {
  rename view-R ""
  view $R get
} {a b c d a f c b d}

test 47 {as renamed} {
  rename view-S view-S2
  view-S2 get
} {b g a d a f}

test 48 {as renamed to another ns} {
  rename view-S2 dummy::view-S3
  dummy::view-S3 get
} {b g a d a f}
  
test 49 {restore variable} {
  set S [dummy::view-S3]
  vget $S
} {b g a d a f}

namespace forget dummy

test 50 {union} {
  set v [view $R union $W] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {a b c d a f c b d 1 2 3}}

test 51 {union compatible columns} {
  set v [view $R union $S]
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {a b c d a f c b d b g a}}

test 52 {union different column types} -body {
  view $S union $X | get #
} -returnCodes error -result {incompatible columns}

test 53 {union different column count} -body {
  view $R union $T | get #
} -returnCodes error -result {incompatible columns}

test 54 {except} {
  set v [view $R except $W] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {d a f c b d}}

test 55 {except different columns} {
  set v [view $R except $S]
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {a b c c b d}}

test 56 {except incompatible columns} -body {
  view $R except $X | get #
} -returnCodes error -result {incompatible columns}

test 57 {except different column count} -body {
  view $R except $T | get #
} -returnCodes error -result {incompatible columns}

test 58 {intersect} {
  set v [view $R intersect $W] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {a b c}}

test 59 {intersect different columns} {
  set v [view $R intersect $S]
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {d a f}}

test 60 {intersect incompatible columns} -body {
  view $R intersect $X | get #
} -returnCodes error -result {incompatible columns}

test 61 {intersect different column count} -body {
  view $R intersect $T | get #
} -returnCodes error -result {incompatible columns}

  # union works, leaves all dups in v
test 62 {dups in union match} {
  set v [view D vdef {x x x y y z}] 
  view $v union $Y | get
} {x x x y y z}

test 63 {dups in union no match} {
  set v [view D vdef {x x x a a z}] 
  view $v union $Y | get
} {x x x a a z y}

test 64 {dups in union to self} {
  set v [view D vdef {x x x y y z}] 
  view $v union $v | get
} {x x x y y z}

  # except does not drop duplicates
test 65 {dups in except match} {
  set v [view D vdef {x x x y y z}] 
  view $v except $Y | get
} {x x x z}

test 66 {dups in except no match} {
  set v [view D vdef {x x x a a z}] 
  view $v except $Y | get
} {x x x a a z}

test 67 {dups in except to self} {
  set v [view D vdef {x x x y y z}] 
  view $v except $v | get
} {}

  # intersect keeps duplicates
test 68 {dups in intersect match} {
  set v [view D vdef {x x x y y z}] 
  view $v intersect $Y | get
} {y y}

test 69 {dups in intersect no match} {
  set v [view D vdef {x x x a a z}] 
  view $v intersect $Y | get
} {}

test 70 {dups in intersect to self} {
  set v [view D vdef {x x x y y z}] 
  view $v intersect $v | get
} {x x x y y z}

test 71 {pick} {
  view $T pick {0 1 0 1 1 0} | get
} {a b e f e d c d e d e f}

test 72 {sort strings} {
  set v [view $R sort] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {a b c c b d d a f}}

test 73 {sort reversed strings} {
  set v [view $R reverse | sort] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {a b c c b d d a f}}

test 74 {sort strings and int} {
  set v [view $X sort] 
  list [view $v names] [view $v structure] [view $v get]
} {{D E F} SIS {a 100 aa b 20 bb c 3 cc}}

test 75 {sort on strings} {
  set v [view $R sort B] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {d a f a b c c b d}}

test 76 {sort on integers by column name} {
  set v [view $X sort E] 
  list [view $v names] [view $v structure] [view $v get]
} {{D E F} SIS {c 3 cc b 20 bb a 100 aa}}

test 77 {sort on integers by column position} {
  set v [view $X sort 1] 
  list [view $v names] [view $v structure] [view $v get]
} {{D E F} SIS {c 3 cc b 20 bb a 100 aa}}

test 78 {sort on integers by relative column position} {
  set v [view $X sort -2] 
  list [view $v names] [view $v structure] [view $v get]
} {{D E F} SIS {c 3 cc b 20 bb a 100 aa}}

  # configure -verbose pe

test 79 {make sure sort is stable} {
  set v [view {A B:I} vdef {A 3 A 1 A 2 B 1 D 1 D 2 C 1 C 2 C 3}]
  view $v sort B | reverse | sort A | get
} {A 3 A 2 A 1 B 1 C 3 C 2 C 1 D 2 D 1}

test 80 {clone view} {
  set v [view $R clone] 
  list [view $v names] [view $v structure] [view $v get]
} {{A B C} SSS {}}

test 81 {take none} {
  view $R take 0 | get
} {}

test 82 {take one} {
  view $R take 1 | get
} {a b c}

test 83 {take two} {
  view $R take 2 | get
} {a b c d a f}

test 84 {take more} {
  view $R take 4 | get
} {a b c d a f c b d a b c}

test 85 {take last} {
  view $R take -1 | get
} {c b d}

test 86 {take more than last} {
  view $R take -4 | get
} {c b d d a f a b c c b d}

test 87 {tag} {
  set v [view $R tag N]
  list [view $v names] [view $v structure] [view $v get]
} {{A B C N} SSSI {a b c 0 d a f 1 c b d 2}}

test 88 {multi-line commands} {
  view $R do {
    sort B
    take 5
    reverse
    get
  }
} {a b c d a f c b d a b c d a f}

test 89 {multi-line embedded} {
  view $R sort B | do {
    take 5
    reverse
  } | get
} {a b c d a f c b d a b c d a f}

test 90 {multi-line mix} {
  view $R do {
    sort B
    take 5 | reverse
  } | get
} {a b c d a f c b d a b c d a f}

test 91 {multi-line with comments} {
  view $R do {
    # this is a comment
    sort B
    # so is this, even with { and "
    take \
      5
    # but we need to balance the }'s
    reverse | get
  }
} {a b c d a f c b d a b c d a f}

test 92 {multi-line with variable} {
  set v [view {X Y} vdef {1 a 2 b 3 c}]
  set n 1
  view $v do {
    project Y
    get $n *
  }
} b

test 93 {multi-line with call} {
  set n 0
  view $v do {
    project Y
    get [incr n] *
  }
} b

test 94 {multi-line with variable in condition} {
  set n 2
  view $v do {
    where {$(X) == $n}
    get
  }
} {2 b}

test 95 {slice} {
  view $R slice 1 2 1 | get
} {d a f c b d}

test 96 {slice} {
  view $R slice 2 2 -1 | get
} {c b d d a f}

test 97 {slice} {
  view $R slice 0 2 2 | get
} {a b c c b d}

test 98 {slice} {
  view $R slice 1 3 0 | get
} {d a f d a f d a f}

test 99 {slice} {
  view $R slice 1 0 1 | get
} {}

test 100 {where var expansion} {
  set n 2
  view o:I vdef {1 2 3} | where {$(o) == $n} | get
} 2

test 101 {string columns} {
  view {A B C} vdef {a b c d e f g h i} | where {$(A) eq "a"} | get
} {a b c}

test 102 {string columns containing numbers} {
  view {A B C} vdef {1 2 3 4 5 6 7 8 9} | where {$(A) eq "1"} | get
} {1 2 3}

test 103 {omit named} {
  set v [view $T mapcols -omit A B] 
  list [view $v names] [view $v structure] [view $v get]
} {{C D} SS {c d e f e f c d e f d e}}

test 104 {omit named meta} {
  list [vget $v @ #] [vget $v @ * 0] [vget $v * 1]
} {2 {C D} {d f f d f e}}

test 105 {omit named meta} {
  vget $v @ * *
} {C S {} D S {}}

test 106 {omit named meta} {
  vget $v @ * 0
} {C D}

test 107 {meta contents} {
  vget $T @ * 0
} {A B C D}

test 108 {remap meta contents} {
  view $T remap {2 3 1} | names
} {A B C D}

test 109 {remap meta contents} {
  view $T cremap {2 3 1} | get @ * 0
} {C D B}

test 110 {remap meta contents} {
  view $T cremap {2 3 1} | names
} {C D B}
  
test 111 {find single key} {
  view $R mapcols B | find a
} 1

test 112 {miss single key} {
  view $R mapcols B | find A
} -1

test 113 {find compound key} {
  view $T mapcols D C | find e d
} 5

test 114 {miss compound key} {
  view $T mapcols C D | find e d
} -1

test 115 {min} {
  view X vdef {5 4 3 8 7 6} | min X
} 3

test 116 {min above} {
  view X vdef {5 4 3 8 7 6} | min X 9
} 3

test 117 {min below} {
  view X vdef {5 4 3 8 7 6} | min X 2
} 2

test 118 {min empty} {
  view 0 min X
} {}

test 119 {min none} {
  view 0 min X 1
} 1

test 120 {max} {
  view X vdef {5 4 3 8 7 6} | max X
} 8

test 121 {max above} {
  view X vdef {5 4 3 8 7 6} | max X 9
} 9

test 122 {max below} {
  view X vdef {5 4 3 8 7 6} | max X 2
} 8

test 123 {max empty} {
  view 0 max X
} {}

test 124 {max none} {
  view 0 max X 1
} 1

test 125 {prod factorial} {
  view N vdef {1 2 3 4 5} | prod N
} 120

test 126 {prod none} {
  view 0 prod N
} 1

test 127 {sum} {
  view 6 tag N | sum N
} 15

test 128 {sum none} {
  view 0 sum N
} 0

test 129 {transpose} {
  set v [view {A B C} vdef {1 2 3 4 5 6 7 8 9} | transpose]
  list [view $v names] [view $v structure] [vget $v]
} {{x0 x1 x2} SSS {1 4 7 2 5 8 3 6 9}}

test 130 {transpose ints} {
  set v [view {A:I B:I C:I} vdef {1 2 3 4 5 6 7 8 9} | transpose X:I]
  list [view $v names] [view $v structure] [vget $v]
} {{X0 X1 X2} III {1 4 7 2 5 8 3 6 9}}

test 131 {use vop} {
  view 1 use 2
} 2

test 132 {debug vop} -body {
  view $T debug transpose
  return
} -match glob -output {\
 rows-in  col  msec  view-operation
 -------  ---  ----  --------------
       6    4     ?  transpose
       4    6  ----  --------------
}

test 133 {use and debug vops} -body {
  view - debug {
    use {A B}
    vdef {1 2 3 4 5 6}
    transpose
    get
  }
} -result {1 3 5 2 4 6} -match glob -output {\
 rows-in  col  msec  view-operation
 -------  ---  ----  --------------
                  ?  use {A B}
                  ?  vdef {1 2 3 4 5 6}
       3    2     ?  transpose
       2    3     ?  get
 -------  ---  ----  --------------
}

test 134 {debug comments} -body {
  view $T debug {
    # start
    transpose
    # empty lines are not shown
    
    structure
    # end
  }
} -result SSSSSS -match glob -output {\
 rows-in  col  msec  view-operation
 -------  ---  ----  --------------
                     # start
       6    4     ?  transpose
                     # empty lines are not shown
       4    6     ?  structure
                     # end
 -------  ---  ----  --------------
}

test 135 {lookup vop} {
  set v [view A vdef {c d e a b c f d e}]
  set w [view A vdef {a b c d e}]
  view $v lookup $w
} {2 3 4 0 1 2 -1 3 4}

::tcltest::cleanupTests
