<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>
      LuaVlerq Reference
    </title>
  </head>
  <body>
    <h1>
      LuaVlerq Reference
    </h1>
    <p>
      Version 1.7.0 (DRAFT)
    </p>
    <p>
      Copyright Â© 2008 Jean-Claude Wippler.
    </p>
    <hr />
    <h1>
      1 - Introduction
    </h1>
    <p>
      LuaVlerq is a <a href="http://www.lua.org">Lua</a> extension for managing structured datasets. It is part of the <a href="http://www.vlerq.org">Vlerq</a> project.
    </p>
    <h1>
      2 - Getting started
    </h1>
    <p>
      Get the latest source code from svn:
    </p>
    <pre>
      <strong>svn co svn://svn.vlerq.org/vlerq/branches/v7 vlerq</strong>
</pre>
    <p>
      Edit <code>vlerq/src/config</code> as needed, then proceed as follows:
    </p>
    <pre>
      <strong>cd vlerq/src</strong>
      <strong>make</strong>
      <strong>make test   </strong>     # &lt;-- optional
      <strong>make install</strong>     # &lt;-- optional
</pre>
    <p>
      On to the first example:
    </p>
    <pre>
      $ <strong>lua</strong>
      <em>Lua 5.1.2  Copyright (C) 1994-2007 Lua.org, PUC-Rio</em>
      &gt; <strong>require 'vq'</strong>
      &gt; <strong>vq{1,2,3}:p()</strong><em>
        ?
        -
        1
        2
        3</em>
      &gt;
</pre>
    <p>
      Explanation: <strong>vq</strong> is the name of the LuaVlerq module and also the interface through which all objects are constructed. In this example, a call with a single table argument turns that table into a LuaVlerq object, which is then printed on stdout using its "<strong>p</strong>" operator and the "<code>:...()</code>" Lua notation for method calls.
    </p>
    <p>
      Here is a more elaborate example:
    </p>
    <pre>
      &gt; <strong>(vq{meta='A';1,2,3}..vq{meta='B';4,5,6}):reverse():p()</strong><em>
        A  B
        -  -
        3  6
        2  5
        1  4</em>
      &gt;
</pre>
    <p>
      Explanation: two tables are used, this time each with explicit column names. Once converted to LuaVlerq objects, they are "paired" (i.e. concatenated in the horizontal direction). The result is a new object, of which the rows are printed in reverse order.
    </p>
    <p>
      These examples only scratch the surface of LuaVlerq, illustrating how operations are applied to combine and re-organize data structures in different ways. The <strong>p()</strong> method is mostly a convenience method for debugging, in normal use the resulting objects would be saved in variables for further use.
    </p>
    <blockquote>
      <p>
        Note: the typographical conventions used above will be used for the remainder of this document. User input is in <strong>bold</strong>. Machine output is in <em>italics</em>.
      </p>
    </blockquote>
    <h1>
      3 - Concepts
    </h1>
    <p>
      LuaVlerq introduces a bit of terminology, all of which is essential to understand how LuaVlerq works with its data and what its operators do. The key terms and concepts are described in this section.
    </p>
    <h2>
      3.1 - Views
    </h2>
    <p>
      The "<strong>view</strong>" is the central data structure in LuaVlerq. It is a rectangular collection of cells, with rows and columns. A cell can store at most one value. Rows are indexed by their ordinal position in the view. Columns are identified either by their ordinal position or by name (if they have one).
    </p>
    <p>
      <em>Row and column positions are zero-based</em>, i.e. rows run from 0 through &lt;numrows&gt;-1, and columns from 0 through &lt;numcols&gt;-1.
    </p>
    <p>
      Rows are uniquely identified by their position. When rows are inserted or deleted in the middle of a view, all following row positions change.
    </p>
    <p>
      Column names may be absent (the empty string), and they need not be unique. In the case of duplicate column names, column access by name is not well-defined - this can be resolved by adjusting all such column names in a view.
    </p>
    <p>
      Columns are <strong>typed</strong>: all values in a single column must be of the same basic data type. The types supported are: integer (up to 32b), longs (64b), floats (32b), doubles (64b), strings (0-terminated), bytes (arbitrary byte sequences), and (sub-)views.
    </p>
    <h2>
      3.2 - Rows
    </h2>
    <p>
      In addition to view objects, LuaVlerq supports lightweight row objects. These are (view,index) pairs which identify a row in a view. Being objects, rows can be passed around as needed. A row in a view can be treated as a collection of values in named fields, and as such very much acts like an object itself, whose state happens to be stored in a view.
    </p>
    <blockquote>
      <p>
        Note: row positions are <em>not</em> adjusted when rows are inserted or deleted from the associated view. This is not as bad as it may seem, due to the availability of "mutable views" (these are described later on).
      </p>
    </blockquote>
    <h2>
      3.3 - Subviews
    </h2>
    <p>
      A sub-view is a view stored as values in another view. Sub-views are values, not references: circular/recursive sub-view chains are not possible.
    </p>
    <h2>
      3.4 - Empty views
    </h2>
    <p>
      There are two edge cases for views: views without rows, and views without columns. Both are allowed (and so is their combination: the 0-row/0-column view). A zero-row view is simply a structured collection with no data (yet). A zero-column view is slightly unusual in that it cannot contain any values. This case is less common, but it turns out that as an edge case, 0-column views are in fact quite important. A 0-column views with N rows is in many ways similar to the integer <em>value</em> N. For example: the relational product of two 0-column views with N1 and N2 rows, respectively, produces the 0-column view with N1*N2 rows.
    </p>
    <h2>
      3.5 - Meta-views
    </h2>
    <p>
      Every view in LuaVlerq has a structure, and this structure is in fact also a view. For each column in view <code>v</code>, there is a row in its meta-view, which describes the properties of that column. All meta-views have the same structure: each row in a meta-view contains a name, a type, and a sub-view structure.
    </p>
    <p>
      Given that a meta-view is a view, it too has a meta-view (the "meta-meta-view"). Since all meta-views have the same structure, there is exactly one such meta-meta-view. It is rarely needed in day-to-day use, but it exists so that the entire view "tower" is well-defined. This is similar to the issues encountered in good database dictionaries: a closed system must be able to describe itself.
    </p>
    <h2>
      3.6 - Missing values
    </h2>
    <p>
      Each cell in a view, i.e. each row/column position holds at most one value. The type of that value is fixed for each individual column. Optionally, one or more columns can be defined to support missing values, i.e. the absence of a value (it is common to call these "null values" in SQL, but that is a <em>contradictio-in-terminis</em>).
    </p>
    <p>
      Such <em>sparse</em> views are fully supported: LuaVlerq implements both views which are nearly "full" and nearly "empty" relatively efficiently.
    </p>
    <h2>
      3.7 - Vops
    </h2>
    <p>
      As objects, views have access to a wide range of view operators or "vops". The built-in ones are described later in this document, but vops can also be defined by the application. Once defined, such custom vops become indistinguishable from the built-in ones. Furthermore, a vop can be defined either in Lua or in C (LuaVlerq itself consists of a mix of both).
    </p>
    <h2>
      3.8 - Mutable views
    </h2>
    <p>
      To provide a level of isolation between different users (within an application) of a view, there is a mechanism called the "mutable view". It adds a layer on top of an existing view where all changes made to the original are collected. From the outside, a mutable view looks like the original view with all the changes applied. Yet the original view is unaffected, and can still be accessed independent of these changes. This does not cause any copying of the view.
    </p>
    <h2>
      3.9 - Storage
    </h2>
    <p>
      LuaVlerq is designed with disk-backed storage and network-based exchanges in mind. Any view can be stored on file or sent across a communications channel in a very compact format. Later on views can be loaded on-demand, whereby file opening is instant and data only gets read off the disk when actually needed, regardless of the size or complexity of the saved view and sub-views. There is a separate "Persistence" section describing these capabilities.
    </p>
    <h1>
      4 - View operators
    </h1>
    <p>
      There are many pre-defined view operators and additional custom ones can be defined at any time. The normal way to access these operators is via Lua's ":" method-call convention, but note that <code>v1:someop(...)</code> is always equivalent to "<code>vq.someop(v1, ...)</code>".
    </p>
    <p>
      The view operators described in this section are grouped in several categories to place related ones near each other.
    </p>
    <h2>
      4.1 - View setup and details
    </h2>
    <p>
      Several important functions defy categorization - these are described first:
    </p>
    <h3>
      <code>vq(t1)</code>
    </h3>
    <p>
      Convert table <code>t1</code> into a view. This can also be written as <code>vq{...}</code> when <code>t1</code> is a literal table. Only the list portion is used, i.e. the entries stored at <code>t1[1]</code> through <code>t1[#t1]</code>. If <code>t1.meta</code> does not exist, then <code>t1</code> is converted to a view with a single un-named integer column. Otherwise <code>t1.meta</code> is used as meta-view. If 2 or more columns are defined, then values are pulled from <code>t1</code> in row-wise order.
    </p>
    <h3>
      <code>vq(n1[,m1])</code>
    </h3>
    <p>
      Create a new view with <code>n1</code> rows. If <code>m1</code> is either a string or a view, it is used as the meta-view describing the structure of the new view, otherwise an empty 0-column/n1-row view is returned.
    </p>
    <h3>
      <code>vq(s1)</code>
    </h3>
    <p>
      Convert a description string <code>s1</code> into a meta-view.
    </p>
    <h3>
      <code>#v1</code>
    </h3>
    <p>
      Return the size of <code>v1</code>, i.e. the number of rows in <code>v1</code>.
    </p>
    <h3>
      <code>tostring(v1)</code>
    </h3>
    <p>
      Return a short string describing the type, size, and structure of view <code>v1</code>.
    </p>
    <h3>
      <code>v1:cols()</code>
    </h3>
    <p>
      Return the number of columns in <code>v1</code>. This is equivalent to "<code>#v1:meta()</code>".
    </p>
    <h3>
      <code>v1:dump()</code>
    </h3>
    <p>
      Return a nicely-formatted tabular version of the contents of view <code>v1</code> as a string. Sub-views are shown as a row count.
    </p>
    <h3>
      <code>v1:html()</code>
    </h3>
    <p>
      Return an HTML rendering of the contents of view <code>v1</code> as a string (to be used as part of a complete HTML page, presumably). Unlike the <code>dump()</code> operator, this recursively renders the contents of sub-views as well.
    </p>
    <h3>
      <code>v1:meta()</code>
    </h3>
    <p>
      Return the meta-view of <code>v1</code>, describing its structure.
    </p>
    <h3>
      <code>v1:p()</code>
    </h3>
    <p>
      Display view <code>v1</code> on stdout. This is equivalent to "<code>print(v1:dump())</code>".
    </p>
    <h2>
      4.2 - Getting and setting cells
    </h2>
    <p>
      The mechanism to access and modify values in views is defined by the following three operations:
    </p>
    <h3>
      <code>v1[n1].name</code>
    </h3>
    <p>
      Access the "<code>name</code>" field of row <code>n1</code> in view <code>v1</code>. This can be used for both getting and setting cells in the designated <em>cell</em> in the view. Unlike Lua tables, <em>the <code>n1</code> index is zero-based.</em> Also, setting a cell to <em>nil</em> does not delete the cell, but marks that cell as being a missing value. Use the <code>replace()</code> operator to delete rows.
    </p>
    <h3>
      <code>v1[n1][n2]</code>
    </h3>
    <p>
      Access to column <code>n2</code> of row <code>n1</code> in view <code>v1</code>. This can be used for getting and for setting values in the designated <em>cell</em> in the view. <em>The <code>n1</code> and <code>n2</code> indices are zero-based.</em>
    </p>
    <h3>
      v1:replace(off,len[,v2])
    </h3>
    <p>
      Replace rows <code>off</code> through <code>off+len-1</code> in view <code>v1</code> with all rows in view <code>v2</code>. If present, the structure of <code>v2</code> must be compatible with <code>v1</code>. When <code>len</code> is zero, this acts as row insertion. When <code>v2</code> is nil or absent, this acts as row deletion. <em>The <code>off</code> index is zero-based.</em>
    </p>
    <h2>
      4.3 - Lua operators
    </h2>
    <p>
      Some operators are so common that they have been defned as operators in Lua itself (via metatables):
    </p>
    <h3>
      <code>v1..v2</code>
    </h3>
    <p>
      Return a new view with all columns of <code>v1</code> on the left and all the columns of <code>v2</code> on the right. This is a special case of the <strong>pair()</strong> operator, which takes an arbitrary number of input views.
    </p>
    <h3>
      <code>v1+v2</code>
    </h3>
    <p>
      Return a new view with all rows of <code>v1</code> followed by all rows of <code>v2</code>. This is a special case of the <strong>concat()</strong> operator, which takes an arbitrary number of input views.
    </p>
    <h3>
      <code>v1[n1]</code>
    </h3>
    <p>
      Return row <code>n1</code> of view <code>v1</code> as a new row object. <em>Row indices are zero-based</em>, i.e. valid rows numbers are from 0 through <code>#v1</code>.
    </p>
    <h3>
      <code>v1[v2]</code>
    </h3>
    <p>
      Return a view with rows from view <code>v1</code> "mapped" by the indices in the first column of view <code>v2</code>. The number of rows in the resulting view is the number of rows in <code>v2</code>.
    </p>
    <h3>
      <code>v1/n1</code>
    </h3>
    <p>
      Return a 1-column view, by taking just column <code>n1</code> from view <code>v1</code>. <em>Column indices are zero-based</em>, i.e. valid column numbers are 0 through <code>#v1:cols()-1</code>.
    </p>
    <h3>
      <code>v1/s1</code>
    </h3>
    <p>
      Return a 1-column view, using the first column named "<code>s1</code>".
    </p>
    <h3>
      <code>v1/v2</code>
    </h3>
    <p>
      Return a view with columns from view <code>v1</code> "mapped" by the indices in the first column of view <code>v2</code>. The number of columns in the resulting view is the number of rows in <code>v2</code>.
    </p>
    <h2>
      4.4 - Vector operators
    </h2>
    <p>
      One way to deal with views is to treat them as vectors of rows or columns. The following operators provide some convenient primitives and wrappers:
    </p>
    <h3>
      <code>v1:concat(...)</code>
    </h3>
    <p>
      Return a view containing all the rows of view <code>v1</code>, followed by all the rows of each of the views passed as argument to <code>concat()</code>. All views must have a compatible structure.
    </p>
    <h3>
      <code>v1:first(n)</code>
    </h3>
    <p>
      Return a view with the first <code>n</code> rows of view <code>v1</code>, or return <code>v1</code> if <code>n</code> exceeds the row count of <code>v1</code>.
    </p>
    <h3>
      <code>v1:last(n)</code>
    </h3>
    <p>
      Return a view with the last <code>n</code> rows of view <code>v1</code>, or return <code>v1</code> if <code>n</code> exceeds the row count of <code>v1</code>.
    </p>
    <h3>
      <code>v1:pair(...)</code>
    </h3>
    <p>
      Return a view containing all the columns of view <code>v1</code>, followed by all the columns of each of the views passed as argument to <code>concat()</code>. All views must have the same number of rows.
    </p>
    <h3>
      <code>v1:reverse()</code>
    </h3>
    <p>
      Return a view with all rows from view <code>v1</code> in reversed order.
    </p>
    <h3>
      <code>v1:spread(n)</code>
    </h3>
    <p>
      Return a view, where each of the separate rows in view <code>v1</code> is repeated <code>n</code> times.
    </p>
    <h3>
      <code>v1:step([off[,step[,rate]]])</code>
    </h3>
    <p>
      Return a 1-column view with the same number of rows as view <code>v1</code>. The integer in row position <strong>x</strong> is "<code>off+(x/rate)*step</code>", where <code>off</code> defaults to 0, and both <code>step</code> and <code>rate</code> default to 1. Integer division is used here (<code>rate</code> must be at least 1).
    </p>
    <h3>
      <code>v1:times(n)</code>
    </h3>
    <p>
      Return a view, where all the rows in view <code>v1</code> are repeated <code>n</code> times.
    </p>
    <h2>
      4.5 - Set operators
    </h2>
    <p>
      When all rows in a view are unique, then standard set operators will return the expected results. Furthermore, all set operators are fully specified even when the input views are not pure sets:
    </p>
    <h3>
      <code>v1:except(v2)</code>
    </h3>
    <p>
      Return the rows of view <code>v1</code> which are not present in view <code>v2</code>. This is equivalent to "<code>v1[v1:exceptmap(v2)]</code>".
    </p>
    <h3>
      <code>v1:exceptmap(v2)</code>
    </h3>
    <p>
      Return a 1-column map of row numbers in view <code>v1</code>, for those rows which are not present in view <code>v2</code>.
    </p>
    <h3>
      <code>v1:intersect(v2)</code>
    </h3>
    <p>
      Return the rows of view <code>v1</code> which are also present in view <code>v2</code>. This is equivalent to "<code>v1[v1:isectmap(v2)]</code>".
    </p>
    <h3>
      <code>v1:isectmap(v2)</code>
    </h3>
    <p>
      Return a 1-column map of row numbers in view <code>v1</code>, for those rows which are also present in view <code>v2</code>.
    </p>
    <h3>
      <code>v1:union(v2)</code>
    </h3>
    <p>
      Return all rows of view <code>v1</code>, followed by those rows in view <code>v2</code> which are not present in view <code>v1</code>. This is equivalent to "<code>v1+v2[v2:exceptmap(v1)]</code>".
    </p>
    <h2>
      4.6 - Relational operators
    </h2>
    <p>
      The Relational Algebra operators make it possible to express queries for which SQL is often used:
    </p>
    <h3>
      <code>v1:ijoin(v2)</code>
    </h3>
    <h3>
      <code>v1:join(v2)</code>
    </h3>
    <h3>
      <code>v1:product(v2)</code>
    </h3>
    <h3>
      <code>v1:project(...)</code>
    </h3>
    <h3>
      <code>v1:select(...)</code>
    </h3>
    <h3>
      <code>v1:where(...)</code>
    </h3>
    <h2>
      4.8 - Grouping
    </h2>
    <p>
      Grouping re-shapes collections so that common parts are collected into sub-views, whereas ungrouping does the inverse:
    </p>
    <h3>
      <code>v1:group(...)</code>
    </h3>
    <h3>
      <code>v1:ungroup(...)</code>
    </h3>
    <h2>
      4.7 - Sorting and comparing
    </h2>
    <p>
      These operators provide basic sorting and comparison functionality:
    </p>
    <h3>
      <code>v1:sort()</code>
    </h3>
    <p>
      Return a sorted version o view <code>v1</code>. This is equivalent to "<code>v1[v1:sortmap()]</code>".
    </p>
    <h3>
      <code>v1:sortmap()</code>
    </h3>
    <p>
      Return a 1-column map of row numbers in <code>v1</code>, such that it would sort view <code>v1</code> if the map were used to reorder <code>v1</code>. The sort is <em>stable</em>, i.e. equal rows retain their relative order.
    </p>
    <h3>
      <code>v1:uniq()</code>
    </h3>
    <p>
      Return a view with all duplicate rows in <code>v1</code> omitted. The order of the rows is not affected. Equivalent to "<code>v1[v1:uniqmap()]</code>".
    </p>
    <h3>
      <code>v1:uniqmap()</code>
    </h3>
    <p>
      Return a 1-column map of row numbers in <code>v1</code>, for those rows which are not duplicates of any preceding rows.
    </p>
    <h1>
      5 - Persistence
    </h1>
    <p>
      These simple operators support saving and loading views in a compact and portable format (similar, and in some cases compatible, to the <a href="http://www.equi4.com/metakit.html">Metakit</a> database library).
    </p>
    <h2>
      5.1 - Saving
    </h2>
    <p>
      Views can be saved to a (binary) string or to file:
    </p>
    <h3>
      <code>v1:emit()</code>
    </h3>
    <p>
      Return a binary string representing view <code>v1</code>, i.e. its structure and contents (including any nested sub-views).
    </p>
    <h3>
      <code>v1:save(fn)</code>
    </h3>
    <p>
      Save view <code>v1</code> to a file named <code>fn</code>. Return the number of bytes written.
    </p>
    <h2>
      5.2 - Loading
    </h2>
    <h3>
      <code>vq.load(s1)</code>
    </h3>
    <p>
      Reconstruct a complete view a (binary) string, as previously created via codeemit() or as read from a file created with <code>save()</code>.
    </p>
    <h3>
      <code>vq.open(fn)</code>
    </h3>
    <p>
      Map a file into memory in read-only mode and return a view with the same structure and contents as the original view. Mapping is instant because the file will only be accessed when the data is actually needed. A relatively small amount of memory will be allocated when this happens, but it will be considerably less than the bytes need for the actual data since everything remains memory mapped.
    </p>
    <h1>
      6 - Implementation
    </h1>
    <p>
      <strong>#TBD#</strong>
    </p>
  </body>
</html>
