--[[  Vlerq standalone executable startup file.
      $Id: vq.c 3953 2008-02-17 10:21:35Z jcw $
      This file is part of Vlerq, see src/vlerq.h for full copyright notice.
--]]

dofile "../src/vq.lua"

-- function printf (fmt,...)
--   print(fmt:format(...))
-- end

function dbopen (fn)
  return assert(vq.open(fn))
end

function vq.isview (v)
  return getmetatable(v) == getmetatable(vq())
end

function vq.type2str (t)
  return vq.types:sub(t+1,t+1)
end

-- memory & modules adapted from Nanoki, see http://alt.textdrive.com/nanoki/

local function memory ()
  local mem = collectgarbage('count')
  return mem > 999 and ('%.1f MB'):format(mem/1024) or ('%.0f KB'):format(mem)
end

local function modules ()
  local mods = {}
  for name, pkg in pairs(package.loaded) do
    if name ~= '_G' then
      table.insert(mods,name)
    end
  end
  table.sort(mods)
  return table.concat(mods,', ')
  -- FIXME: return table.concat(vq(mods,'name'):sort():table(),', ')
end

-- this Lua-based MK datafile walker is used to dump the file structure

local walker = {}

-- the default output function prints each call on stdout
local function myoutfun (...)
  local t = {...}
  for i,v in ipairs(t) do t[i] = tostring(v) end
  print(table.concat(t, ' '))
end

function walker:fdump (map, outfun)
  -- utility function to convert a few bytes in the map to a big-endian integer
  local function beInt (o,n)
    local v = 0
    for i=1,n do v = v * 256 + map[self.off+o+i] end
    return v
  end

  self.map = map
  self.out = outfun or myoutfun
  
  self.off = #map-16
  local f0, f1, b0 = beInt(0,1), beInt(8,1), beInt(1,3)
  assert(f0 == 128 and f1 == 128, 'file is not a Metakit data file')
  local datacnt, rootlen, rootoff = beInt(4,4)+16, beInt(9,3), beInt(12,4)
  self.out('%', 0, '-', datacnt, #map-datacnt)
  self.out('/', 0, '-', rootlen, rootoff)
  self.off = #map-datacnt
  local h0, h1 = beInt(0,1), beInt(1,1)
  assert(h0+h1 == 150, 'file is not recognized as Metakit data file')
  --self.bigendian = h0 == 76
  self.curr = rootoff

  self:walksub()
end

function walker:walksub (seq, meta)
  local desc = '-'
  self:getb()
  if meta == nil then 
    desc = self:getdesc()
    meta = vq(desc)
  end
  local rows = self:getv()
  self.out('#', desc, rows, seq or 0, 0)
  if rows > 0 then
    for r in meta:rows() do
      local t = vq.t2s(r.type)
      self.size, self.pos = self:getp()
      self.out(t, rows, r.name, self.size, self.pos)
      self[t](self, rows, r.subv)
    end
  end
end

function walker:I (rows)
end

function walker:S (rows)
  if self.size > 0 then 
    self.out('.', rows, '-', self:getp())
  end
  local msize, mpos = self:getp()
  if msize > 0 then
    self.out('>', rows, '-', msize, mpos)
  end
end

function walker:V (rows, subv)
  local curr = self.curr
  self.curr = self.pos
  for i=1,rows do
    self:walksub(i, subv)
  end
  self.curr = curr
end

walker.L = walker.I
walker.F = walker.I
walker.D = walker.I
walker.B = walker.S

function walker:getb ()
  self.curr = self.curr+1
  return self.map[self.off+self.curr]
end

function walker:getv ()
  local v = 0
  repeat
    local b = self:getb()
    v = v * 128 + b
  until b >= 128
  return v - 128
end

function walker:getp ()
  local size = self:getv()
  local pos = size > 0 and self:getv() or 0
  return size, pos
end

function walker:getdesc ()
  local t = {}
  for i=1,self:getv() do t[i] = string.char(self:getb()) end
  return table.concat(t)
end

-- implementation of each of the vqx sub-commands

local vqx = {}

function vqx.add ()
  local inf, outf = table.remove(arg,1), os.tmpname()
  local db = dbopen(inf):mutwrap()
  db:append(unpack(arg))
  print(db:save(outf))
  assert(os.rename(outf,inf))
end

function vqx.create ()
  return vq(0,arg[2]):save(arg[1])
end

function vqx.delete ()
  local inf, outf = arg[1], os.tmpname()
  local db = dbopen(inf):mutwrap()
  db:replace(arg[2],1,db:clone())
  print(db:save(outf))
  assert(os.rename(outf,inf))
end

function vqx.fdump ()
  local fn = assert(arg[1], "filename required")
  local map = assert(vq.map(fn), "can't open file")
  walker:fdump(map)
end

function vqx.help ()
  print [[

    vqx add file ?...?         - append values to view in file
    vqx create file desc       - create new datafile with given structure
    vqx delete file row        - delete a row from view in file
    vqx fdump file             - dump structure of a data file
    vqx help                   - you're lookin' at it now
    vqx info file              - show some information about a datafile
    vqx lsk file               - list the contents of a starkit
    vqx run file ?...?         - run a script, with optional args
    vqx show file ?...?        - show view contents, remaining args are path
    vqx test ?-v?              - run the standard LuaVlerq tests (verbose)
    vqx version                - show version details
    vqx with file cmd ?...?    - apply cmd to view in file (in 'db' global)
    vqx xdump file ?len? ?off? - hex dump over a 0-based byte range in a file
]]
end

function vqx.info ()
  local views = vq(0,'view,rows:I,description')
  local db = dbopen(arg[1])
  if #db == 1 then
    for r in db:meta():rows() do
      local desc, count = vq.type2str(r.type), -1
      if desc == 'V' then
        desc = r.subv:describe()
        count = #db[1][#r]
      end
      views:append(r.name, count, desc)
    end
  else
    views:append('-', #db, db:describe())
  end
  return views
end

function vqx.lsk ()
  local paths = vq(0, 'path,files:V')
  for r in dbopen(arg[1])[1].dirs:rows() do
    local dir = #r>1 and paths[r.parent+1].path..r.name..'/' or '/'
    paths:append(dir, r.files)
  end
  for r in paths:sort():rows() do
    print(r.path)
    r.files:sort():p(1e6)
  end
end

function vqx.run ()
  return dofile(assert(table.remove(arg,1), 'haha'))
end

function vqx.show ()
  local db = dbopen(table.remove(arg,1))
  for _,f in ipairs(arg) do db = db[f] end
  return db
end

function vqx.test ()
  dofile "../src/test.lua"
end

function vqx.version ()
  -- somewhat useless info, just playing around with views
  local info = {
    Version = vq._VERSION,
    Copyright = vq._COPYRIGHT,
    Release = vq._RELEASE,
    System = _VERSION,
    Memory = memory(),
    Packages = modules():sub(1,60)..'...',
  }
  return vq(info,'tag,details'):sort()
end

function vqx.with ()
  db = dbopen(arg[1])
  return assert(loadstring('return '..arg[2]))()
end

function vqx.xdump ()
  local fn, count, from = unpack(arg)
  local fd = assert(io.open(fn,'rb'))
  if from then fd:seek('set',from) end
  if count == nil then count = 1e6 else count = tonumber(count) end
  local offset = 0
  while true do
    local s = fd:read(16)
    if s == nil or count <= 0 then return end
    if count < 16 then s = s:sub(1,count) end
    io.write(string.format("  %08X  ",offset))
    string.gsub(s, "(.)", function (c)
                            io.write(string.format("%02X ",string.byte(c)))
                          end)
    io.write(string.rep(" ",3*(16-string.len(s))))
    io.write(" ",string.gsub(s,"%c","."),"\n") 
    offset = offset+16
    count = count-16
  end
end

local result = (vqx[table.remove(arg,1) or "help"] or vqx.help)()

if vq.isview(result) then
  result = result:dump()
end
if result then
  print(result)
end
