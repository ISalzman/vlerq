info {
  package   thrive
  version   2.23
  title	    {Threaded Interpreter Virtual Machine}
  keywords  {thrive thrill vlerq {virtual machine} vm tcl}
  website   http://www.vlerq.org/
}

preamble {
  require Tcl 8.4
  require thrive
}

desc {
  The [b thrive] package defines a [q thrive] command in Tcl to create
  and manage a virtual machine for use by [b Vlerq].
  This package is not normally called directly from application code.
}

cmd ::thrive {
  Create a Tcl command object representing a new virtual machine [q workspace].
  When the command is later deleted, all memory used by that workspace will
  be released.
  The name of the new workspace is returned,
  it is of the form [q ::thrive_NUM].
}

obj workspace eval token {
  Look up and prepare to evaluate a symbol in the workspace.
  Actual evaluation will take place when [b run] is called.
  Return the symbol index, or -1 of not found.
}

obj workspace find token {
  Look up (but do not evaluate) a symbol in the workspace.
  Return the symbol as a reference, or throw an error if not found.
}

obj workspace load script {
  Parse a script into tokens and evaluate them.
  The syntax rules match those of [b Thrill], a Forth-like language which
  is used to portably implement Vlerq's functionality on top of Thrive.
  Throws an error if the script does any callbacks.
}

obj workspace pop {
  Pop one value off the data stack and return it as a Tcl data structure.
  Ints and strings are returned as is, nil is returned as the empty string,
  and vectors are returned as lists (recursively converting items in them).
  Views and other objects are returned as a [q reference], see below.

  Cells of the form (Wn,X) are special.
  If X is zero, then this is [q nil] (usually returned as empty string).
  Else an error is thrown.
  If X is -1 then the error value is configurable (default -1),
  else the error is always the number X itself.
}

obj workspace push desc ?values... {
  Convert Tcl values to Thrive values with specified types and push them
  onto the data stack.  No return value.

  The [var desc] argument describes the types of all input values.
  There is one item for each of the values to be pushed:

  [taglist {
    I {an integer}
    S {a string}
    a {an int or a string, depending on what [q [b string is int -strict]] says}
    V {a view reference, see below}
    n {nil, the argument passed in should be [q . 0]}
    (...) {arg list, the [q ...] is again a list of the types inside that list}
  }]

  An empty [var desc] defaults to [q . S].
  When [var desc] is exhausted, it is restarted from the first item.
}

obj workspace run ?cref {
  Pump the run loop, keep going until it returns with a result or requests
  a trampoline callback.
  The optional [var cref] is a reference to code
  which will get pushed and called.  Return 0 if there is no more work,
  &gt; 0 to request a callback, or &lt; 0 to flag a return or error condition.
}

obj workspace type arg {
  Return the Thrive type (a small integer) of [var arg].
  Throws an error if [var arg] is not a reference.
}

section References {
  References provide a mechanism to refer to opaque objects in a 
  workspace without copying its data out to Tcl.  
  References can be returned by [b pop] and by [b find].

  The only use for references is as parameter value for [b push] or [b run],
  as an efficient way to refer to objects managed by Thrive.
  An object in Thrive will not be garbage collected as long as a reference
  to it exists, as tracked via the Tcl_Obj [q dual representation].

  References cannot be stored on file, or used in other workspaces.
}

examples {
  Create a Thrive workspace and do some data stack manipulations:
} {
  % package require thrive
  2.23
  % set ws [thrive::new]
  ::thrive_1
  % $ws push I(SI) 123 {one 1 two 2 three 3}
  % $ws pop
  one 1 two 2 three 3
  % $ws pop
  123
  %
} {
  The [q I(SI)] descriptor in [b push] describes the type of the two following
  values: an integer and a list consisting of alternating strings and ints.

  Some bootstrap code needs to be loaded before normal processing is possible,
  here's a minimal version:
} {
  $ws load { 0 exit exec -1 syst [[ }
} {
  Perform some arithmetic, now that the bootstrap has been loaded:
} {
  % $ws push II 234 345
  % $ws eval +
  33
  % $ws run
  0
  % $ws pop
  579
  %
} {
  Lastly, cleanup and release all memory used by the workspace:
} {
  % rename $ws ""
  %
}
