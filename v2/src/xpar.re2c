/* xpar.re2c -=- Token parser extension, to be processed via re2c */

#define YYCTYPE	      UC
#define YYCURSOR      (*((UM*)&s[0].i))
#define YYLIMIT	      (*((UM*)&s[1].i))
#define YYMARKER      (*((UM*)&s[2].i))
#define YYFILL(n)     fill(s)
#define YYDEBUG(x,y)  printf("state %d char %d (%c)\n",x,y,y)

#define TOKEN	      (*((UM*)&s[3].i))
#define TAIL	      s[4]

L UM fill(P s) {
  P w = Work(s);
  if (isInt(TAIL)) {
    I n = YYLIMIT-TOKEN;
    P p = newBuffer(w,0,n+1);
    UM b = (UM)String(p);
    TAIL.p = p; /* for gc, also prevents re-entering this code */
    memcpy(b,TOKEN,n);
    b[n] = 0;
    /* printf("FILL n %d c %d <%s>\n",n,YYCURSOR-TOKEN,b); */
    YYCURSOR = b+(YYCURSOR-TOKEN);
    YYMARKER = b+(YYMARKER-TOKEN);
    YYLIMIT = b+n;
    TOKEN = b;
  }
  return YYCURSOR;
}

/*!re2c
  A = [\001-\377];
  D = [0-9];
  L = [A-Za-z_];
  H = [A-Fa-f0-9];
  X = [Ee] [+-]? D+;
  E = "\\" ([bnrt'"\\] | "x" H{2} | "u" H{4} );
  W = [ \t\r\n]+;
  Z = [\000];
*/

L I sqltoken(P w, P s) {
  if (YYLIMIT == 0) {
    YYCURSOR = (UM)strAt(s[0]);
    YYLIMIT = YYCURSOR+lenAt(s[0]);
  }
 std:
  TOKEN = YYCURSOR;
/*!re2c
  L (L|D)*				        { return 257; }
  D+					        { return 258; }
  ("'" (A\['] | "''")* "'")		        { return 259; }
  (D+ X) | (D* "." D+ X?) | (D+ "." D* X?)      { return 260; }
  "$" L (L|D)* ("(" (L|D)* ")")? (":" L)?	{ return 261; }
  "<=" | "<>" | ">="			        { return 262; }
  ("\"" (A\["] | "\"\"")* "\"")		        { return 263; }
  W 					        { goto std; }
  A					        { return *TOKEN; }
  Z					        { return 0; }
*/
}

L I tcltoken(P w, P s) {
  if (YYLIMIT == 0) {
    YYCURSOR = (UM)strAt(s[0]);
    YYLIMIT = YYCURSOR+lenAt(s[0]);
  }
 std:
  TOKEN = YYCURSOR;
/*!re2c
  L (L|D)*				        { return 257; }
  ("0x" H+) | D+			        { return 258; }
  ("\"" (A\[\\"] | E)* "\"")		        { return 259; }
  (D+ X) | (D* "." D+ X?) | (D+ "." D* X?)      { return 260; }
  "$" L (L|D)* ("(" (L|D)* ")")? (":" L)?	{ return 261; }
  "<=" | "!=" | ">=" | "==" | "&&" | "||"       { return 262; }
  W 					        { goto std; }
  A					        { return *TOKEN; }
  Z					        { return 0; }
*/
}

L I xml1token(P w, P s) {
  if (YYLIMIT == 0) {
    YYCURSOR = (UM)strAt(s[0]);
    YYLIMIT = YYCURSOR+lenAt(s[0]);
  }
  TOKEN = YYCURSOR;
/*!re2c
  "<![CDATA[" { while (YYCURSOR <= YYLIMIT-3 &&
		    (YYCURSOR[2]!='>' || YYCURSOR[1]!=']' || YYCURSOR[0]!=']'))
		  ++YYCURSOR;
		YYCURSOR += 3;
		return 257;
	      }
  (A\[<])+         			        { return 258; }
  "<"     				        { return 1; }
  Z                         		        { return 0; }
*/
}

L I xml2token(P w, P s) {
  if (YYLIMIT == 0) {
    YYCURSOR = (UM)strAt(s[0]);
    YYLIMIT = YYCURSOR+lenAt(s[0]);
  }
 std:
  TOKEN = YYCURSOR;
/*!re2c
  "?" (A\[>])* / ">"			        { return 259; }
  "!--" ((A\[-]) | "-" (A\[-]))* "--" / ">"     { return 260; }
  "!" (A\[>\[])* ("[" (A\[\]])* "]" W?)? / ">"	{ return 261; }
  "="						{ return 2; }
  ("'" (A\['])* "'") | ("\"" (A\["])* "\"")	{ return 262; }
  (L | D | [-._:])+			        { return 263; }
  "/"						{ return 3; }
  W 					        { goto std; }
  ">"                      		        { return 4; }
  Z                           		        { --YYCURSOR; return 0; }
*/
}

/* rul=5 rdc=6 tab=7 key=8 val=9 nod=10 pval=11 txt=12 sym=13 ops=14 */

L I sfind(P t, P k) {
  I i = 0, n = Length(t);
  while (i < n)
    if (Length(t[i].p) == Length(k) &&
	memcmp(String(t[i].p),String(k),Length(k)) == 0)
      break;
    else
      ++i;
  if (i >= n) i = -1;
  return i;
}

L I pfind(P o, I t, I s) {
  I i = 0, n = Length(o[8].p), k = 256*t+s;
  while (i < n) if (o[8].p[i].i == k) break; else ++i;
  return i < n ? o[9].p[i].i : 0;
}

L V parser(P w) {
  I token = Wpopd.i, mode, next, base, act, typ, i, n;
  P o = Wsubd.p, nv;
  o[11] = Wpopd;
  Wtopd.p = o; /* hold on to ref */
  if (token == 257) {
    I z = sfind(o[13].p,o[11].p);
    if (z >= 0) token = 264 + z;
  } else if (token == 262) {
    I z = sfind(o[14].p,o[11].p);
    if (z < 0) { puts("ops error"); }
    token = 264 + Length(o[13].p) + 1 + z;
  }
  for (;;) {
    I f = pfind(o, token, o[Length(o)-1].i);
    mode = f & 3;
    next = f / 4;
    if (mode != 2) break;
    base = Length(o) - o[6].p[next].i;
    act = o[7].p[next].i;
    typ = act & 15;
    n = (act>>4) & 15;
    nv = newVector(w,n);
    o[18].p = nv; /* hold on to ref */
    if (typ == 0) {
      if (o[12].i)
	nv[Length(nv)++] = o[10].p[(act >> 8) & 255];
      else
	nv[Length(nv)++].i = (act >> 8) & 255;
      for (i = 0; i < 15; ++i)
	if (act & (1 << (i+16))) {
	  nv[Length(nv)].i = -1;
	  nv[Length(nv)++].p = o[base+i-1].p;
	}
    } else {
      for (i = 0; i < n; ++i) {
	I k = (act >> (4*i+8)) & 15;
	if (k == 0)
	  nv[Length(nv)++] = Wn;
	else {
	  nv[Length(nv)].i = -1;
	  nv[Length(nv)++].p = o[base+k-1].p;
	}
      }
      switch (typ) {
	case 2: { I n0 = Length(nv[0].p), n1 = Length(nv[1].p);
		  P v = newVector(w,n0+n1);
		  for (i = 0; i < n0; ++i) v[i] = nv[0].p[i];
		  for (i = 0; i < n1; ++i) v[i+n0] = nv[1].p[i];
		  Length(v) = n0+n1;
		  nv = v;
		}
		break;
	case 3: nv = nv[0].p;
      }
    }
    Length(o) = base + 1;
    o[base].i = pfind(o, o[5].p[next].i, o[base-1].i) / 4;
    o[base].p = nv;
  }
  if (mode) {
    o[Length(o)].i = next;
    o[Length(o)++].p = o[11].p;
    Wtopd = Wz;
  } else {
    Wtopd.p = o[Length(o)-1].p;
    Wtopd.i = -1;
  }
}

L I parExt(P box, I cmd) {
  P w = Work(box), s = Wtopd.p;
  switch (cmd) {
    case 0:   parser(w); return 0;
    case 1:   Wtopd.i = sqltoken(w,Wtopd.p); break;
    case 2:   Wtopd.i = tcltoken(w,Wtopd.p); break;
    case 3:   Wtopd.i = xml1token(w,Wtopd.p); break;
    case 4:   Wtopd.i = xml2token(w,Wtopd.p); break;
    default:  return 0;
  }
  if (Wtopd.i < 256)
    Wtopd.p = Wz.p;
  else {
    /* TODO return a shared string iso a copy */
    Wtopd.p = newBuffer(w,(S)TOKEN,YYCURSOR-TOKEN);
    Length(Wtopd.p) = YYCURSOR-TOKEN;
  }
  return 0;
}

/* vim: set ft=c : */
