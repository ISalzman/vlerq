info {
  package   vlerq
  version   1.0
  title	    {Tying Vectors to Relational Algebra}
  website   http://www.vlerq.org/
}

desc {
  Vlerq is a research project which explores ways to combine
  a vector-oriented processing model with relational algebra.
}

section Components {
  Vlerq consists of an ever-evolving set of components and sub-systems,
  because there is not a single [q vlerq] software package but rather
  a range of packages for use in various contexts.

  The main subsystems are:

  [taglist {
    Thrive {the virtual machine on which everything else is based}
    Thrill {this is not really a subsystem but the name of the low-level
	    language layer used in Vlerq}
    Ratcl {an extension for using Relational Algebra in Tcl,
	    with more operators and persistence thrown in for free}
    Rasql {an SQL translation layer for Ratcl, vaporware mostly}
    Vqx {a self-contained executable containing much of the above,
	  but independely of Tcl}
  }]

  There is limited documentation at this stage,
  in the form of manual pages for 
  the [a href=ratcl.html {Ratcl API}] and 
  the [a href=thrive.html {Thrive VM}] (both for use from Tcl).
}

section Builds {
  The first step in building one of a number of Vlerq binaries,
  is to run [q [tt sh configure]].
  This creates a [i build] directory with a [i Makefile] in it.
  You should [i cd] into it and run all make's from there.
  The name of the build directory is not hardwired - you can
  maintain as many variants as you like, as long as builds 
  always take place from a directory next to the original [i build] area,
  i.e. at the same nesting level.

  The makefile works on a couple of platorms:

  [taglist {
    Unix {as is, at least on Linux}
    Windows {do [q [tt set ARCHSUFFIX=.win32]] and use [i mingw] with [i msys]}
    {Mac OS X} {do [q [tt export ARCHSUFFIX=.macosx]]}
  }]

  There are a number of build targets for [i make],
  with varying build requirements and dependencies.
  The main ones are:

  [taglist {
    make {build vq and runs a minimal test, only requires the C compiler}
    {make test} {build a debug version of the Tcl extension and
		 run the test suite}
    {make clean} {delete all build products and intermediate files}
  }]

  The tests require either [i tclsh] or [i tclkit], version 8.4 or later.
  Use [q [tt make test TCL=tclsh]] if you have tclsh.

  When running [i make] with different targets, some of the following
  utilities may have to be present on your execution path:

  [taglist {
    diet {used to create [i vq-static], a small statically linked version of vq
      [br](see [a href=http://www.fefe.de/dietlibc/ www.fefe.de],
      by Felix von Leitner)}
    re2c {used to create [i xpar.h] from [i xpar.re2c]
      [br](see [a href=http://www.re2c.org/ www.re2c.org],
      various maintainers at SourceForge)}
    sdx {the Starkit Developer eXtension, used to create wrapped Starkits
      [br](see [a href=http://www.equi4.com/sdx.html www.equi4.com])}
    tclkit {self-contained Tcl/Tk distribution, including Metakit database
	    [br](see [a href=http://www.equi4.com/tclkit.html www.equi4.com])}
    upx {used to create [i vq-tiny], a compressed version of [i vq-fast]
	    [br](see [a href=http://upx.sourceforge.net/ SourceForge],
	    by Markus Oberhumer)}
  }]

  The [i diet] and [i upx] commands can be replaced by dummy shell scripts,
  they are not essential for any of the other build steps.

  There are several other build targets:

  [taglist {
    {make all} {build several vq/vqx variants and update files in [i noarch]}
    {make ratcl} {packaged version of Thrive, ready to use from Tcl scripts}
    {make regen} {regenerate the entire [i noarch] directory from scratch}
    {make thrive} {build Tcl debug extension, used to run
		    the test suite during development}
    {make thrive-lua} {set up a makefile-based area with Thrive for Lua}
    {make thrive-py} {set up a distutils-based area with Thrive for Python}
    {make thrive-rb} {set up an extconf-based area with Thrive for Ruby}
    {make thrive-tcl} {set up a TEA3-based area with Thrive for Tcl}
    {make vq} {standalone executable with embedded startup code, used by vqx}
    {make vqx} {standalone utility, used for testing and for viewing datafiles}
  }]
}

section {Language bindings} {
  There are language bindings to Thrive for Lua, Python, Ruby, and Tcl.
  These are generated from the base sources and use templates from the
  [i lang] directory to make them work in the [q normal] way for each
  language:

  [taglist {
    Lua  {[tt {make thrive-lua; cd thrive-lua; make; etc...}]}
    {Python &nbsp;}
	 {[tt {make thrive-py; cd thrive-py; python setup.py build; etc...}]}
    Ruby {[tt {make thrive-rb; cd thrive-rb; ruby extconf.rb; etc...}]}
    Tcl  {[tt {make thrive-tcl; cd thrive-tcl; sh configure; etc...}]}
  }]

  See the README files in the generated areas for more information.

  Note: the [q ARCHSUFFIX] settings mentioned elsewhere are ignored here,
  these builds use whatever standard mechanism the respective language offers.
}

section {Windows builds} {
  There is some support for Win32 builds and cross-compilation using [i Mingw].

  With Mingw's [i msys] simply do [q [tt {sh configure; cd build; make}]].
  There will be some failures
  for [i upx] and [i diet] but it should be enough to build [i vq] and [i vqx].

  See [a href=http://www.equi4.com/pub/xc www.equi4.com] for packages which
  can install a Mac OS X or Linux hosted cross-compiler for Win32, respectively.
  The trick for cross-compilation is to set up
  [q [tt {export ARCHSUFFIX=.win32}]] in the shell,
  which will affect some settings in the Vlerq makefile.

  To build the Tcl extension with this cross-compiler, use:

  [tt {&nbsp; make thrive-tcl; cd thrive-tcl; sh configure --host=mingw32; make}]

  Note that [i make thrive] will not work with the cross-compiler
  because it does not have the Tcl header files.
}
