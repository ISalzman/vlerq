\ words -=- Thrill code to be loaded into each new Thrive VM instance

# <CORE> --------------------------------- final part of the bootstrap code ---

\ standard preamble, must be at code offsets 0..4
0 exit
exec -1 syst #We

\ initial definitions, some of these will be redefined later
immed 1 Wi Wl b!
noop exit
]] -1 (to) Wt exit
: 2 (to) Wt 0 syst ]] exit
, Wc ! 1 +to Wc exit
; (lit) exit , 0 (to) Wt exit

\ the [[ exits define mode, immed then adjusts the ';' definition above
[[ immed

\ make sure input code ends with an exit before entering an infinite (tok) loop
\ the difficult case is: vqx eval '1 .p "2 .p" eval 3 .p nl'
\ : eval #s- 'exit 'S heval 'S heval begin (tok) again ;
: eval #s- 'exit 'S 1 syst 'S 1 syst 0 syst [[ Gj -3 box , ]] ;

# <BASIC> --------------------------------------- basic runtime definitions ---

\ trampoline calls
: (tok)  #-e    0 syst ;
: heval  #ss-s  1 syst ;
: quit   #i-    2 syst ;
: .p     #v-    3 syst ;
: readf  #s-s   4 syst ;
: usec   #-n    5 syst ;
: getenv #s-s   6 syst ;
: fseek  #fom-o 7 syst ;
: fread  #fn-s  8 syst ;
: fwrite #fs-i  9 syst ;

\ define new symbols
\ XXX constant evaluates when compiled-in, it ought to compile as literal
: constant (tok) ! ;
: variable Ww (tok) ! 1 +to Ww ;

\ basic output words
: ? dup .p ;
: sp " " .p ;
: nl "\n" .p ;

\ branching and looping
: branch! tuck - 1- swap dup @ rot box swap ! ;
: jmp, Wc Gj , ;
: cnd, Wc Gc , ;
: tst, Wc Gt , ;

: ?if tst, ; immed
: if cnd, ; immed
: then Wc swap branch! ; immed
: else jmp, Wc rot branch! ; immed
: begin Wc ; immed
: while cnd, swap ; immed
: again jmp, branch! ; immed
: until cnd, branch! ; immed
: repeat jmp, branch! Wc swap branch! ; immed

\ state aware "lit" and "to" so they can also be used in run mode
: token #-t Wc -1 (to) Wt (tok) 0 (to) Wt dup (to) Wc @ ;
: to Wt if (lit) (to) , else token work ! then ; immed
: lit Wt if (lit) (lit) , else token then ; immed

\ initialize Thrive's C extensions
xini

# 8 to Wq

\ resumable iteration using the xfor extension, works for ints/boxes/views
\ XXX views need to be boxed with their size: dup ^count box - see fixsz

: @xfor Wc 1- xfor over @ box swap ! ; immed

: $beg* #v-vnn dup 0< if dup tlen else dup b2o swap then dup ;
: $end* #-x 2r> 2r> drop rrot drop >r ;
: rep* #vf- >r $beg* drop 2>r 0 @xfor $end* drop ;
: fnd* #vf-n >r $beg* drop 2>r 1 @xfor r> b2i 2r> 2drop ;
: cnt* #vf-n >r $beg* b2p nvec rbox 2>r 2 @xfor $end* tlen ;
: bit* #vf-b >r $beg* 7 + 3 >> nbuf rbox 2>r 3 @xfor $end* ;
: sel* #vf-b >r $beg* nvec rbox 2>r 4 @xfor $end* b2o ;
: seq* #vf-b >r $beg* 2 << nbuf rbox 2>r 5 @xfor $end* b2o ;
: map* #vf-b >r $beg* nvec rbox 2>r 6 @xfor $end* b2o ;
: maq* #vf-b >r $beg* 2 << nbuf rbox 2>r 7 @xfor $end* b2o ;

\ shorthand
: tfin! #ev- -5 b! ;
: ttag! #ev- -4 b! ;
: tadr! #ev- -3 b! ;
: tdat! #ev- -2 b! ;
: tlen! #ev- -1 b! ;

\ quotation
: { #-th Wt -1 to Wt Wc ; immed
: (cb) #th- lit exit , Wc over - over to Wc dup nvec over 1- over tlen! dup >r
  b2p swap vcpy 2drop to Wt r> Ge over setg b2p Wt if lit lit , , then ; 
: } #th- (cb) ; immed

\ copy to a new box in reversed order
: vrev #b-b dup tlen swap { not over + @ } map* nip ;
\ replace top n items of stack with a new vector containing them
: pack #*n-v lit drop map* vrev ;

\ in-line vectors, made state aware so this can also be used in run mode
: ( Wt if { r> Wd 2>r } , else Wd >r begin (tok) again then ; immed
: ) Wt if { 2r> swap >r Wd swap - pack } , else 2r> 2drop Wd r> - pack then ;
  immed

\ machine constants
{ 1 1 begin dup 2* while 2* swap 1+ swap repeat } exec
  constant highbit constant bits/int
1 nvec tcnt b2i constant bytes/box
       Ww b2i constant var0
       Wd b2i constant dsp0
\ : rol 2dup bits/int swap - >> rrot << or ;
\ : ror 2dup bits/int swap - << rrot >> or ;

: depth Wd dsp0 - b2i ;
: tmax tcnt b2i bytes/box div ;

# <UTIL> ---------------------------------------------- thrill utility code ---

: nil? #x-f Wn p= ;
: ?? #xs- .p ': .p .p sp ;
: s? #- Wd 'Wd ?? ;
: p2end #s-e dup tlen box ;
: end2p #p-s dup b2i over tlen! b2o ;
: sgn #n-n dup 0> if 0> else 0< neg then ;
: 1pck #e-v 1 pack ;
\ mark as object
: mao #v- Gi swap setg ;
: ,nip #- -1 +to Wc Wc @ Wc 1- ! ; immed
: custg #vf-v over tadr! Gu over setg ;
: ref? #v-f tget Gi tget = ;
: bye #- 0 quit ;
: ?dup dup ?if then ;
: dip #*xf-*x swap >r exec r> ;
: def? #s-f find Wv < b2i ;

# <VIEW> --------------------------------------------------- main view code ---

\ XXX workaround for single-char constants in thrill
: cdef b2p c@ constant ;
 'B cdef B' 'I cdef I' 'S cdef S' 'V cdef V'
 '[ cdef [' '] cdef ]' ', cdef ,' ': cdef :'

\ view obj: tag=meta adr=ownr dat=vtab[,flags] len=[dims,]rows
\ dispatch: 0=type 1=count 2=at 3=mut
\ funtab: 0=name 1=argc 2=meta 3=init 4=len 5=at

: ^meta #v-r ttag ;
: ^ownr #v-r tadr ;
: ^type #v-s dup tdat 0 b@ ljmp ;
: ^count #v-n dup tdat 1 b@ ljmp ;
: ^at #rc-x over tdat 2 b@ ljmp ;
: ^Mut #v-v dup tdat 3 b@ ljmp ;

: ^info #v-n ^meta 2 ^at ;

\ support for named and end-relative columns
: ncoli #sv-c { 0 ^at over s= } fnd* nip ;
: ncol #vc-vc dup str? if over ^info ncoli else
	dup 0< if over ^info + then then ;
: ncols #bv-b swap p2end { @ ncol } map* nip ;

: getcell #vrc-x >r box r> ncol ^at ;
: fixsz #v-v dup ^count box ;

\ forward reference to the code which adds a mutable layer to a view
variable MutF

\ mkcommon sets up a view and is used for all types
: mkcommon #vmnt-o
  2>r over ttag! r> over tlen! Wn over tadr! r> b2p over tdat! dup mao ;
\ create a row-wise view with all data in one box of cells
: mkrowview #vmn-o 
  { { #v-s drop 'row } ,nip
    { #v-n tlen b2i } ,nip
    { #rc-x >r dup tmax over tlen div over * box r> + @ } ,nip
    { #v-v MutF ljmp } ,nip
  } mkcommon fixsz ;
\ create a column-wise view with all data in columns accessed by getters
\ the fetched value is exec'ed again (for subview setup, noop for ints/strs)
: mkcolview #vmn-o 
  { { #v-s drop 'col } ,nip
    { #v-n tlen b2i } ,nip
\ exec the column's getter, but make sure r & c can be retrieved later
    { #rc-x over rbox o( @ rbox exec exec )o } ,nip
    { #v-v MutF ljmp } ,nip
  } mkcommon fixsz ;
\ create a functional view, this is just part of the whole process
: mkfunview #vmt-o 
  { { #v-s o( tlen 0 b@ exec )o } ,nip
    { #v-n o( 8 b@ exec )o } ,nip
    { #rc-x swap o( 9 b@ exec )o } ,nip
    { #v-v MutF ljmp } ,nip
  } mkcommon b2o ;
\ a mutable view is like a funview, but it returns itself for ^Mut
: mkmutview #vmt-o 
  { { #v-s drop noop 'mut } ,nip
    { #v-n o( 8 b@ exec )o } ,nip
    { #rc-x swap o( 9 b@ exec )o } ,nip
    noop
  } mkcommon b2o ;

# following code disabled, for now: lower case is nullable, upper case is not
# col types are encoded as [A-Z] -> 1..26 in bits 0..4 and [a-z] -> bits 5..31
\ typ2i #s-i 0 swap { c@ dup 97 < if 31 and else 92 - 1 swap << then or } rep* ;
\ : typ2s #i-s o( 28 nbuf b2p swap 31 and 64 + over c! 1+
\     26 { Wo #im over 5 + >> 1 and if 97 + over c! 1+ else drop then } rep*
\     )o end2p ;
: typ2i #s-i b2p c@ 63 and ;
: typ2s #i-s 64 + 1 nbuf tuck b2p c! dup ++ ;
: typ= #ic-f xor 31 and 0= ;
: typn? #i-f 32 and 0<> ; #nullable?

\ set up the dictionary meta views, with D,0 and D,1 repurposed once done
variable Dict0   variable Dict1   variable D,0   variable D,1
  ( 'keys 'I typ2i -1 'dups 'I typ2i -1 'cols 'V typ2i 1 ) Wn 3 mkrowview to D,0
  ( 'name 'S typ2i -1 'type 'I typ2i -1 'subv 'V typ2i 0 ) Wn 3 mkrowview to D,1
  ( 0 1 D,0 ) Wn 1 mkrowview b2p to Dict0
  ( 1 0 D,1 ) Wn 1 mkrowview b2p to Dict1
\ need to manually fix ownr's, meta's, etc since they are circular
  Dict0 dup D,1 8 b! dup Dict0 ttag! dup Dict1 ttag! D,0 tadr! 
  Dict1 dup D,0 8 b! dup D,0 ttag! dup D,1 ttag! D,1 tadr! 
\ make D,0 and D,1 refer to Dict0 and Dict1, respectively
  Dict0 to D,0  Dict1 to D,1

\ a top level meta row is a row with a subview, so it needs some fixup
: mktopmeta #kdv-o
  D,1 over tlen 3 div mkrowview 3 pack D,0 1 mkrowview b2p dup dup 2 ^at tadr! ;
: mkvdef #ivm 0 1 rot mktopmeta rot mkrowview ;
\ fix meta view after mkvdef
: fixvdef #rir- ^meta rrot swap ^info swap 3 * 2+ b! ;

variable Mvnone   0 ( ) ( ) mkvdef ^meta 0 over tlen! to Mvnone

\ extract data from a view
: getcol #vi-b swap fixsz { over ^at } map* nip ;
: ^getcol #vs-b ncol getcol ;
: getrow #vi-b box dup ^info { #vi-vx 2dup ^at nip } map* nip ;
\ : getrows #v-b fixsz { #e-b dup getrow } map* ;
: getall #v-b fixsz dup dup ^info * nvec b2p swap
    { #pe-pb dup getrow { @ over ! 1+ } rep* } rep* dup b2i over tlen! b2o ;

: ^width #v-i ^info b2i ;
: ^names #v-b ^info 0 getcol ;
: ^types #v-b ^info 1 getcol { @ typ2s } map* ;

# <MKREAD> --------------------------------------- metakit file/data reader ---

\ Smk holds MK data, offset zero is start of the data, Smk.i is current pos
\ this var is only used briefly, so it can be re-used for multiple data files
variable Smk
\ set current position relative to base
: mseek #i- Smk rbox to Smk ;
\ mkb fetches one byte and advances
: mkb #-i Smk 1 +to Smk c@ 0xFF and ;
: mk2be #-i mkb 8 << mkb or ;
: mk4be #-i mk2be 16 << mk2be or ;
\ big4 handles > 31b offsets in head & tail, but must also work on 32b arch
: big4 #i-i 0xF and 16 << 16 << mk4be 0xFFFFFFFF and + ;
\ peek4 gets high byte 4 positions before curr seek pos
: peek4 #-i -4 +to Smk mkb 3 +to Smk big4 ;
\ skroot seeks to the root column of the stored data
: skroot #- Smk p2end 4 - mseek peek4 mseek ;
\ mkroot takes a (mapped) data string and returns the root column offset
\ creates new shared string which is 0-based at JL/LJ
\ returns error -1001 if there is no valid MK data (this is not 100% detected)
: mkroot #s-o p2end 16 - to Smk Wn -1001 box mkb 128 = if
    3 +to Smk peek4 neg 16 - Smk rbox
    dup tlen tuck + swap nsha b2p to Smk
    mkb mkb + 150 = mkb 26 = and if skroot drop Smk then then ;
\ mkv fetches one variable-sized int and advances
: mkv #-i 0 begin 128 * mkb tuck + swap 128 and until 128 - ;

\ symc reads one character and returns true if it is not a separator
: symc #-cf mkb dup [' <> over ]' <> * over ,' <> * over :' <> * ;
\ tok returns the next identifier plus terminating character
\ XXX fixed limit of 40 chars for a single property name!
: tok #-sc 41 nbuf begin 1+ symc while over c! repeat swap end2p swap ;
\ mdef takes metaview, and adds name/type to it, leaving mvw on stack
: mdef #vsi-v dup int? if -1 else V' swap then swap 63 and swap
    3 pack b2p swap 3 vcpy nip ;
\ pars returns a parsed metarow, stops one character too far
\ XXX fixed limit for at most 120 properties per metaview!
\     fails if char after desc str is a comma (44, i.e. row count >= 5632)
\     can't happen in current MK, because top-level count is always 1
: pars #-m 360 nvec b2p
    begin tok [' = if pars else mkb then mdef mkb ,' <> until
\ need to copy to a fresh box since tmax is used and set too high
    #p dup b2p over nvec b2p rot vcpy
    nip b2o D,1 over tmax 3 div mkrowview fixsz
    0 1 rot 3 pack D,0 1 mkrowview b2p ;

\ adaptive int widths
 "340512/23041./1230.4/12.30./012.3./012..3/01.2.." constant wtab
: $wbit #rb-brf over 8 < over 7 < * ;
: $wmap #rb-i swap 1- 7 * + 1- wtab rbox c@ 7 and ;
: bigend #-f '1234 b2p i@ 255 and 0x34 = ;
: $reve #i-i dup 5 >= neg Smk bigend box c@ #'L 76 = * if 2+ then ;
: $wdiv #rb-i 8 * swap div log2 1- ;
: aintw #rb-w dup 0= if nip exit then $wbit if $wmap else $wdiv then 1+ $reve ;
# 80 10 aintw '80/10 ?? 2 2 aintw '2/2 ?? 3 12 aintw '3/12 ?? nl
variable Iget
  ( xv0z xv1u xv2u xv3u xv4i xv5i xv6i xv5r xv6r ) to Iget
: $mkv2 #-io mkv dup if mkv else 0 then Smk rbox ;
: icol #v-s ^count $mkv2 over nsha rrot aintw Iget rbox @ over setg ;

\ load items for a view with N columns, possibly still consisting of lazy stubs
: BorS #c-f dup B' typ= swap S' typ= or ;
: vskip #-i mkv if mkv else 0 then ;
: $nskp #c- typn? if vskip mkv 2drop then ;
: $cskp #c- BorS if #len: vskip if #dat: vskip drop then then vskip drop ;
\ the "columns" are initially Smk,offset cells which will set up the real col
: loadv #m-v mkv drop dup nil? if drop mkv drop pars -1 +to Smk then mkv #mr
    over 2 ^at { Smk >r over if dup 1 ^at dup $nskp $cskp then drop r> } map*
    #mrc rrot mkcolview ;

\ set up string vector, vec item is either offset or already filled in if memo
\ tdat is int sizes vec, tadr is proper getter, tlen is -1 for S or 0 for B
\ TODO could be improved: vec of strings + entries which get themselves on exec
\      then the vector would not need a custom getter (needs second 0-size box)
: $sinc #orv-or rot swap #rov -2 box dup @ swap ++ exec + swap ;
: $sall #orv-g >r
    begin dup while 1- over r> dup 1+ >r ! r@ $sinc repeat 2drop r> ;
: $sdec #os-s tuck tlen dup if swap tlen + over tlen! else 2drop then ;
: $smap #ro-s over dup tdat rbox exec nsha $sdec ;
: $smi1 #nv-nv mkv + $mkv2 swap nsha 2dup $sdec drop over ! 1+ ;
: $smit #nv-nv b2p begin over Smk > while $smi1 repeat ;
: $smem #v- $mkv2 ?if dup mseek + swap $smit then 2drop ;
: $icol #orv-ors 2 pick if icol then ;
: $scol #o-g Wo ^count Wo $icol b2p over nvec b2p tuck tdat! $sall dup $smem ;

\ attach column to mapped data
: oinfo #-r Wo ^info Wo box ;
: $vc #-x vskip mseek oinfo 2 ^at Wo ^count { drop dup loadv } map* nip ;
: $sc #t-x S' typ= neg vskip Smk rbox $scol tuck tlen!
      { #r-s dup @ dup 0< if nip else $smap then } custg ;
: $ic #-x Wo icol ;

\ Ffixn is forward declared because nullable cols require bitmap/xbit utils
\ the default code tries (!) to treat nullable cols as std cols for now
variable Ffixn   { #Wo=v #bsn-b Wo tlen! drop } to Ffixn
: $cfix2 #t-b
    dup V' typ= if $vc else dup BorS if dup $sc else $ic then then nip ;
: colfix #-b oinfo 1 ^at #t dup typn? if Wo tlen swap #nt
    $mkv2 swap nsha mkv Wo tlen! rrot $cfix2 rrot Ffixn exec else $cfix2 then ;
\ Smk is set to a custom getter so it can be used for lazy offsets
: mkopen #s-v mkroot dup nil? 0= if
    { #r-x dup Wo @ box to Smk colfix dup Wo ! over box exec nip } custg
    to Smk Wn loadv b2o then ;
\ open file, return as view, error -1000 if no such file or -1001 if not valid
: mkfopen #s-v xmmf exec dup str? if mkopen else drop Wn -1000 box then ;

# <STARTUP> --------------------------------------- optional starkit launch ---

: skfind #vs-r over fixsz { 0 ^at over cmp 0= } fnd* nip box ;
: findez #vs-s skfind dup ^count over = if drop Wn else
    dup 3 ^at swap 1 ^at over tlen over =
    if drop else nbuf swap xdez exec then then ;

Ww 100 box constant infv
Ww 101 box constant exef
Ww 102 box constant argv

\ stores opened MK dirs view
variable Exe

{ infv 0 b@ 'Vq s= if exef mkfopen dup -1 >= if
  b2p 'dirs ncol ^at b2p dup to Exe 2 ^at 'boot.th findez eval then then } exec

# <VECSTR> ------------------------------------ vector and string utilities ---

: vnew #i-v dup nvec tuck tlen! ;
: vdup #v-v dup { over swap b@ } map* nip ;

\ nil if out of bounds, support end-relative
: v@ #vi-x duo 0< if over tlen + then
    over tlen over > over 0< or if 2drop Wn exit then b@ ;
: v,@ #vij-v >r box r> { drop dup 1+ swap @ } map* nip ;
: v..@ #vij-v over - v,@ ;

: vfirst #v-x 0 v@ ;
: vlast #v-x -1 v@ ;

: vfull? #v-f dup tlen swap tmax >= ;

\ from end
: vpop #v-vx dup tlen if dup b2o -- dup dup tlen b@ else Wn then ;
: vatend #vx-v >r dup vfull? if grow then r> over dup tlen b! ;
: vpush #vx-v vatend dup b2o ++ ;

\ may not be called on empty vecs
: vrot #v-v dup b2p @ over b2o dup -- { dup 1+ @ swap ! } rep* vpush ;
: vdel #vn- box 1+ dup tlen over - over 1- swap vcpy b2i swap tlen! ;

\ from start
: vshift #v-vx dup tlen if vrot then vpop ;
: vunshift #vx-v vpush vrev vrot vrev ;

\ append string, advancing pointer
: scopy #ps-p { c@ over c! 1+ } rep* ;

\ basic string ops
: srep #sn-s swap o( tlen over * nbuf b2p swap { drop Wo scopy } rep* end2p )o ;
: scat #ss-s over tlen over tlen + nbuf b2p rot scopy swap scopy end2p ;

\ vec->str, pre-flights to calc result string size
: sjoin #vs-s over tlen if o( drop
      0 over { @ tlen + } rep* #vn over tlen 1- Wo tlen * + #vn
      nbuf b2p swap { #se dup if swap Wo scopy swap then @ scopy } rep* end2p
    )o else 2drop "" then ;
\ str->vec, split on single character
: csplit #sc-v over { c@ over = } sel* nip over tlen vpush
    swap o( drop 0 swap { @ Wo rot box 2dup - nsha >r 1+ r> } map* )o nip ;

\ fill with constant
: vfill #vx-v over { 2dup ! drop } rep* drop ;
: v,fill #vijx-v o( drop >r box r> { over swap + Wo swap ! } rep* b2o )o ;
: v..fill #vijx-v >r over - r> v,fill ;

# <EXTRA> ---------------------------------------------- extra utility code ---

\ like C's "*ptr1++ != *ptr2++" expression
\ : <>++ #pp-ppf over @ over @ <> >r 1+ swap 1+ swap r> ;
\ compare all filled elements of two boxes
\ : bcmp #vv-f dup @ 1+ begin dup 0> while 1- >r <>++ r> or repeat 0= nip nip ;
\ : spaces #i- { drop sp } rep* ;

\ arithmetic utilities

: u< 2dup xor 0< if swap drop else - then 0< ;
: u> swap u< ;

: max 2dup < if swap then drop ;
: min 2dup > if swap then drop ;
: within over - rrot - u> ;

\ statistics and symbol table

variable Ticks
0 to Ticks

: elapsed #- usec Ticks - .p " uSec" .p usec to Ticks ;
: words #- 0 Ws Wv box { @ .p sp } rep* nl ;

\ simple system statistics and info

: cycle #-n usec 249 begin 1- dup 0= until drop usec swap - ;
: ./. swap .p "/" .p .p ;

: pos/tot #e- dup b2i swap tmax ./. ;
: stats #- sp
  Wc pos/tot " codes, " .p
  Wv pos/tot " syms, " .p
  Ww b2i var0 - dsp0 3 - var0 - ./. " vars, " .p
  Wu Wh ./. " gc, " .p
  cycle .p " nS/op\n" .p
;
: info #- sp
  highbit .p   " highbit, " .p 
  bits/int .p  " bits/int, " .p 
  bytes/box .p " bytes/box, " .p 
  var0 .p " var0, " .p 
  dsp0 .p " dsp0 \n" .p
;

# <VUTIL> ----------------------------------------------- view utility code ---

\ accessors and modifiers for Wo args and temps (note that vt3 overlaps va4)
: va1 Wo 0 b@ ;   : va2 Wo 1 b@ ;   : va3 Wo 2 b@ ;   : va4 Wo 3 b@ ;
: vt1 Wo 5 b@ ;   : vt2 Wo 4 b@ ;   : vt3 Wo 3 b@ ;
: vt1! Wo 5 b! ;  : vt2! Wo 4 b! ;  : vt3! Wo 3 b! ;
\ special purpose, for mutable views
: va2! Wo 1 b! ;  : va3! Wo 2 b! ;  : va4! Wo 3 b! ;

\ should not used for fun/mutviews, since args must remain intact
: va1! Wo 0 b! ;  : va2! Wo 1 b! ;  : va3! Wo 2 b! ;

variable Mnone  variable Mmap  variable Mint  variable Mstr
\ also set up a meta view with no columns, can be used for counts
  0 1 ( ) mktopmeta to Mnone
  0 1 ( 'M 'I typ2i -1 ) mktopmeta to Mmap
  0 0 ( 'I 'I typ2i -1 ) mktopmeta to Mint
  0 0 ( 'S 'S typ2i -1 ) mktopmeta to Mstr

: mkcount #n-v ( ) Mnone rot mkrowview ;
: mkmapvw #b-v Mmap over tlen mkrowview ;
: mkintvw #n-v 1pck Mint 1 mkrowview ;
: mkstrvw #s-v 1pck Mstr 1 mkrowview ;
: mksubvw #v-v
    dup 1pck swap 'V 'V typ2i rot ^meta 3 pack 0 0 rot mktopmeta 1 mkrowview ;

\ ^Fun views have a vtable which defines their behavior
\ the meta row of the result needs to be determined right away, but ^count
\ and ^at are set up on first use, calling the init member to set things up
\ this machinery will be needed for change propagation and re-calculation

: $vfix #- Wo tlen dup 4 b@ Wo 8 b! dup 5 b@ Wo 9 b! 3 b@ ljmp ;
: $padn #n-b 1 b@ - { drop Wn } rep* 
    { #-n $vfix Wo 8 b@ exec } { #c-x $vfix Wo 9 b@ ljmp } 10 pack ;
: $Fun #*tf-v 2>r 8 r@ $padn Wn 2r> exec o( Wo tlen 2 b@ exec Wo ttag! )o ;
: ^Fun #*t-v lit mkfunview $Fun ;

\ this variant is used to set up a mutable view, see MutF below
: $Mut #*t-v lit mkmutview $Fun ;

\ ^Late views are ^Fun views, but they end up setting up a view which gets
\ used for all ^count and ^at calls - lazily so, i.e. on first data access
\ the dispatch table is slightly simpler, but there is a double indirection
\ late dispatch: 0=name 1=argc 2=metaf 3=initf
: ^Late #*t-v >r 8 r@ $padn Wn 
    { { vt1 0 b@ } ,nip { vt1 1 b@ } ,nip { #-v vt1 2 b@ ljmp } ,nip
      { #- vt1 3 b@ exec vt2! } ,nip
      { #-n vt2 ^count } ,nip
      { #c-x vt2 Wo box swap ^at } ,nip
    } mkfunview r> swap o( swap vt1! Wo tlen 2 b@ exec Wo ttag! )o ;

: mknewmeta #v-o 0 1 rot getall mktopmeta ;
: samemeta #-v va1 ^info mknewmeta ;

# <HASH> ------------------------------------------------------- hash views ---

\ create mutable view with empty columns named "k" and "v" of specified type
: hnew #tt-v 2>r 0 ( ( ) ( ) ) 0 1
    'k r> typ2i Wn 'v r> typ2i Wn 6 pack mktopmeta rot mkcolview ;
: $hsetk #vx-p vatend va1! va1 tlen int? if va1 p2end hshm then va1 p2end ;
: hpos #xv-r o( drop va1 swap $hsetk 0 hshf Wo rbox )o ;
: hfnd #xv-x hpos dup 0>= if dup 1 b@ swap b@ else drop Wn then ;
: hset #vxy- rot o( drop va1 rot $hsetk 1 hshf dup 0>=
    if va2 rbox ! else drop Wo b2o ++ va1 b2o ++ va2 swap vpush va2! then )o ;
: hdel #xv- hpos dup 0>= if dup 0 b@ over vdel 
\ lazy way out, force complete rehash for now
    dup 0 b@ dup tlen b2i swap tlen!
    dup 1 b@ over vdel b2o -- else drop then ;

# <PARSER> ----------------------------- generic parser and code generators ---

\ rul=5 rdc=6 tab=7 key=8 val=9 nod=10 pval=11 txt=12 sym=13 ops=14 xpar=15
\ 16..17 spare, for internal use

\ init from persistent views, args: views sym par txt
: $vpar1 #rii- >r getcol Wo r> b! ;
: vparini #sbii-o 100 nvec o( 12 b! xpar rbox Wo 15 b! Wo 14 b! mkopen
    0 box dup 0 #states ^at dup 0 #r 5 $vpar1 dup 1 #c 6 $vpar1 2 #t 7 $vpar1
	  dup 1 #nodes  ^at 0 #s 10 $vpar1
	  dup 2 #words  ^at 0 #s 13 $vpar1
	      3 #trans  ^at dup 0 #k 8 $vpar1 1 #v 9 $vpar1
    Wo mao Wo b2o )o ;

: parser #os-v over 0 b! 0 over 1 b! 0 over 2 b! 0 over 3 b! 0 over 4 b!
  Wn over 19 b! 20 over tlen!  
  begin #o dup dup dup 15 b@ exec dup b2i xpar exec until
  dup tlen 1- b@ b2o ;

# Gview has main view while generating code, used only in gensym to optimize
variable Gview
variable Fgen1 #forward
: gunaop #- va2 Fgen1 ljmp ;
: gbinop #- gunaop va3 Fgen1 ljmp ;
: gcmpop #-x gbinop lit cmp , lit b2i ;
: gensym #-x
\ do the column lookup while generating code, so repeated use will be faster
    lit Wo , va2 dup str? if Gview ^info ncoli else , lit ncol then , lit ^at
    Wo tlen 2 > if , va3 , lit ncol , lit box then ;
: gdofun #bs-x swap '::thrill::funget rrot 3 pack 'S heval ;
: genfun #-x va3 { dup 1 and if @ Fgen1 exec else drop then } rep*
    'vfun- va2 scat dup def? if find Wv rbox @ else
      drop va3 tlen 2/ , lit pack , va2 , lit gdofun then ;
: gen1 #x- o( vec? if
    { #sym  gensym 
      #var  { '::thrill::varget va2 2 pack 'S heval } ,nip
      #or   { gbinop lit or } ,nip
      #and  { gbinop lit and } ,nip
      #=    { gcmpop lit 0= , } ,nip
      #<    { gcmpop lit 0< , } ,nip
      #>    { gcmpop lit 0> , } ,nip
      #<=   { gcmpop lit 0<= , } ,nip
      #>=   { gcmpop lit 0>= , } ,nip
      #<>   { gcmpop lit 0<> , } ,nip
      #+    { gbinop lit + } ,nip
      #-    { gbinop lit - } ,nip
      #*    { gbinop lit * } ,nip
      #div  { gbinop lit div } ,nip
      #0=   { gunaop 0= } ,nip
      #neg  { gunaop neg } ,nip
      #bind 'bind? 
      #fun  genfun 
      #arg  'arg? 
    } va1 b@ exec
\ convert ints and string via a lookup, drop the trailing " in strings
    else Wv Wo dup 0 box c@ #" 34 = if dup -- then find b@ then
    , )o ;
lit gen1 to Fgen1

: genc #fvos-x parser over to Gview Wt Wc rot gen1 (cb)
    rrot fixsz { o( drop dup exec )o } rot if map* else sel* then nip ;

\ TODO global var with current parsing object, should get rid of this
variable Xpo

: setxpar #n- xpar rbox Xpo 5 b! ;
: xparser #s- 6 nvec tuck 0 b! to Xpo 3 setxpar ;
: xtoken #-x Xpo dup 5 b@ exec
    dup 1 = if 4 setxpar then dup 4 = if 3 setxpar then ;
: xmloop #s- xparser
    begin xtoken dup 257 < if { ' '< '= '/ '> } over b@ Wn else
	{ 'D 'T '? 'C '! 'Q 'I } over 257 - b@ over b2o then
      '::thrill::xmlfun rrot 3 pack 'n heval drop 0= until ;
: xmltok #-xy xtoken dup 257 < if { ' '< '= '/ '> } swap b@ Wn
    else { 'D 'T '? 'C '! 'Q 'I } over 257 - b@ swap b2o then ;
: xmltoken #-x xmltok 2 pack ;
: xmltokens #-v 100 nvec 50 { drop xmltok >r vpush r> vpush } rep* ;

# <BITMAP> ---------------------------------------------- bitmap operations ---

'xbit def? constant hasXbit

: b.count #s-n xbit exec b2i ;
: b.nth1 #s-n xbit 1 box exec b2i ;
: b.topbit #n-n xbit 2 box exec ;
: b.pack #s-s xbit 3 box exec ;
: b.unpack1 #s-n xbit 4 box exec ;
: b.lohi #s-nn xbit 5 box exec b2i swap b2i swap ;
: b.convi #sn-s xbit 6 box exec ;

: .b #n- 8 { over swap 7 xor >> 1 and .p } rep* drop ;
: dumpb #s- dup tcnt box { c@ sp .b } rep* ;

\ iterate over all 1-runs in packed bitmap, exec given code with o+n on stack
: bruns #bf- swap 1 over tadr!
  dup >r 0 box c@ 128 and if 0 else r@ b.unpack1 then
  begin r@ b.unpack1 dup while 2 pick exec + r@ b.unpack1 + repeat
  r> 2drop 2drop
;

\ in C: i < 0 ? -2 - topbit((UQ)~i) : topbit((UQ)i) + 1;
: sprec #i-i dup 0< if not b.topbit 2+ neg else b.topbit 1+ then ;

\ determine how far int vectors can be "narrowed down"
\ ranges are: 0 0,1 0,3 0,15 -128,127 -32768,32767 and 4-byte ints
\ tricky because smaller ranges are unsigned-only
\ do not compress below 1-byte ints if vector size < 8 (unless all zero's)

\              012 4   8       16
: $bwpos #i-i '01233444555555556666666666666666 rbox c@ 7 and ;
: $bwneg #i-i '04444444455555555666666666666666 rbox c@ 7 and ;
: $width #s-n b.lohi #lh 0 max sprec $bwpos swap 0 min sprec neg $bwneg max ;
: bwidth #s-n dup tlen 8 < 4 * swap $width dup if max else nip then ;

: bcount #v-n p2end dup 7 + 8 div box b.count ;

# <MKSAVE> -------------------------------------- serialize to Metakit file ---

\ debugging: print a box offset + tlen + tcnt, leave box on the stack
: b? #b-b sp dup b2i 'b?\soff ?? dup tlen b2i 'len ?? dup tcnt b2i 'cnt ?? ;

\ replace Ffixn to properly handle loading of nullable columns
\ XXX currently expands all nulls right away, fix it later to work lazily
variable Tmap
variable Tsome
{ #Wo=v #bsn-b dup Wo tlen! { drop lit Wn } map* to Tmap swap b2p to Tsome
\ can't access stack inside bruns loop, because there is more stuff on it
  { #xy 2dup { drop Tsome over Tmap rbox ! 1+ 1 +to Tsome } rep* drop } bruns 
  Tmap 
} to Ffixn

\ forward declaration to fix up state hash lookup of views
variable FixV   lit noop to FixV

variable Evec
variable Outf
variable Esub
variable Ebeg

: addv #i- Evec swap vpush to Evec ;
: addp #ii- dup addv if addv else drop then ;
: epos #-i Outf 0 1 fseek Ebeg - ;
: emit #s- Outf swap fwrite drop ;
: em1b #c- '? tuck b2p c! emit ;
: em1v #i- dup 0< if 0 em1b not then 0 begin 7 + 2dup >> 0= until
       begin 7 - 2dup >> 127 and over 0= 128 * + em1b dup 0= until 2drop ;
: em4be #i- dup 24 >> em1b dup 16 >> em1b dup 8 >> em1b em1b ;

: v2i #v-b lit @ maq* ;
: $v2is #b-s v2i dup bwidth b.convi dup tcnt over tlen! ;
: $emi1 #b- epos >r emit r> epos over - addp ;

: enil #b-b dup { @ nil? 0= } bit*
    dup b.pack dup tcnt over tlen! $emi1 dup tlen addv dup dup tlen!
    #bb dup tlen xop0 3 box exec b2o { i@ over rbox @ } map* nip ;

: $eint #b- $v2is $emi1 ;
: $estr #bfg- >r epos 2>r dup r> rep* r> epos over - tuck addp
	if r> map* $v2is $emi1 else r> 2drop then 0 addv ;
: $edmp #t- 0 em1v dup 0 b@ ?if dup tlen em1v emit then
	dup 1 b@ dup em1v if 2 b@ { @ em1v } rep* else drop then ;
: $esub #b- { @ FixV exec 0 Esub ljmp } map*
        epos >r { @ $edmp } rep* r> epos over - addp ;
: $ecol #vm-v 2dup getcol swap 1 ^at #vbt dup typn? if swap enil swap then
    dup I' typ= if drop $eint else dup V' typ= if drop $esub else
    S' typ= if { @ emit 0 em1b } { @ tlen 1+ } else { @ emit } { @ tlen } then
	      $estr then then ;

: $capp #sc-s over c! 1+ ;
: $sapp #ss-s { c@ $capp } rep* ;
: $mapp #sm-s { o( if ,' $capp then Wo 0 ^at $sapp
	        Wo 1 ^at V' typ= if [' $capp Wo 2 ^at 2 ^at $mapp ]' $capp 
		  else :' $capp Wo 1 ^at typ2s $sapp then )o } rep* ;
\ XXX fixed size desc str buffer
: m2dsc #m-s 1000 nbuf b2p swap $mapp dup b2i over tlen! b2o ;

{ #vf-t
  Evec 2>r dup ^info 0 nvec to Evec #vm fixsz lit $ecol rep*
  #v r> if dup ^info m2dsc else 0 then swap ^count Evec 3 pack r> to Evec 
} to Esub
: $ehdr #- bigend if 'LJ else 'JL then emit 0x1a em1b 0 em1b 0 em4be ;
: $emrk #ps- 0x80000000 em4be epos 4 - em4be 0x80000000 + em4be em4be ;
: svout #vf-ps Esub exec epos >r $edmp r> epos over - ;
: ^save #vd-i to Outf 0 to Ebeg epos to Ebeg b2o $ehdr 1 svout $emrk epos ;

# <VOPS> ------------------------------------- view accessors and operators ---

: ^pass #v-v 
  { 'pass 1 { #-v va1 ^meta } ,nip
    noop
    { #-n va1 ^count } ,nip
    { #c-x va1 Wo box swap ^at } ,nip
  } ^Fun ;

: ^clone #v-v 
  { 'pass 1 { #-v va1 ^meta } ,nip
    noop
    0
    noop
  } ^Fun ;

: ^iota #is-v
  { 'iota 2 { #-v 0 0 ( va2 'I typ2i -1 ) mktopmeta } ,nip
    noop
    { #-n va1 } ,nip
    { #c-x drop Wo b2i } ,nip
  } ^Fun ;

: ^repeat #vn-v 
  { 'repeat 2 samemeta
    { #- va1 ^count vt1! } ,nip
    { #-n vt1 va2 * } ,nip
    { #c-x va1 Wo vt1 mod box swap ^at } ,nip
  } ^Fun ;

: ^spread #vn-v 
  { 'spread 2 samemeta
    noop
    { #-n va1 ^count va2 * } ,nip
    { #c-x va1 Wo va2 div box swap ^at } ,nip
  } ^Fun ;

: error #s-e Wn ttag! Wn b2o ;
: colscheck #vv-vv1|e0 over ^names over ^names over tlen over tlen = if
    { dup @ >r over rbox @ r> cmp 0= } cnt* swap tlen = else 2drop 0 then
    if 1 else 2drop "not same columns" error 0 then ;
  
: ^concat #vv-v 
  colscheck if FixV exec
  { 'concat 2 samemeta
    { #- va1 ^count vt1! } ,nip
    { #-n vt1 va2 ^count + } ,nip
    { #c-x Wo vt1 < if va1 Wo else va2 Wo vt1 - then box swap ^at } ,nip
  } ^Fun then ;

: pairmeta #-v va1 ^info va2 ^info ^concat mknewmeta ;

\ XXX meta view keys and dups could be same as leftmost view
: ^pair #vv-v FixV exec
  { 'pair 2 pairmeta
    { #- va1 ^info vt1! } ,nip
    { #-n va1 ^count } ,nip
    { #c-x dup vt1 < if va1 else vt1 - va2 then Wo box swap ^at } ,nip
  } ^Fun ;

: ^tag #vs-v over ^count swap ^iota ^pair ;

\ ^product #vv-v dup ^count >r over ^count ^repeat swap r> ^spread swap ^pair ;
: ^product #vv-v FixV exec
  { 'product 2 pairmeta
    { #-v va1 va2 ^count ^spread va2 va1 ^count ^repeat ^pair } ,nip
  } ^Late ;

: ^maprow #vb-v 
  { 'maprow 2 samemeta
    noop
    { #-n va2 tlen } ,nip
    { #c-x va1 va2 Wo b@ box swap ^at } ,nip
  } ^Fun ;

\ condense nonzero entries
: cdense #b-b { @ 0<> } sel* ;
\ skip first entry, which is "-omit"
: colomits #vb-vb dup tlen 1 = if drop ( ) else
    dup 1 b@ over 0 b! over ncols over ^width { drop 1 } map*
    swap #vmb { @ over rbox 0 swap ! } rep* cdense then ;

: ^mapcols #vb-v 
  dup tlen if dup b2p @ '-omit s= if colomits then then
  dup tlen if
    { 'mapcols 2 { #-v va1 ^info va2 va1 ncols ^maprow mknewmeta } ,nip
      { va2 va1 ncols vt1! } ,nip
      { #-n va1 ^count } ,nip
      { #c-x vt1 swap b@ va1 Wo box swap ^at } ,nip
    } ^Fun else drop then ;

: ^slice #viii-v 
  { 'slice 4 samemeta
    noop
    { #-n va3 } ,nip
    { #c-x va1 Wo va4 * va2 + box swap ^at } ,nip
  } ^Fun ;

: ^reverse #v-v
  { 'reverse 1 samemeta
    { #-v va1 dup ^count 1- dup 1+ -1 ^slice } ,nip
  } ^Late ;

: ^first #vi-v
  { 'first 2 samemeta
    { #-v va1 0 va1 ^count va2 min 1 ^slice } ,nip
  } ^Late ;

: ^last #vi-v
  { 'last 2 samemeta
    { #-v va1 va2 over ^count over - dup 0< if + 0 then swap 1 ^slice } ,nip
  } ^Late ;

# a view with the same structure containing one row of all nil's
: ^empty #v-v
  { 'empty 1 samemeta
    noop
    { #-n 1 } ,nip
    { #c-x drop Wn } ,nip
  } ^Fun ;

: ^take #vi-v dup >r abs over ^count #vac 2dup > if
      dup >r over #vaca + 1- r> div #var rot swap ^repeat swap #va
    else drop then #va r> 0< if ^last ^reverse else ^first then ;

: ^delete #vii-v
  { 'delete 3 samemeta
    { #-v va1 va2 ^first va1 dup ^count va2 - va3 - ^last ^concat } ,nip
  } ^Late ;

: ^omitcol #vi-v 
  { 'omitcol 2 { #-v va1 ^info va2 1 ^delete mknewmeta } ,nip
    noop
    { #-n va1 ^count } ,nip
    { #c-x va1 Wo box swap dup va2 >= + ^at } ,nip
  } ^Fun ;

: ^blocked #v-v 
  { 'blocked 1 { #-v va1 ^info b2p 2 ^at } ,nip
    noop
    { #-n va1 fixsz 0 swap { #nv-n 0 ^at ^count + } rep* } ,nip
    { #c-x Wo va1 b2p #vr
	begin 2dup 0 ^at ^count - dup 0> while swap 1+ >r box 1- r> repeat
	#vrn 0= if box va1 fixsz 1- then 0 ^at rbox swap ^at } ,nip
  } ^Fun ;

\ sorting - from http://www.forth.org/fd/FD-V5N5.pdf p.29
\ adjusted to support custom comparison functions and int vectors

variable Fcmp
: $sort #se- 2dup 2dup over - 2/ + @ >r
    begin
      swap begin dup @ r@ Fcmp exec while 1+ repeat
      swap begin r@ over @ Fcmp exec while 1- repeat
      2dup <= if 2dup 2dup @ swap @ rot ! swap ! swap 1+ swap 1- then
      2dup >
    until r> drop 
    tuck over - >r rot dup 3 pick - r> < if 2swap then
    2dup < if $sort else 2drop then
    2dup < if $sort else 2drop then ;
: fsort #vf- to Fcmp b2p over dup tlen 1- box $sort ;

\ row compare (I&S, order must match), -2/+2 = data diff, -1/+1 = rownum diff
: rcmp@ #rrv-rrf >r over r@ ^at over r> ^at cmp ;
: rcmp #rr-n dup ^info lit rcmp@ fnd* 
    over ^info ^count over = if drop - sgn else rcmp@ 2* nip nip then ;

\ view sort map and reorder
: sortmap #v-b o( ^count lit noop map* dup tlen if dup
    { #nn-f Wo rot box Wo rot box rcmp 0< } fsort then )o ;
: ^sort #vb-v
    dup tlen if over swap ^mapcols else drop dup then sortmap ^maprow ;

\ row differences, first entry is always set
: vdelta #v-b fixsz
    { #r-f dup 0= if 0= else dup 1- rcmp 2/ 0<> then b2i } map* ;
\ invert a permutation
: pinv #b-b b2o dup tlen dup nvec tuck tlen! swap
    { dup >r b2i over r> @ box ! } rep* ;
\ invmap permutes a box, like ^maprow does for views
: invmap #bb-b { @ over swap b@ } map* nip ;
: notz #b-b { @ 0= } map* ;
: $umap #vf-v
    >r dup sortmap 2dup ^maprow vdelta swap pinv invmap r> exec cdense nip ;
: $uori  #vf-v over swap $umap ^maprow ;

: $unique #v-v lit noop $uori ;
: ^uniqmap #v-v lit noop $umap ;
: Xunique #v-v drop lit noop $uori ;
: ^unique #vb-v
    dup tlen if 2dup ^mapcols ^uniqmap nip ^maprow else drop $unique then ;

: ^union #vv-v colscheck if ^concat $unique then ;
: ^project #vb-v ^mapcols $unique ;
: ^intersect #vv-v colscheck if FixV exec swap ^concat lit notz $uori then ;

\ $clrp clears the previous delta if next one is clear
: $clrp #b-b b2p begin 1+ dup dup tlen < while
    dup @ over 1- dup @ rot and swap ! repeat b2o ;
: ^except #vv-v colscheck if over >r ^concat dup sortmap tuck ^maprow vdelta
    $clrp swap pinv invmap r@ ^count over tlen! cdense r> swap ^maprow then ;

: ^pick #vb-v cdense ^maprow ;

\ does rename need a funview, even though it only affects the meta info?
: bsplit #b-bb dup tlen 2/ { 2* 1+ over rbox @ } map*
	    >r dup tlen 2/ { 2* over rbox @ } map* nip r> ;
: $rname #bno-b { 2dup b@ swap @ 3 * 3 pick swap b! } rep* drop ;
: ^rename #vb-v bsplit
  { 'rename 3 { 0 1 va1 ^info getall va3 va2 va1 ncols $rname mktopmeta } ,nip
    noop
    { #-n va1 ^count } ,nip
    { #c-x va1 Wo box swap ^at } ,nip
  } ^Fun ;

# <MUTABLE> ------------------------------------------------- mutable views ---

\ The current code cuts a lot of corners:
\  - no bitmaps, a single vec overlays each cell in rowwise order
\  - always a permutation, set to iota at init time
\  - value replacement stores the new value in overlay, making entry non-nil
\  - when setting an inserted row, make that view mutable and set recursively 
\  - insertion uses ^concat, adding an extra layer to the insert view
\  - deletion just drops entries from the permutation map

\ va1=view va2=map va3=overlay va4=mods (va2..va4 are pseudo args, not inputs)
\ if map entry < 0: lower 31 bits are index in mods view
: $insvw #n-r 0x7fffffff and va4 rbox ;
: $mutf #v-v 0 0 0
  { 'mut? 4 samemeta
    { #- va1 ^count dup lit noop map* va2!
	  va1 ^width * { drop Wn } map* va3!
	   ( ) va1 ^meta 0 mkrowview va4! } ,nip
    { #-n va2 tlen } ,nip
    { #c-x va2 Wo b@ dup 0< if $insvw swap ^at else
	    va1 rbox swap 2dup va1 ^count * + va3 rbox @ 
	    dup nil? if drop ^at else nip nip then then } ,nip
\ careful: mutable view has to be inited right away, as we go poking inside it!
  } $Mut dup ^count drop ;
lit $mutf to MutF

\ each of the mutating functions below returns the modified view
\ if the input was mutable it is changed, otherwise a mutable layer is added

\ use rowset to make the change if the change is to an inserted row
: rowset #rcx- rot dup ^width * rot + ! ;

: ^Set #rcx-v rot dup ^Mut o( drop #cxr va2 rbox @ dup 0<
    if $insvw rrot rowset else rot va1 ^count * + va3 rbox ! then Wo )o ;
: ^vset #vrcx-v 2>r box r> ncol r> ^Set ;

\ general row re-order: exchange groups of rows with each other
\ if both groups are same size, simply exchange them element by element
\ represents a move if either group is empty

\ The problem: exchange A and C, where the box contains "... <A> <B> <C> ..."
\     A starts at index N, size of A is X, B is Y, C is Z.
\ Solution is to do 3 in-place element range reversals:
\     [N..N+X+Y)  [N+Y..N+X+Z)  [N..N+Y+Z)
\ I.e. A B C -> B' A' C -> B' C' A -> C B A

: chg-s #rr- #swap over @ over @ 3 pick ! over ! 2drop ;
: chg-x #rrn- #exchange 2/ { drop chg-s 1+ swap 1+ swap } rep* ;
: chg-f #rn- #flip
    o( 2/ { 2dup 2dup - Wo + 1- rrot + chg-s drop } rep* )o drop ;
: chg-r #rxzy- #relocate 2over 2over nip + chg-f
    2over 2over rrot + >r + r> chg-f 2over 2over + nip chg-f 2drop 2drop ;
: ^Chg #rnrn-v 3 pick ^Mut o( drop
    >r va2 rbox 2>r va2 rbox 2r> r>
    2 pick over =
    if drop swap chg-x else 3 pick rot - abs 2 pick - chg-r then Wo )o ;

# first view must already be a row-wise view
: rowcat #vv-v dup >r ^count over ^count + tuck over ^width * #rvn vnew b2p
    swap b2p swap over tmax vcpy #rvn r> getall b2p tuck tlen vcpy nip #rvn 
    b2o swap ^meta rot mkrowview ;

\ insertion starts by appending, then moves rows to the proper place
\ starts by setting up a new map with extra entries 
: ^Ins #rv-v colscheck if FixV exec over ^Mut o( drop va2 tlen over ^count + 
    { #rvi dup va2 tlen <
      if va2 rbox @ else va2 tlen - va4 ^count + 0x7fffffff not or then
    } map* va2! va4 over rowcat va4!
    >r va2 rbox dup tlen over - r> ^count swap over - 0 rrot chg-r Wo )o then ;
: ^insert #vrv-v >r box r> ^Ins ;
: ^append #vv-v >r dup ^count box r> ^Ins ;
\ deletion starts by exchanging to end, then truncates the map
: ^Del #rn-v dup >r over ^count 0 ^Chg r>
    swap o( #nv va2 tlen rot - va2 tlen! )o ;
: ^delete #vrn-v >r box r> ^Del ;
: ^replace #vrv-v >r tuck box r@ ^count ^Del rbox r> ^Ins ;

# <VSTATE> ------------------------------------ view state and transactions ---

variable Vstate
'V 'V hnew to Vstate

\ make sure view is current version
: vsget #v-v dup b2o Vstate hfnd dup nil? if swap then nip ;
\ make sure view is mutable, or register a new one if not
: vsmut #v-v dup b2o Vstate hfnd dup nil? if drop 
    Vstate swap b2o dup $mutf dup >r hset r> else nip then ;

\ adjust previous forward declarations to become state aware
lit vsget to FixV lit vsmut to MutF 

: ctypes #vb-b over ^info o( drop { @ ncol Wo rbox 1 ^at } map* nip )o ;

\ another map is needed to tie an object to its string "path" for MK
variable Vpaths
'V 'S hnew to Vpaths
: vpdef #sv- vsmut swap Vpaths rrot hset ;
: vpath #v-s Vpaths hfnd ;

# <VGROUP> --------------------------------------------- grouping and joins ---

\ subviews in groupby are generated on the fly, and then cached
: ^gsubvw #udsn-v
  { 'gsubvw 4 { #-v 0 0 ( va4 'V typ2i va1 ^meta ) mktopmeta } ,nip
    noop
    { #-n va2 tlen } ,nip
    { #c-x drop va3 Wo b@ dup 0= if drop
	va1 va2 Wo box dup @ swap 1+ @ over - 1 ^slice
	dup va3 Wo b! then Wo box } ,nip
  } ^Fun ;

\ identity vec of size n, but leaving out specified values
: allbut #bn-b dup nvec tuck tlen! >r p2end
    begin 1- dup 0>= while 1 over @ r@ swap b! repeat drop r> notz cdense ;
\ create new box with n added past end, i.e. same tlen
: $vgex #bn-b swap b2p dup tlen 1+ nvec tuck b2p over tlen vcpy 2drop
        dup tmax 1- over 2dup tlen! >r b! r> ;

\ group is complex due to stack shuffling, but completely linear
\
\   in: view group-col-list new-group-col-name
\   - extract cols (mapcols) and create a sortmap for them
\   - apply the sortmap to the entire view and to the col subset
\   - use vdelta and cdense to locate first of each repetition
\   - add a sentinel at end so last group also is valid
\   - create a subview vect which caches results in a box
\   - subviews are slices using remaining reordered columns

: $grp #vgn-vv 2>r dup r@ ^mapcols dup sortmap tuck ^maprow >r ^maprow r>
    dup vdelta cdense 2 pick ^count $vgex tuck ^maprow rot
    r> over ncols over ^info allbut ^mapcols rot dup tlen nvec r> ^gsubvw ;
: ^group #vgn-v over tlen
    if $grp ^pair else >r drop mksubvw 0 r> 2 pack ^rename then ;

\ row counts of subviews
: ^counts #vc-b ncol swap fixsz { #ce-cn over ^at vsget ^count } map* nip ;
: ^norows #vc-b ncol swap fixsz { #ce-cn over ^at vsget ^count 0= } sel* nip ;

\ divide returns rows from first half of a groupby when subview is a superset
: $nmvw #v-v ^info ( 0 ) ^mapcols ;
: $div #vv-b swap fixsz
    { #vr-vf 0 ^at vsget over ^intersect ^count over ^count = } map* nip ;
: ^divide #vv-v FixV exec
    >r dup $nmvw r@ $nmvw ^except 0 getcol '_D $grp r> $div ^pick ;

\ this is xops,6 recoded in Thrill
: ispread #vn-v dup nvec tuck tlen! b2p swap 0 o( drop
    { @ dup 0> if #pi >r Wo over ! 1+ r> #pi 1- { neg 1- over ! 1+ } rep*
		else drop then 1 +to Wo } rep* )o b2o ;
: $nsmap #b-v 0 over { @ + } rep* ispread ;
: ^nspread #vb-v
  { 'nspread 2 samemeta
    { #- va2 $nsmap vt1! } ,nip
    { #-n vt1 tlen } ,nip
    { #c-x va1 vt1 Wo box dup @ dup 0< * + @ box swap ^at } ,nip
  } ^Fun ;

: ^subcat #vc-v
  { 'subcat 2
      { #-v va1 va2 ncol swap ^info rbox 2 ^at } ,nip
    { #- va1 va2 ncol dup vt2! ^counts $nsmap vt1! } ,nip
    { #-n vt1 tlen } ,nip
    { #c-x va1 vt1 Wo box @ dup 0< if #vi
	     dup >r Wo + vt1 rbox @ box r> neg
	   else box 0 then >r vt2 ^at vsget r> box swap ^at } ,nip
  } ^Fun ;

: ^ungroup #vc-v
    ncol 2dup 2>r ^counts r@ swap ^nspread r> r@ ^subcat ^pair r> ^omitcol ;

\ join returns same rows plus a new subview col
: $jsub #m-v ( ) swap 0 mkrowview ;
: $jext #v-v dup ^info b2p 2 ^at $jsub 1pck over ^meta 1 mkrowview ^concat ;
: $join #kl-b fixsz swap fixsz
    { #lr-lv over { #rx-rf over rcmp 2/ 0= } fnd* nip } map* nip ;
: vjoin #vgwhn-v $grp 2>r
    over swap ^mapcols #vv r> $join #vb r> $jext swap #vvb ^maprow #vv ^pair ;

\ join_i returns only matching joins, join0 returns nonmatching rows
: $samec #vv-vvb over $nmvw over $nmvw ^intersect 0 getcol ;
: pjoin #vvn-v >r mksubvw 0 r> 2 pack ^rename over ^count ^repeat ^pair ;
: ^join #vvn-v >r FixV exec $samec
    dup tlen if swap over r> vjoin else drop r> pjoin then ;
: ^join_i #vv-v '_J ^join '_J ^ungroup ;
: ^join0 #vv-v over >r '_J ^join '_J ^norows r> swap ^maprow ;

: ^join_l #vv-v 2dup $samec tuck ^project rrot ^project swap ^except
\ now we have a view with common cols in w and rows which do not appear in v
  over $nmvw over $nmvw ^except 0 getcol #vvvb 2 pick swap ^mapcols ^empty
\ v w common-not-in-v empty, now extend w with the extra row and finally join_i
  ^product over ^names ^mapcols ^concat ^join_i ;

# <AGGR> ----------------------------------------- aggregates and callbacks ---

: vfun-valid #x-f nil? 0= b2i ;
: vfun-count #v-n vsget ^count ;
: vfun-upper #s-s dup tlen nbuf b2p swap
    { c@ dup 96 > over 122 <= and if 32 - then over c! 1+ } rep* end2p ;
: vfun-lower #s-s dup tlen nbuf b2p swap
    { c@ dup 64 > over 90 <= and if 32 + then over c! 1+ } rep* end2p ;

: vsgetc #c-c dup vsget rbox ;
: vfun-sum #c-n vsgetc o( fixsz 0 swap { Wo ^at + } rep* )o ;
: vfun-avg #c-n vsgetc dup ^count ?if >r vfun-sum r> div else drop 0 then ;
: vfun-min #c-n vsgetc dup ^count if o( 0 box Wo ^at Wo fixsz
    { Wo ^at 2dup < if drop else nip then } rep* )o else drop Wn then ;
: vfun-max #c-n vsgetc dup ^count if o( 0 box Wo ^at Wo fixsz
    { Wo ^at 2dup > if drop else nip then } rep* )o else drop Wn then ;

# <TAGS> -------------------------------------- view tags and introspection ---

: $immv? #v-vf dup tdat 0 b@ 1 b@ str? ;
: ^arity #v-n $immv? if drop 0 else tlen 1 b@ then ;
: ^args #v-b 0 over ^arity v,@ ;

# recursive pretty-print representation of a view's entire structure
#  - descends into view operators and shows column info
#  - will in fact work for any type of input, not just views
#  - uses some str/vec operators defined at the top of this file
#  - Wo has frame with prefix vec in 0..19, tadr=outstr, tlen=level, tdat=func

: pemit #s- Wo tadr swap scat Wo tadr! ;
: plaux #b- dup { '\n\s\s pemit  Wo "" sjoin pemit  '+- pemit
		   2dup 1+ = if '\s\s else "| " then Wo dup tlen b!
		   Wo ++  Wo tdat exec  Wo -- } rep* drop ;
: mlist #e- dup 0 ^at pemit ":" pemit dup 1 ^at dup typ2s pemit
    V' typ= if dup 2 ^at 2 ^at plaux then drop ;
: plist #e- @
    dup nil? if 'nil pemit else
      dup int? if 'int pemit else
        dup str? if dup pemit else
	  Wo tlen Wo tmax >= if 'etc pemit else
	    dup ref? 0= if 'vec pemit else
	      dup dup ^arity if dup ^type pemit dup ^arity box else
		'view pemit ^info lit mlist Wo tdat!
	      then plaux lit plist Wo tdat!
    then then then then then drop ;
: ^describe #v-s
    " -" 20 nvec o( tadr! lit plist Wo tdat! 1pck b2p plist Wo )o tadr ;

# <V3SAVE> ------------------- new save code, will eventually replace ^save ---

# Svbuf is a past-the-end pointer with saved-up bytes to emit
variable Svbuf

: sfit #pn-p begin 2dup + dup tcnt >= while swap grow swap repeat drop ;
: emiC #c- Svbuf 1 sfit tuck c! 1+ to Svbuf ;
: emiN #n- dup 0< if 0 emiC not then 0 begin 7 + 2dup >> 0= until
       begin 7 - 2dup >> 127 and over 0= 128 * + emiC dup 0= until 2drop ;
: emiS #s- Svbuf over tlen sfit swap scopy to Svbuf ;

variable Femitv #forward

: emstr #s- dup tlen emiN emiS ;
: emvec #v- dup emiN { @ Femitv ljmp } rep* ;
: emsub #v- 0 svout emiN emiN ;

: emitv #v- 
    dup nil? if 0 emiC else
      dup int? if 1 emiC dup emiN else
        dup str? if 2 emiC dup emstr else
	  dup ref? 0= if dup p2end 3 emiC emvec else
	    dup ^arity 0= if 4 emiC dup ^meta emsub dup emsub else
	      5 emiC dup ^type emstr dup dup ^arity box emvec
    then then then then then drop ;
lit emitv to Femitv

: ^save2 #vd-i to Outf 0 to Ebeg epos to Ebeg
    bigend if 'LJ else 'JL then emit 0x1a em1b 0x40 em1b
    ' b2p to Svbuf
    emitv
    epos >r Svbuf end2p emit r> epos over - 
    0x40000000 + em4be em4be
    epos ;

\ meta views have to be row-wise views for now, convert after loading them
\ hardcoded: 3 cols, last of type V
: rowify3 #v-v o( ^count 3 * nvec Wo fixsz
    { swap over 0 ^at vpush over 1 ^at vpush swap 2 ^at rowify3 vpush } rep*
    Wo ^meta Wo ^count mkrowview )o ;

variable Fv3get #forward
: getN #-i Smk c@ 0= neg mkv xor ;
: getS #-s mkv Smk over nsha swap +to Smk ;
: getB #-b mkv { drop Fv3get ljmp } map* ;
: getV #-v mkv drop mkv Smk >r mseek Dict0 loadv rowify3 b2p r> to Smk 
	    mkv drop mkv Smk >r mseek loadv r> to Smk ;
: getO #-v getS >r getB lit @ rep* Wv '^ r> scat find b@ exec ;
: v3get #-x { Wn getN getS getB getV getO } mkb b@ exec ;
lit v3get to Fv3get

# special pseudo view operator to restore mutated views on load
: ^mut #vxxv-v 2>r >r vsmut r> over 1 b! r> over 2 b! r> over 3 b! ;

: v3load #s-x 
    { #r-x dup Wo @ box to Smk colfix dup Wo ! over box exec nip } custg
    p2end 4 - to Smk mk4be mseek v3get ;
: v3open #s-x xmmf exec dup str? if v3load else drop Wn -1000 box then ;

# <CONVERT> ---------------------------------------------- view conversions ---

: ^freeze #v-v dup ^type 'col s= 0= if dup ^info fixsz { #vc-v
      over { over ^at } map* swap 1 ^at V' typ= if { @ ^freeze } map* then
    } map* over ^meta rot ^count mkcolview then ;

# vim: set ft=thrill :
