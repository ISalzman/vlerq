info {
  package   ratcl
  version   1.0
  title	    {Relational Algebra for Tcl}
  keywords  {ratcl thrive thrill vlerq {relational algebra} tcl metakit}
  website   http://www.vlerq.org/
}

preamble {
  require Tcl 8.4
  require ratcl
}

desc {
  The [b ratcl] package implements a relational algebra package for Tcl.
  It can be used for in-memory data manipulation as well as for persistent
  data stored in files compatible with the Metakit embedded database library.
}

cmd ::ratcl::vdef names... data {
  Create a [q view] with the specified column names and data content.
  The last argument contains the [var data] as a list, all items of row 0,
  followed by all items of row 1, and so on.

  The [var names] entries can each optionally be followed by a type specifier.
  Only a few types are supported for now:

  [taglist {
    name:B {arbitrary data bytes}
    name:I {an integer value}
    name:S {a UTF-8 string, this is the default type}
    name:V {a subview (there are several restrictions with this for now)}
    {{name {...}}} {a subview with the specified set of columns/types,
			  the corresponding data item must be a list}
  }]

  The type specifier can also be a lowercase letter, which means that
  the field is [q nullable]: an empty string will be stored as null,
  i.e. a missing value.  This works for all data types, including strings.
  Null entries are stored in an extremely compact form, require a bit more 
  processing, and are distinct from every normal value - despite the fact that
  the Tcl binding returns them as an empty string.
  Whether an item is null can be tested with the [q valid] functions,
  see the [b EXPRESSIONS] section below.

  The number of items in [var data] must be an exact multiple of the
  number of [var names].
  In the case that no [var names] are specified, the argument may also be
  a non-negative integer.
  This defines a content-less view with that many rows and no columns.
  With no arguments at all, a view with no rows and no columns is returned.

  Return an opaque reference which can be used in the [b view] command.
}

cmd ::ratcl::vfun name type tclfun ... {
  Define a function [var name] which can be called from inside Ratcl
  expressions and conditions (see the [b extend] and [b where] commands below).
  Whenever [q name(...)] is used in Ratcl,
  the [var tclfun] Tcl proc (plus any other arguments) will be
  called to do the work, with all the parameters given in the Ratcl expression
  appended.

  The [var type] specifies the type of the function return value.
  It must be one of: I, S, V - for ints, strings, or views
  respectively.
}

cmd ::ratcl::vget v ?row1 ?col1 ... {
  This is the workhorse for extracting data from a view [var v] to Tcl.
  It returns the specified row and column,
  descending into subviews if more row/column specifiers are given.
  It's also used to obtain the row count.

  The last row/column specification may have additional special formats:

  [taglist {
    #     {- return the row count}
    *     {- return all rows as lists (i.e. a list of lists)}
    {* *} {- return all values in row-wise order}
    {r *} {- return all values for row [var r]}
    {* c} {- return all values for column [var c]}
  }]

  If no arguments are specified, all data is returned as in the [q {* *}] case.

  When neither row nor column is [q *], then a single value is returned
  else the result is a list.

  Columns can be specified by name or by position.
  A negative row or column number is taken as indexing from the end.
}

cmd ::ratcl::vopen ?type arg {
  Load a view from a file, a channel, or a string and return it.

  The [var type] argument determines which mode is used:

  [taglist {
    -data {[var arg] is a string produced by the [b save] operator, see below}
    -file {[var arg] is the name of the file to open (as on-demand loaded memory map)}
    -from {[var arg] is a Tcl channel which will be read until EOF}
  }]

  When [var type] is omitted, it defaults to [q -file].
}

cmd ::ratcl::view v op ?... ?|... {
  This is the interface to all view operators.
  The [var v] argument specifies which view to use,
  while [var op] is one of a range of possible operators to apply.
  Some operators take further arguments.

  If the result is a view, then further operators can be applied to it
  by adding a pipe symbol ([q |]) followed by that next operator as 
  well as any arguments it needs.
  This sequence can be repeated as often as needed.
  The result of the last operator is returned.

  Each of the operators will now be described, but note that they must
  all either start with [q [b view] [var v]] when used in Tcl, or
  follow a [q |] pipe symbol when part of an operator sequence.
  The descriptions below use [var (v)] as placeholder for either case.
}

obj (v) append w {
  Append the rows in view [var w] to [var v].
  Shorthand for [q [var (v)] insert \[get [var v] #\] [var w]].
  This is a state-modifying operation.
}
obj (v) as cmd {
  Create an alias named [var cmd], which can be used as shorthand for
  the [q [var view {$v}]] prefix.

  This is also useful in cases where view references risk shimmering
  and getting lost (i.e. Tcl traces and Tk bindings).
  The resulting command has global scope like any alias,
  and will continue to exist until explicitly deleted in Tcl.
}
obj (v) blocked {
  Return a view which handles Metakit's [q blocked] views
  ([var v] must have a single subview column called [q _B]).
}
obj (v) clone {
  Return a view with the same structure as [var v] but no rows.
}
obj (v) commit filename {
  This is an [i experimental] operator for now,
  which uses the [b Mk4tcl] extension to apply changes made by
  [b append], [b delete], [b insert], [b replace], and [b set].

  The [var filename] must be the same as given to [b vopen].
  After commit, all views loaded from file become [i invalid].

  See also [b mk4name], which has te be used for all the views
  which could be changed and will be committed.
}
obj (v) concat w {
  Return a view with all rows from [var v] followed by all rows from
  [var w].
  Both views must have the same structure.
}
obj (v) counts col {
  Return a list with the counts of each subview in column [var col] of
  view [var v].
  The returned list has as many values as there are rows in [var v].
}
obj (v) delete start count {
  Delete [var count] rows from [var start].
  This is a state-modifying operation.
}
obj (v) describe {
  Return a string which describes the internal structure of view [var v].
  When passed to puts, this will display as a nested tree representation.
}
obj (v) divide w {
  Relational division operator.
}
obj (v) do cmds {
  This is a convenience operator which allows writing long pipelines
  of commands using newlines instead.
  It takes a single [var cmds] argument,
  ignores all lines starting with a "#",
  replaces all newlines with the "|" symbol,
  and then evaluates the result.
}
obj (v) dump ?maxrows {
  Convert a view to a table-like textual representation,
  which can be shown using [b puts].
  Return only the first [var maxrows], the default is 20.
  The result is a string with no trailing newline.
}
obj (v) each aname body {
  Iterate over all rows, setting the Tcl array [var aname] to that row before
  evaluating [var body] as a Tcl script.
  There is one array item for each column in [var v].
  There is also an array item [q #] containing the current row index
  and an item [q ^] which is set to [var v].
  The access mechanism is based on Tcl traces.
}
obj (v) except w {
  Set difference, omit all rows from [var v] which are also in [var w].
  Both views must have the same structure.
}
obj (v) extend name1 expr1 ?... {
  Return a view by adding one or more new columns [var name],
  which are calculated from their respective [var expr].
  The expression syntax is described below.
}
obj (v) first count {
  Return a view containing the first [var count] rows of [var v].
}
obj (v) freeze {
  Make sure a view consists of actual data.
  This will construct a copy if the input view was not in column-wise
  format or if the input view is based on other view operators.
  Subviews are also frozen recursively.
  Return either a new view or the original if it already had the right shape.
}
obj (v) get ?... {
  Shorthand for [q [b ::ratcl::vget] [var v] ...].
  This operator version is more convenient in a pipeline.
}
obj (v) group cols... gcol {
  Return a view grouped by [var cols],
  adding a new subview column called [var gcol] at the end
  to hold all remaining columns.
}
obj (v) html {
  Convert a view to a fancy HTML table.
  Return that HTML snippet.
}
obj (v) info ?type {
  Obtain information about [var v].
  Possible values for [var type] are:

  [taglist {
    arity {return the number of operands or zero if not a view operator}
    args  {return the operands of this view operator}
    names {return a list of all the column names}
    tag   {return the name of this view structure or operation}
    types {return a list of all the column types}
    width {return the number of columns}
  }]

  If omitted, a tagged list with all the above is returned.
}
obj (v) insert start w {
  Insert the rows in view [var w] into [var v], at position [var start].
  Both views must have the same structure.
  This is a state-modifying operation.
}
obj (v) intersect w {
  Set intersection, return only rows from [var v] which are also in
  [var w].
  Both views must have the same structure.
}
obj (v) join w jcol {
  Perform a natural join on [var v] and [var w],
  adding a new subview column called [var jcol] to hold the join groups.
  If [var v] and [var w] have no columns in common,
  this becomes a cross product.
}
obj (v) join_i w {
  Inner join.
  Shorthand for [q [var (v)] join [var w] _J_ | ungroup _J_].
}
obj (v) join_l w ?vals... {
  Left outer join.
  Unlike [b join_i],
  this does not drop rows from [var v] if there are no matching rows 
  in [var w], but fills in the missing values.
  If [var vals...] is present (one value per non-join column in [var w]),
  these will be used instead.
}
obj (v) last count {
  Return a view containing the last [var count] rows of [var v].
}
obj (v) mapcols ?-omit cols... {
  Return a view with the columns specified in [var cols].
  If the [var -omit] option is present,
  then map all but the specified [var cols] instead.

  Unlike [b project], duplicate rows will not be removed.
  Columns can be specified by name or by position,
  negative values are end-relative.
}
obj (v) maprow map {
  Return a view with row numbers specified in the [var map] list.
  The map may be any sequence of valid row numbers,
  and may therefore be a subset and/or contain duplicates.
}
obj (v) mk4name name {
  Return the view found as top-level view in a database opened from file.

  This is like doing [q [var (v)] get 0 [var name]],
  but it sets up some additional information to allow changes
  to be written back using [b commit].
}
obj (v) pair w {
  Return a view with all items from view [var w] tacked onto the end of
  each row, if [var w] has less rows, it is repeated as often as needed,
  if it has more, then the remaining rows are ignored.
  The columns in [var w] must all be different from the ones in [var v].
}
obj (v) pass {
  Return [var v], this is essentially the identity operation.
  Used only in very special cases (e.g. to "seal off" mutable views),
  and as baseline for timing comparisons.
}
obj (v) pick flags {
  The [var flags] argument is a list of integer values.
  Return ony those rows in [var v] for which the corresponding
  entry in [var flags] is not zero.
}
obj (v) product w {
  Return the cartesian product of [var v] with [var w],
  i.e. rows with all possible combinations
  with the rows on [var w] varying most rapidly.
}
obj (v) project ?-omit cols... {
  Relational projection.
  If the [var -omit] option is present,
  then project all but the specified [var cols] instead.
  This uses [b mapcols] and [b unique].
}
obj (v) rename old1 new1 ?... {
  Rename one or more columns.
  The original column can be specified either by name or by position,
  negative values are end-relative.
}
obj (v) repeat count {
  Return a view with [var count] copies of [var v], end to end.
  See also [b spread].
}
obj (v) replace start w {
  Replace rows in [var v] by the rows in view [var w],
  from position [var start].
  Both views must have the same structure.
  This is a state-modifying operation.
}
obj (v) reverse {
  Reverse the rows in a view.
  Shorthand for [q [var (v)] take -\[get [var v] #\]].
}
obj (v) save ?-to ?arg {
  Save a view and all its subviews to string, file, or channel.

  Without arguments, save as binary string and return it.
  This requires either the [q TclVFS] or the [q Memchan] package.

  With one argument, [var arg] is taken as the name of
  the file to save to.  Existing file contents will be overwritten.
  Return the number of bytes written.

  With the [q -to] option, use [var arg] as the channel to save to.
  The channel will be left in binary mode, no seeks will be performed.
  Return the number of bytes written.
}
obj (v) set row ?col1 ?val1 ... {
  Change one or more values in the specified [var row],
  where [var col1] can be specified by name or by position,
  and [var val1] must be of the correct type for that column.
  This is a state-modifying operation.
}
obj (v) slice start count step {
  Return a view with [var count] rows taken from [var v],
  starting at row position [var start], and advancing to successive rows
  by [var step].
  The step may also be zero or negative.
}
obj (v) sort ?cols... {
  Return a view sorted on the specified [var cols] in lexicographic order.
  If no columns are specified, sort on all columns.
  Sorting is stable, so multiple sorts can be combined from last to first
  and [b reverse] can be used to switch to descending order.
}
obj (v) spread count {
  Return a view with each row copied [var count] times.
  See also [b repeat].
}
obj (v) tag tcol {
  Add a new column called [var tcol], containing the integer row number.
}
obj (v) take n {
  Return a view with [var n] rows [q taken] from [var v],
  start from the end if [var n] is negative.
  Wrap around if more rows are requested than the size of the view.
  If [var v] is empty, then so is the result.
}
obj (v) ungroup col {
  Return a view where a [var col] of subviews is expanded ([q flattened]),
  this is the inverse of [b group].
  The main view columns and the columns in subview [var col] must all have
  different names,
  [var col] itself is omitted from the result.
}
obj (v) union w {
  Set union, return all rows of [var v] followed by all rows in [var w]
  which were not already in [var v].
  Both views must have the same structure.
}
obj (v) unique ?cols... {
  Return a view, omitting duplicate rows.
  If [var cols] are specified, then consider only those columns
  to establish uniqueness of rows and keep the first such row.
}
obj (v) where condition {
  Return a view with only rows matching [var condition].
}

section Expressions {
  The [b extend] and [b where] operators take
  an expression as argument, which must be protected by braces in Tcl.
  In the case of [q where],
  a non-zero result and a non-empty string and a non-empty subview
  are all considered as [q true] condition.

  Expressions are parsed according to the usual algebraic conventions, allowing
  all the common arithmetic and comparison operators, as well as Tcl's [q &&],
  [q ||], and such.
  The syntax has been made as much like Tcl's [b expr] command as possible,
  including the precedence of +, -, *, /, and the other operators.
  Strings must be enclosed in double quotes.

  Unlike Tcl's [q expr], identifiers are treated as [i column names], not
  strings or variables.

  Simple Tcl variables and fixed array elements can be inserted as
  [q \$foo] and [q \$foo(bar)], respectively.
  These references are expanded at the time of definition.
  The default is to treat these variable references as strings.
  To handle expansion as integers or views,
  append [b :I] or [b :V], respectively.

  A small number of functions are defined: [q count], [q sum],
  [q min], [q max], [q avg], and [q valid] (which returns 1 if its
  argument is not null).
  Additional functions can be defined in Tcl using the [b vfun] command.
  Functions are called as [q name(...)], with comma-separated arguments.
}

section State {
  The [b append], [b delete], [b insert], [b replace], and [b set] operators
  alter the state of a view.
  This means that all changes made will carry over to the next
  operations and remain visible.

  This is done without actually modifying the original views.
  It's all smoke and mirrors, using a "mutable view layer" which tracks all
  changes and presents views as if they were copies with all changes applied.
  The reason for this approach will become clear in future versions of Ratcl.
}
  
examples {
  Here is an interactive [q tclsh] session which sets up a view
  with some data and print it out:
} {
  % package require ratcl
  1.0
  % namespace import ratcl::*
  % set V [vdef A B C:I {one un 1 twenty vingt 20}]
  ^1
  % view $V dump
    A       B      C
    ------  -----  --
    one     un      1
    twenty  vingt  20
  % view $V get
  one un 1 twenty vingt 20
  % view $V get 1 *
  twenty vingt 20
  % view $V get * 1
  un vingt
  %
} {
  Inspect various view properties:
} {
  % view $V get #
  2
  % view $V info width
  3
  % view $V info names
  A B C
  % view $V info types
  S S I
  %
} {
  Some view operations:
} {
  % view $V sort B | dump
    A       B      C
    ------  -----  --
    twenty  vingt  20
    one     un      1
  % view $V project C A | dump
    C   A
    --  ------
     1  one
    20  twenty
  % view $V take -1 | dump
    A       B      C
    ------  -----  --
    twenty  vingt  20
  %
} {
  Combine multiple operations into a sequence:
} {
  % view $V sort B | project C A | dump
    C   A
    --  ------
    20  twenty
     1  one
  %
} {
  The same, using an alternate notation:
} {
  % view $V do {
      # this does the same as the previous example
      sort B
      project C A
      dump
    }
    C   A
    --  ------
    20  twenty
     1  one
  %
} {
  Add a calculated column, based on a Tcl variable:
} {
  % set n 10
  10
  % view $V extend D:I { $n:I + 20 * C } | dump
    A       B      C   D
    ------  -----  --  ---
    one     un      1   30
    twenty  vingt  20  410
  %
} {
  Execute Tcl commands via callbacks:
} {
  % vfun len I string length
  % vfun upper S string toupper
  % view $V extend D:I { len(A) * C } E { upper(B) } | dump
    A       B      C   D    E
    ------  -----  --  ---  -----
    one     un      1    3  UN
    twenty  vingt  20  120  VINGT
  %
} {
  Extract results into a Tcl array:
} {
  % array set a [view $V project C A | get]
  % parray a
  a(1)  = one
  a(20) = twenty
  %
} {
  Release the view, it will be freed once all references
  are gone from Tcl and Ratcl.
} {
  % unset V
  %
}
