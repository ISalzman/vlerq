: vnew dup nvec tuck tlen! ;
: vdup dup { over swap b@ } map* nip ;
: v@ duo 0< if over tlen + then
 over tlen over > over 0< or if 2drop Wn exit then b@ ;
: v,@ >r box r> { drop dup 1+ swap @ } map* nip ;
: v..@ over - v,@ ;
: vfirst 0 v@ ;
: vlast -1 v@ ;
: vfull? dup tlen swap tmax >= ;
: vpop dup tlen if dup b2o -- dup dup tlen b@ else Wn then ;
: vatend >r dup vfull? if grow then r> over dup tlen b! ;
: vpush vatend dup b2o ++ ;
: vrot dup b2p @ over b2o dup -- { dup 1+ @ swap ! } rep* vpush ;
: vdel box 1+ dup tlen over - over 1- swap vcpy b2i swap tlen! ;
: vshift dup tlen if vrot then vpop ;
: vunshift vpush vrev vrot vrev ;
: scopy { c@ over c! 1+ } rep* ;
: srep swap o( tlen over * nbuf b2p swap { drop Wo scopy } rep* end2p )o ;
: scat over tlen over tlen + nbuf b2p rot scopy swap scopy end2p ;
: sjoin over tlen if o( drop
 0 over { @ tlen + } rep* over tlen 1- Wo tlen * + 
 nbuf b2p swap { dup if swap Wo scopy swap then @ scopy } rep* end2p
 )o else 2drop "" then ;
: csplit over { c@ over = } sel* nip over tlen vpush
 swap o( drop 0 swap { @ Wo rot box 2dup - nsha >r 1+ r> } map* )o nip ;
: vfill over { 2dup ! drop } rep* drop ;
: v,fill o( drop >r box r> { over swap + Wo swap ! } rep* b2o )o ;
: v..fill >r over - r> v,fill ;
: u< 2dup xor 0< if swap drop else - then 0< ;
: u> swap u< ;
: max 2dup < if swap then drop ;
: min 2dup > if swap then drop ;
: within over - rrot - u> ;
variable Ticks
0 to Ticks
: elapsed usec Ticks - .p " uSec" .p usec to Ticks ;
: words 0 Ws Wv box { @ .p sp } rep* nl ;
: cycle usec 249 begin 1- dup 0= until drop usec swap - ;
: ./. swap .p "/" .p .p ;
: pos/tot dup b2i swap tmax ./. ;
: stats sp
 Wc pos/tot " codes, " .p
 Wv pos/tot " syms, " .p
 Ww b2i var0 - dsp0 3 - var0 - ./. " vars, " .p
 Wu Wh ./. " gc, " .p
 cycle .p " nS/op\n" .p
;
: info sp
 highbit .p " highbit, " .p 
 bits/int .p " bits/int, " .p 
 bytes/box .p " bytes/box, " .p 
 var0 .p " var0, " .p 
 dsp0 .p " dsp0 \n" .p
;
: va1 Wo 0 b@ ; : va2 Wo 1 b@ ; : va3 Wo 2 b@ ; : va4 Wo 3 b@ ;
: vt1 Wo 5 b@ ; : vt2 Wo 4 b@ ; : vt3 Wo 3 b@ ;
: vt1! Wo 5 b! ; : vt2! Wo 4 b! ; : vt3! Wo 3 b! ;
: va2! Wo 1 b! ; : va3! Wo 2 b! ; : va4! Wo 3 b! ;
: va1! Wo 0 b! ; : va2! Wo 1 b! ; : va3! Wo 2 b! ;
variable Mnone variable Mmap variable Mint variable Mstr
 0 1 ( ) mktopmeta to Mnone
 0 1 ( 'M 'I typ2i -1 ) mktopmeta to Mmap
 0 0 ( 'I 'I typ2i -1 ) mktopmeta to Mint
 0 0 ( 'S 'S typ2i -1 ) mktopmeta to Mstr
: mkcount ( ) Mnone rot mkrowview ;
: mkmapvw Mmap over tlen mkrowview ;
: mkintvw 1pck Mint 1 mkrowview ;
: mkstrvw 1pck Mstr 1 mkrowview ;
: mksubvw 
 dup 1pck swap 'V 'V typ2i rot ^meta 3 pack 0 0 rot mktopmeta 1 mkrowview ;
: $vfix Wo tlen dup 4 b@ Wo 8 b! dup 5 b@ Wo 9 b! 3 b@ ljmp ;
: $padn 1 b@ - { drop Wn } rep* 
 { $vfix Wo 8 b@ exec } { $vfix Wo 9 b@ ljmp } 10 pack ;
: $Fun 2>r 8 r@ $padn Wn 2r> exec o( Wo tlen 2 b@ exec Wo ttag! )o ;
: ^Fun lit mkfunview $Fun ;
: $Mut lit mkmutview $Fun ;
: ^Late >r 8 r@ $padn Wn 
 { { vt1 0 b@ } ,nip { vt1 1 b@ } ,nip { vt1 2 b@ ljmp } ,nip
 { vt1 3 b@ exec vt2! } ,nip
 { vt2 ^count } ,nip
 { vt2 Wo box swap ^at } ,nip
 } mkfunview r> swap o( swap vt1! Wo tlen 2 b@ exec Wo ttag! )o ;
: mknewmeta 0 1 rot getall mktopmeta ;
: samemeta va1 ^info mknewmeta ;
: hnew 2>r 0 ( ( ) ( ) ) 0 1
 'k r> typ2i Wn 'v r> typ2i Wn 6 pack mktopmeta rot mkcolview ;
: $hsetk vatend va1! va1 tlen int? if va1 p2end hshm then va1 p2end ;
: hpos o( drop va1 swap $hsetk 0 hshf Wo rbox )o ;
: hfnd hpos dup 0>= if dup 1 b@ swap b@ else drop Wn then ;
: hset rot o( drop va1 rot $hsetk 1 hshf dup 0>=
 if va2 rbox ! else drop Wo b2o ++ va1 b2o ++ va2 swap vpush va2! then )o ;
: hdel hpos dup 0>= if dup 0 b@ over vdel 
 dup 0 b@ dup tlen b2i swap tlen!
 dup 1 b@ over vdel b2o -- else drop then ;
: $vpar1 >r getcol Wo r> b! ;
: vparini 100 nvec o( 12 b! xpar rbox Wo 15 b! Wo 14 b! mkopen
 0 box dup 0 ^at dup 0 5 $vpar1 dup 1 6 $vpar1 2 7 $vpar1
 dup 1 ^at 0 10 $vpar1
 dup 2 ^at 0 13 $vpar1
 3 ^at dup 0 8 $vpar1 1 9 $vpar1
 Wo mao Wo b2o )o ;
: parser over 0 b! 0 over 1 b! 0 over 2 b! 0 over 3 b! 0 over 4 b!
 Wn over 19 b! 20 over tlen! 
 begin dup dup dup 15 b@ exec dup b2i xpar exec until
 dup tlen 1- b@ b2o ;
variable Gview
variable Fgen1 
: gunaop va2 Fgen1 ljmp ;
: gbinop gunaop va3 Fgen1 ljmp ;
: gcmpop gbinop lit cmp , lit b2i ;
: gensym 
 lit Wo , va2 dup str? if Gview ^info ncoli else , lit ncol then , lit ^at
 Wo tlen 2 > if , va3 , lit ncol , lit box then ;
: gdofun swap '::thrill::funget rrot 3 pack 'S heval ;
: genfun va3 { dup 1 and if @ Fgen1 exec else drop then } rep*
 'vfun- va2 scat dup def? if find Wv rbox @ else
 drop va3 tlen 2/ , lit pack , va2 , lit gdofun then ;
: gen1 o( vec? if
 { gensym 
 { '::thrill::varget va2 2 pack 'S heval } ,nip
 { gbinop lit or } ,nip
 { gbinop lit and } ,nip
 #= { gcmpop lit 0= , } ,nip
 #< { gcmpop lit 0< , } ,nip
 #> { gcmpop lit 0> , } ,nip
 #<= { gcmpop lit 0<= , } ,nip
 #>= { gcmpop lit 0>= , } ,nip
 #<> { gcmpop lit 0<> , } ,nip
 #+ { gbinop lit + } ,nip
 { gbinop lit - } ,nip
 { gbinop lit * } ,nip
 { gbinop lit div } ,nip
 #0= { gunaop 0= } ,nip
 { gunaop neg } ,nip
 'bind? 
 genfun 
 'arg? 
 } va1 b@ exec
 else Wv Wo dup 0 box c@ #" 34 = if dup -- then find b@ then
 , )o ;
lit gen1 to Fgen1
: genc parser over to Gview Wt Wc rot gen1 (cb)
 rrot fixsz { o( drop dup exec )o } rot if map* else sel* then nip ;
variable Xpo
: setxpar xpar rbox Xpo 5 b! ;
: xparser 6 nvec tuck 0 b! to Xpo 3 setxpar ;
: xtoken Xpo dup 5 b@ exec
 dup 1 = if 4 setxpar then dup 4 = if 3 setxpar then ;
: xmloop xparser
 begin xtoken dup 257 < if { ' '< '= '/ '> } over b@ Wn else
 { 'D 'T '? 'C '! 'Q 'I } over 257 - b@ over b2o then
 '::thrill::xmlfun rrot 3 pack 'n heval drop 0= until ;
: xmltok xtoken dup 257 < if { ' '< '= '/ '> } swap b@ Wn
 else { 'D 'T '? 'C '! 'Q 'I } over 257 - b@ swap b2o then ;
: xmltoken xmltok 2 pack ;
: xmltokens 100 nvec 50 { drop xmltok >r vpush r> vpush } rep* ;
'xbit def? constant hasXbit
: b.count xbit exec b2i ;
: b.nth1 xbit 1 box exec b2i ;
: b.topbit xbit 2 box exec ;
: b.pack xbit 3 box exec ;
: b.unpack1 xbit 4 box exec ;
: b.lohi xbit 5 box exec b2i swap b2i swap ;
: b.convi xbit 6 box exec ;
: .b 8 { over swap 7 xor >> 1 and .p } rep* drop ;
: dumpb dup tcnt box { c@ sp .b } rep* ;
: bruns swap 1 over tadr!
 dup >r 0 box c@ 128 and if 0 else r@ b.unpack1 then
 begin r@ b.unpack1 dup while 2 pick exec + r@ b.unpack1 + repeat
 r> 2drop 2drop
;
: sprec dup 0< if not b.topbit 2+ neg else b.topbit 1+ then ;
: $bwpos '01233444555555556666666666666666 rbox c@ 7 and ;
: $bwneg '04444444455555555666666666666666 rbox c@ 7 and ;
: $width b.lohi 0 max sprec $bwpos swap 0 min sprec neg $bwneg max ;
: bwidth dup tlen 8 < 4 * swap $width dup if max else nip then ;
: bcount p2end dup 7 + 8 div box b.count ;
: b? sp dup b2i 'b?\soff ?? dup tlen b2i 'len ?? dup tcnt b2i 'cnt ?? ;
variable Tmap
variable Tsome
{ #Wo=v dup Wo tlen! { drop lit Wn } map* to Tmap swap b2p to Tsome
 { 2dup { drop Tsome over Tmap rbox ! 1+ 1 +to Tsome } rep* drop } bruns 
 Tmap 
} to Ffixn
variable FixV lit noop to FixV
variable Evec
variable Outf
variable Esub
variable Ebeg
: addv Evec swap vpush to Evec ;
: addp dup addv if addv else drop then ;
: epos Outf 0 1 fseek Ebeg - ;
: emit Outf swap fwrite drop ;
: em1b '? tuck b2p c! emit ;
: em1v dup 0< if 0 em1b not then 0 begin 7 + 2dup >> 0= until
 begin 7 - 2dup >> 127 and over 0= 128 * + em1b dup 0= until 2drop ;
: em4be dup 24 >> em1b dup 16 >> em1b dup 8 >> em1b em1b ;
: v2i lit @ maq* ;
: $v2is v2i dup bwidth b.convi dup tcnt over tlen! ;
: $emi1 epos >r emit r> epos over - addp ;
: enil dup { @ nil? 0= } bit*
 dup b.pack dup tcnt over tlen! $emi1 dup tlen addv dup dup tlen!
 dup tlen xop0 3 box exec b2o { i@ over rbox @ } map* nip ;
: $eint $v2is $emi1 ;
: $estr >r epos 2>r dup r> rep* r> epos over - tuck addp
 if r> map* $v2is $emi1 else r> 2drop then 0 addv ;
: $edmp 0 em1v dup 0 b@ ?if dup tlen em1v emit then
 dup 1 b@ dup em1v if 2 b@ { @ em1v } rep* else drop then ;
: $esub { @ FixV exec 0 Esub ljmp } map*
 epos >r { @ $edmp } rep* r> epos over - addp ;
: $ecol 2dup getcol swap 1 ^at dup typn? if swap enil swap then
 dup I' typ= if drop $eint else dup V' typ= if drop $esub else
 S' typ= if { @ emit 0 em1b } { @ tlen 1+ } else { @ emit } { @ tlen } then
 $estr then then ;
: $capp over c! 1+ ;
: $sapp { c@ $capp } rep* ;
: $mapp { o( if ,' $capp then Wo 0 ^at $sapp
 Wo 1 ^at V' typ= if [' $capp Wo 2 ^at 2 ^at $mapp ]' $capp 
 else :' $capp Wo 1 ^at typ2s $sapp then )o } rep* ;
: m2dsc 1000 nbuf b2p swap $mapp dup b2i over tlen! b2o ;
{ 
 Evec 2>r dup ^info 0 nvec to Evec fixsz lit $ecol rep*
 r> if dup ^info m2dsc else 0 then swap ^count Evec 3 pack r> to Evec 
} to Esub
: $ehdr bigend if 'LJ else 'JL then emit 0x1a em1b 0 em1b 0 em4be ;
: $emrk 0x80000000 em4be epos 4 - em4be 0x80000000 + em4be em4be ;
: svout Esub exec epos >r $edmp r> epos over - ;
: ^save to Outf 0 to Ebeg epos to Ebeg b2o $ehdr 1 svout $emrk epos ;
: ^pass 
 { 'pass 1 { va1 ^meta } ,nip
 noop
 { va1 ^count } ,nip
 { va1 Wo box swap ^at } ,nip
 } ^Fun ;
: ^clone 
 { 'pass 1 { va1 ^meta } ,nip
 noop
 0
 noop
 } ^Fun ;
: ^iota 
 { 'iota 2 { 0 0 ( va2 'I typ2i -1 ) mktopmeta } ,nip
 noop
 { va1 } ,nip
 { drop Wo b2i } ,nip
 } ^Fun ;
: ^repeat 
 { 'repeat 2 samemeta
 { va1 ^count vt1! } ,nip
 { vt1 va2 * } ,nip
 { va1 Wo vt1 mod box swap ^at } ,nip
 } ^Fun ;
: ^spread 
 { 'spread 2 samemeta
 noop
 { va1 ^count va2 * } ,nip
 { va1 Wo va2 div box swap ^at } ,nip
 } ^Fun ;
: error Wn ttag! Wn b2o ;
: colscheck #vv-vv1|e0 over ^names over ^names over tlen over tlen = if
 { dup @ >r over rbox @ r> cmp 0= } cnt* swap tlen = else 2drop 0 then
 if 1 else 2drop "not same columns" error 0 then ;
 
: ^concat 
 colscheck if FixV exec
 { 'concat 2 samemeta
 { va1 ^count vt1! } ,nip
 { vt1 va2 ^count + } ,nip
 { Wo vt1 < if va1 Wo else va2 Wo vt1 - then box swap ^at } ,nip
 } ^Fun then ;
: pairmeta va1 ^info va2 ^info ^concat mknewmeta ;
: ^pair FixV exec
 { 'pair 2 pairmeta
 { va1 ^info vt1! } ,nip
 { va1 ^count } ,nip
 { dup vt1 < if va1 else vt1 - va2 then Wo box swap ^at } ,nip
 } ^Fun ;
: ^tag over ^count swap ^iota ^pair ;
: ^product FixV exec
 { 'product 2 pairmeta
 { va1 va2 ^count ^spread va2 va1 ^count ^repeat ^pair } ,nip
 } ^Late ;
: ^maprow 
 { 'maprow 2 samemeta
 noop
 { va2 tlen } ,nip
 { va1 va2 Wo b@ box swap ^at } ,nip
 } ^Fun ;
: cdense { @ 0<> } sel* ;
: colomits dup tlen 1 = if drop ( ) else
 dup 1 b@ over 0 b! over ncols over ^width { drop 1 } map*
 swap { @ over rbox 0 swap ! } rep* cdense then ;
: ^mapcols 
 dup tlen if dup b2p @ '-omit s= if colomits then then
 dup tlen if
 { 'mapcols 2 { va1 ^info va2 va1 ncols ^maprow mknewmeta } ,nip
 { va2 va1 ncols vt1! } ,nip
 { va1 ^count } ,nip
 { vt1 swap b@ va1 Wo box swap ^at } ,nip
 } ^Fun else drop then ;
: ^slice 
 { 'slice 4 samemeta
 noop
 { va3 } ,nip
 { va1 Wo va4 * va2 + box swap ^at } ,nip
 } ^Fun ;
: ^reverse 
 { 'reverse 1 samemeta
 { va1 dup ^count 1- dup 1+ -1 ^slice } ,nip
 } ^Late ;
: ^first 
 { 'first 2 samemeta
 { va1 0 va1 ^count va2 min 1 ^slice } ,nip
 } ^Late ;
: ^last 
 { 'last 2 samemeta
 { va1 va2 over ^count over - dup 0< if + 0 then swap 1 ^slice } ,nip
 } ^Late ;
: ^empty 
 { 'empty 1 samemeta
 noop
 { 1 } ,nip
 { drop Wn } ,nip
 } ^Fun ;
: ^take dup >r abs over ^count 2dup > if
 dup >r over + 1- r> div rot swap ^repeat swap 
 else drop then r> 0< if ^last ^reverse else ^first then ;
: ^delete 
 { 'delete 3 samemeta
 { va1 va2 ^first va1 dup ^count va2 - va3 - ^last ^concat } ,nip
 } ^Late ;
: ^omitcol 
 { 'omitcol 2 { va1 ^info va2 1 ^delete mknewmeta } ,nip
 noop
 { va1 ^count } ,nip
 { va1 Wo box swap dup va2 >= + ^at } ,nip
 } ^Fun ;
: ^blocked 
 { 'blocked 1 { va1 ^info b2p 2 ^at } ,nip
 noop
 { va1 fixsz 0 swap { 0 ^at ^count + } rep* } ,nip
 { Wo va1 b2p 
 begin 2dup 0 ^at ^count - dup 0> while swap 1+ >r box 1- r> repeat
 #vrn 0= if box va1 fixsz 1- then 0 ^at rbox swap ^at } ,nip
 } ^Fun ;
variable Fcmp
: $sort 2dup 2dup over - 2/ + @ >r
 begin
 swap begin dup @ r@ Fcmp exec while 1+ repeat
 swap begin r@ over @ Fcmp exec while 1- repeat
 2dup <= if 2dup 2dup @ swap @ rot ! swap ! swap 1+ swap 1- then
 2dup >
 until r> drop 
 tuck over - >r rot dup 3 pick - r> < if 2swap then
 2dup < if $sort else 2drop then
 2dup < if $sort else 2drop then ;
: fsort to Fcmp b2p over dup tlen 1- box $sort ;
: rcmp@ >r over r@ ^at over r> ^at cmp ;
: rcmp dup ^info lit rcmp@ fnd* 
 over ^info ^count over = if drop - sgn else rcmp@ 2* nip nip then ;
: sortmap o( ^count lit noop map* dup tlen if dup
 { Wo rot box Wo rot box rcmp 0< } fsort then )o ;
: ^sort 
 dup tlen if over swap ^mapcols else drop dup then sortmap ^maprow ;
: vdelta fixsz
 { dup 0= if 0= else dup 1- rcmp 2/ 0<> then b2i } map* ;
: pinv b2o dup tlen dup nvec tuck tlen! swap
 { dup >r b2i over r> @ box ! } rep* ;
: invmap { @ over swap b@ } map* nip ;
: notz { @ 0= } map* ;
: $umap 
 >r dup sortmap 2dup ^maprow vdelta swap pinv invmap r> exec cdense nip ;
: $uori over swap $umap ^maprow ;
: $unique lit noop $uori ;
: ^uniqmap lit noop $umap ;
: Xunique drop lit noop $uori ;
: ^unique 
 dup tlen if 2dup ^mapcols ^uniqmap nip ^maprow else drop $unique then ;
: ^union colscheck if ^concat $unique then ;
: ^project ^mapcols $unique ;
: ^intersect colscheck if FixV exec swap ^concat lit notz $uori then ;
: $clrp b2p begin 1+ dup dup tlen < while
 dup @ over 1- dup @ rot and swap ! repeat b2o ;
: ^except colscheck if over >r ^concat dup sortmap tuck ^maprow vdelta
 $clrp swap pinv invmap r@ ^count over tlen! cdense r> swap ^maprow then ;
: ^pick cdense ^maprow ;
: bsplit dup tlen 2/ { 2* 1+ over rbox @ } map*
 >r dup tlen 2/ { 2* over rbox @ } map* nip r> ;
: $rname { 2dup b@ swap @ 3 * 3 pick swap b! } rep* drop ;
: ^rename bsplit
 { 'rename 3 { 0 1 va1 ^info getall va3 va2 va1 ncols $rname mktopmeta } ,nip
 noop
 { va1 ^count } ,nip
 { va1 Wo box swap ^at } ,nip
 } ^Fun ;
: $insvw 0x7fffffff and va4 rbox ;
: $mutf 0 0 0
 { 'mut? 4 samemeta
 { va1 ^count dup lit noop map* va2!
 va1 ^width * { drop Wn } map* va3!
 ( ) va1 ^meta 0 mkrowview va4! } ,nip
 { va2 tlen } ,nip
 { va2 Wo b@ dup 0< if $insvw swap ^at else
 va1 rbox swap 2dup va1 ^count * + va3 rbox @ 
 dup nil? if drop ^at else nip nip then then } ,nip
 } $Mut dup ^count drop ;
lit $mutf to MutF
: rowset rot dup ^width * rot + ! ;
: ^Set rot dup ^Mut o( drop va2 rbox @ dup 0<
 if $insvw rrot rowset else rot va1 ^count * + va3 rbox ! then Wo )o ;
: ^vset 2>r box r> ncol r> ^Set ;
: chg-s #swap over @ over @ 3 pick ! over ! 2drop ;
: chg-x #exchange 2/ { drop chg-s 1+ swap 1+ swap } rep* ;
: chg-f #flip
 o( 2/ { 2dup 2dup - Wo + 1- rrot + chg-s drop } rep* )o drop ;
: chg-r #relocate 2over 2over nip + chg-f
 2over 2over rrot + >r + r> chg-f 2over 2over + nip chg-f 2drop 2drop ;
: ^Chg 3 pick ^Mut o( drop
 >r va2 rbox 2>r va2 rbox 2r> r>
 2 pick over =
 if drop swap chg-x else 3 pick rot - abs 2 pick - chg-r then Wo )o ;
: rowcat dup >r ^count over ^count + tuck over ^width * vnew b2p
 swap b2p swap over tmax vcpy r> getall b2p tuck tlen vcpy nip 
 b2o swap ^meta rot mkrowview ;
: ^Ins colscheck if FixV exec over ^Mut o( drop va2 tlen over ^count + 
 { dup va2 tlen <
 if va2 rbox @ else va2 tlen - va4 ^count + 0x7fffffff not or then
 } map* va2! va4 over rowcat va4!
 >r va2 rbox dup tlen over - r> ^count swap over - 0 rrot chg-r Wo )o then ;
: ^insert >r box r> ^Ins ;
: ^append >r dup ^count box r> ^Ins ;
: ^Del dup >r over ^count 0 ^Chg r>
 swap o( va2 tlen rot - va2 tlen! )o ;
: ^delete >r box r> ^Del ;
: ^replace >r tuck box r@ ^count ^Del rbox r> ^Ins ;
variable Vstate
'V 'V hnew to Vstate
: vsget dup b2o Vstate hfnd dup nil? if swap then nip ;
: vsmut dup b2o Vstate hfnd dup nil? if drop 
 Vstate swap b2o dup $mutf dup >r hset r> else nip then ;
lit vsget to FixV lit vsmut to MutF 
: ctypes over ^info o( drop { @ ncol Wo rbox 1 ^at } map* nip )o ;
variable Vpaths
'V 'S hnew to Vpaths
: vpdef vsmut swap Vpaths rrot hset ;
: vpath Vpaths hfnd ;
: ^gsubvw 
 { 'gsubvw 4 { 0 0 ( va4 'V typ2i va1 ^meta ) mktopmeta } ,nip
 noop
 { va2 tlen } ,nip
 { drop va3 Wo b@ dup 0= if drop
 va1 va2 Wo box dup @ swap 1+ @ over - 1 ^slice
 dup va3 Wo b! then Wo box } ,nip
 } ^Fun ;
: allbut dup nvec tuck tlen! >r p2end
 begin 1- dup 0>= while 1 over @ r@ swap b! repeat drop r> notz cdense ;
: $vgex swap b2p dup tlen 1+ nvec tuck b2p over tlen vcpy 2drop
 dup tmax 1- over 2dup tlen! >r b! r> ;
: $grp 2>r dup r@ ^mapcols dup sortmap tuck ^maprow >r ^maprow r>
 dup vdelta cdense 2 pick ^count $vgex tuck ^maprow rot
 r> over ncols over ^info allbut ^mapcols rot dup tlen nvec r> ^gsubvw ;
: ^group over tlen
 if $grp ^pair else >r drop mksubvw 0 r> 2 pack ^rename then ;
: ^counts ncol swap fixsz { over ^at vsget ^count } map* nip ;
: ^norows ncol swap fixsz { over ^at vsget ^count 0= } sel* nip ;
: $nmvw ^info ( 0 ) ^mapcols ;
: $div swap fixsz
 { 0 ^at vsget over ^intersect ^count over ^count = } map* nip ;
: ^divide FixV exec
 >r dup $nmvw r@ $nmvw ^except 0 getcol '_D $grp r> $div ^pick ;
: ispread dup nvec tuck tlen! b2p swap 0 o( drop
 { @ dup 0> if >r Wo over ! 1+ r> 1- { neg 1- over ! 1+ } rep*
 else drop then 1 +to Wo } rep* )o b2o ;
: $nsmap 0 over { @ + } rep* ispread ;
: ^nspread 
 { 'nspread 2 samemeta
 { va2 $nsmap vt1! } ,nip
 { vt1 tlen } ,nip
 { va1 vt1 Wo box dup @ dup 0< * + @ box swap ^at } ,nip
 } ^Fun ;
: ^subcat 
 { 'subcat 2
 { va1 va2 ncol swap ^info rbox 2 ^at } ,nip
 { va1 va2 ncol dup vt2! ^counts $nsmap vt1! } ,nip
 { vt1 tlen } ,nip
 { va1 vt1 Wo box @ dup 0< if 
 dup >r Wo + vt1 rbox @ box r> neg
 else box 0 then >r vt2 ^at vsget r> box swap ^at } ,nip
 } ^Fun ;
: ^ungroup 
 ncol 2dup 2>r ^counts r@ swap ^nspread r> r@ ^subcat ^pair r> ^omitcol ;
: $jsub ( ) swap 0 mkrowview ;
: $jext dup ^info b2p 2 ^at $jsub 1pck over ^meta 1 mkrowview ^concat ;
: $join fixsz swap fixsz
 { over { over rcmp 2/ 0= } fnd* nip } map* nip ;
: vjoin $grp 2>r
 over swap ^mapcols r> $join r> $jext swap ^maprow ^pair ;
: $samec over $nmvw over $nmvw ^intersect 0 getcol ;
: pjoin >r mksubvw 0 r> 2 pack ^rename over ^count ^repeat ^pair ;
: ^join >r FixV exec $samec
 dup tlen if swap over r> vjoin else drop r> pjoin then ;
: ^join_i '_J ^join '_J ^ungroup ;
: ^join0 over >r '_J ^join '_J ^norows r> swap ^maprow ;
: ^join_l 2dup $samec tuck ^project rrot ^project swap ^except
 over $nmvw over $nmvw ^except 0 getcol 2 pick swap ^mapcols ^empty
 ^product over ^names ^mapcols ^concat ^join_i ;
: vfun-valid nil? 0= b2i ;
: vfun-count vsget ^count ;
: vfun-upper dup tlen nbuf b2p swap
 { c@ dup 96 > over 122 <= and if 32 - then over c! 1+ } rep* end2p ;
: vfun-lower dup tlen nbuf b2p swap
 { c@ dup 64 > over 90 <= and if 32 + then over c! 1+ } rep* end2p ;
: vsgetc dup vsget rbox ;
: vfun-sum vsgetc o( fixsz 0 swap { Wo ^at + } rep* )o ;
: vfun-avg vsgetc dup ^count ?if >r vfun-sum r> div else drop 0 then ;
: vfun-min vsgetc dup ^count if o( 0 box Wo ^at Wo fixsz
 { Wo ^at 2dup < if drop else nip then } rep* )o else drop Wn then ;
: vfun-max vsgetc dup ^count if o( 0 box Wo ^at Wo fixsz
 { Wo ^at 2dup > if drop else nip then } rep* )o else drop Wn then ;
: $immv? dup tdat 0 b@ 1 b@ str? ;
: ^arity $immv? if drop 0 else tlen 1 b@ then ;
: ^args 0 over ^arity v,@ ;
: pemit Wo tadr swap scat Wo tadr! ;
: plaux dup { '\n\s\s pemit Wo "" sjoin pemit '+- pemit
 2dup 1+ = if '\s\s else "| " then Wo dup tlen b!
 Wo ++ Wo tdat exec Wo -- } rep* drop ;
: mlist dup 0 ^at pemit ":" pemit dup 1 ^at dup typ2s pemit
 V' typ= if dup 2 ^at 2 ^at plaux then drop ;
: plist @
 dup nil? if 'nil pemit else
 dup int? if 'int pemit else
 dup str? if dup pemit else
 Wo tlen Wo tmax >= if 'etc pemit else
 dup ref? 0= if 'vec pemit else
 dup dup ^arity if dup ^type pemit dup ^arity box else
 'view pemit ^info lit mlist Wo tdat!
 then plaux lit plist Wo tdat!
 then then then then then drop ;
: ^describe 
 " -" 20 nvec o( tadr! lit plist Wo tdat! 1pck b2p plist Wo )o tadr ;
variable Svbuf
: sfit begin 2dup + dup tcnt >= while swap grow swap repeat drop ;
: emiC Svbuf 1 sfit tuck c! 1+ to Svbuf ;
: emiN dup 0< if 0 emiC not then 0 begin 7 + 2dup >> 0= until
 begin 7 - 2dup >> 127 and over 0= 128 * + emiC dup 0= until 2drop ;
: emiS Svbuf over tlen sfit swap scopy to Svbuf ;
variable Femitv 
: emstr dup tlen emiN emiS ;
: emvec dup emiN { @ Femitv ljmp } rep* ;
: emsub 0 svout emiN emiN ;
: emitv 
 dup nil? if 0 emiC else
 dup int? if 1 emiC dup emiN else
 dup str? if 2 emiC dup emstr else
 dup ref? 0= if dup p2end 3 emiC emvec else
 dup ^arity 0= if 4 emiC dup ^meta emsub dup emsub else
 5 emiC dup ^type emstr dup dup ^arity box emvec
 then then then then then drop ;
lit emitv to Femitv
: ^save2 to Outf 0 to Ebeg epos to Ebeg
 bigend if 'LJ else 'JL then emit 0x1a em1b 0x40 em1b
 ' b2p to Svbuf
 emitv
 epos >r Svbuf end2p emit r> epos over - 
 0x40000000 + em4be em4be
 epos ;
: rowify3 o( ^count 3 * nvec Wo fixsz
 { swap over 0 ^at vpush over 1 ^at vpush swap 2 ^at rowify3 vpush } rep*
 Wo ^meta Wo ^count mkrowview )o ;
variable Fv3get 
: getN Smk c@ 0= neg mkv xor ;
: getS mkv Smk over nsha swap +to Smk ;
: getB mkv { drop Fv3get ljmp } map* ;
: getV mkv drop mkv Smk >r mseek Dict0 loadv rowify3 b2p r> to Smk 
 mkv drop mkv Smk >r mseek loadv r> to Smk ;
: getO getS >r getB lit @ rep* Wv '^ r> scat find b@ exec ;
: v3get { Wn getN getS getB getV getO } mkb b@ exec ;
lit v3get to Fv3get
: ^mut 2>r >r vsmut r> over 1 b! r> over 2 b! r> over 3 b! ;
: v3load 
 { dup Wo @ box to Smk colfix dup Wo ! over box exec nip } custg
 p2end 4 - to Smk mk4be mseek v3get ;
: v3open xmmf exec dup str? if v3load else drop Wn -1000 box then ;
: ^freeze dup ^type 'col s= 0= if dup ^info fixsz { 
 over { over ^at } map* swap 1 ^at V' typ= if { @ ^freeze } map* then
 } map* over ^meta rot ^count mkcolview then ;
