
<html>
<!-- generated with Tcl's xmlgen-1.4 xmlgen] -->

 <head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8"></meta>
  <title>Ratcl 1.0</title>
  <style type="text/css"><!-- var {color:#44a} pre {background-color:#eef} -->
  </style>
 </head>
 <body>
  <h3>NAME</h3>
  <blockquote>
   <p><b>Ratcl - Relational Algebra for Tcl</b></p>
  </blockquote>
  <h3>SYNOPSIS</h3>
  <blockquote>
   <p>
    <tt>package require <b>Tcl</b> 8.4</tt><br />
    <tt>package require <b>ratcl</b> 1.0</tt><br />
   </p>
   <tt><b>::ratcl::vdef</b> <var>names...</var> <var>data</var></tt><br />
   <tt><b>::ratcl::vfun</b> <var>name</var> <var>type</var> <var>tclfun</var> ...</tt><br />
   <tt><b>::ratcl::vget</b> <var>v</var> ?<var>row1</var>? ?<var>col1</var>? ...</tt><br />
   <tt><b>::ratcl::vopen</b> ?<var>type</var>? <var>arg</var></tt><br />
   <tt><b>::ratcl::view</b> <var>v</var> <var>op</var> ?<var>...</var>? ?<var>|...</var>?</tt><br />
   <tt><var>(v)</var> <b>append</b> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>as</b> <var>cmd</var></tt><br />
   <tt><var>(v)</var> <b>blocked</b></tt><br />
   <tt><var>(v)</var> <b>clone</b></tt><br />
   <tt><var>(v)</var> <b>commit</b> <var>filename</var></tt><br />
   <tt><var>(v)</var> <b>concat</b> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>counts</b> <var>col</var></tt><br />
   <tt><var>(v)</var> <b>delete</b> <var>start</var> <var>count</var></tt><br />
   <tt><var>(v)</var> <b>describe</b></tt><br />
   <tt><var>(v)</var> <b>divide</b> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>do</b> <var>cmds</var></tt><br />
   <tt><var>(v)</var> <b>dump</b> ?<var>maxrows</var>?</tt><br />
   <tt><var>(v)</var> <b>each</b> <var>aname</var> <var>body</var></tt><br />
   <tt><var>(v)</var> <b>except</b> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>extend</b> <var>name1</var> <var>expr1</var> ?<var>...</var>?</tt><br />
   <tt><var>(v)</var> <b>first</b> <var>count</var></tt><br />
   <tt><var>(v)</var> <b>freeze</b></tt><br />
   <tt><var>(v)</var> <b>get</b> ?<var>...</var>?</tt><br />
   <tt><var>(v)</var> <b>group</b> <var>cols...</var> <var>gcol</var></tt><br />
   <tt><var>(v)</var> <b>html</b></tt><br />
   <tt><var>(v)</var> <b>info</b> ?<var>type</var>?</tt><br />
   <tt><var>(v)</var> <b>insert</b> <var>start</var> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>intersect</b> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>join</b> <var>w</var> <var>jcol</var></tt><br />
   <tt><var>(v)</var> <b>join_i</b> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>join_l</b> <var>w</var> ?<var>vals...</var>?</tt><br />
   <tt><var>(v)</var> <b>last</b> <var>count</var></tt><br />
   <tt><var>(v)</var> <b>mapcols</b> ?<var>-omit</var>? <var>cols...</var></tt><br />
   <tt><var>(v)</var> <b>maprow</b> <var>map</var></tt><br />
   <tt><var>(v)</var> <b>mk4name</b> <var>name</var></tt><br />
   <tt><var>(v)</var> <b>pair</b> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>pass</b></tt><br />
   <tt><var>(v)</var> <b>pick</b> <var>flags</var></tt><br />
   <tt><var>(v)</var> <b>product</b> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>project</b> ?<var>-omit</var>? <var>cols...</var></tt><br />
   <tt><var>(v)</var> <b>rename</b> <var>old1</var> <var>new1</var> ?<var>...</var>?</tt><br />
   <tt><var>(v)</var> <b>repeat</b> <var>count</var></tt><br />
   <tt><var>(v)</var> <b>replace</b> <var>start</var> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>reverse</b></tt><br />
   <tt><var>(v)</var> <b>save</b> ?<var>-to</var>? ?<var>arg</var>?</tt><br />
   <tt><var>(v)</var> <b>set</b> <var>row</var> ?<var>col1</var>? ?<var>val1</var>? ...</tt><br />
   <tt><var>(v)</var> <b>slice</b> <var>start</var> <var>count</var> <var>step</var></tt><br />
   <tt><var>(v)</var> <b>sort</b> ?<var>cols...</var>?</tt><br />
   <tt><var>(v)</var> <b>spread</b> <var>count</var></tt><br />
   <tt><var>(v)</var> <b>tag</b> <var>tcol</var></tt><br />
   <tt><var>(v)</var> <b>take</b> <var>n</var></tt><br />
   <tt><var>(v)</var> <b>ungroup</b> <var>col</var></tt><br />
   <tt><var>(v)</var> <b>union</b> <var>w</var></tt><br />
   <tt><var>(v)</var> <b>unique</b> ?<var>cols...</var>?</tt><br />
   <tt><var>(v)</var> <b>where</b> <var>condition</var></tt><br />
  </blockquote>
  <h3>DESCRIPTION</h3>
  <blockquote>
   <p>The <b>ratcl</b> package implements a relational algebra package for Tcl.
  It can be used for in-memory data manipulation as well as for persistent
  data stored in files compatible with the Metakit embedded database library.
   </p>
   <dl>
    <dt>
     <tt><b>::ratcl::vdef</b> <var>names...</var> <var>data</var></tt>
    </dt>
    <dd>
     <p>Create a <q>view</q> with the specified column names and data content.
  The last argument contains the <var>data</var> as a list, all items of row 0,
  followed by all items of row 1, and so on.
     </p>
     <p>The <var>names</var> entries can each optionally be followed by a type specifier.
  Only a few types are supported for now:
     </p>
     <p>
     <blockquote>
      <table cellspacing="0">
       <tr>
        <td valign="top" nowrap=""><b>name:B</b></td>
        <td>&nbsp;</td>
        <td>arbitrary data bytes
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>name:I</b></td>
        <td>&nbsp;</td>
        <td>an integer value
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>name:S</b></td>
        <td>&nbsp;</td>
        <td>a UTF-8 string, this is the default type
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>name:V</b></td>
        <td>&nbsp;</td>
        <td>a subview (there are several restrictions with this for now)
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>{name {...}}</b></td>
        <td>&nbsp;</td>
        <td>a subview with the specified set of columns/types,
			  the corresponding data item must be a list
        </td>
       </tr>
      </table>
     </blockquote>
     </p>
     <p>The type specifier can also be a lowercase letter, which means that
  the field is <q>nullable</q>: an empty string will be stored as null,
  i.e. a missing value.  This works for all data types, including strings.
  Null entries are stored in an extremely compact form, require a bit more 
  processing, and are distinct from every normal value - despite the fact that
  the Tcl binding returns them as an empty string.
  Whether an item is null can be tested with the <q>valid</q> functions,
  see the <b>EXPRESSIONS</b> section below.
     </p>
     <p>The number of items in <var>data</var> must be an exact multiple of the
  number of <var>names</var>.
  In the case that no <var>names</var> are specified, the argument may also be
  a non-negative integer.
  This defines a content-less view with that many rows and no columns.
  With no arguments at all, a view with no rows and no columns is returned.
     </p>
     <p>Return an opaque reference which can be used in the <b>view</b> command.
     </p>
    </dd>
    <dt>
     <tt><b>::ratcl::vfun</b> <var>name</var> <var>type</var> <var>tclfun</var> ...</tt>
    </dt>
    <dd>
     <p>Define a function <var>name</var> which can be called from inside Ratcl
  expressions and conditions (see the <b>extend</b> and <b>where</b> commands below).
  Whenever <q>name(...)</q> is used in Ratcl,
  the <var>tclfun</var> Tcl proc (plus any other arguments) will be
  called to do the work, with all the parameters given in the Ratcl expression
  appended.
     </p>
     <p>The <var>type</var> specifies the type of the function return value.
  It must be one of: I, S, V - for ints, strings, or views
  respectively.
     </p>
    </dd>
    <dt>
     <tt><b>::ratcl::vget</b> <var>v</var> ?<var>row1</var>? ?<var>col1</var>? ...</tt>
    </dt>
    <dd>
     <p>This is the workhorse for extracting data from a view <var>v</var> to Tcl.
  It returns the specified row and column,
  descending into subviews if more row/column specifiers are given.
  It's also used to obtain the row count.
     </p>
     <p>The last row/column specification may have additional special formats:
     </p>
     <p>
     <blockquote>
      <table cellspacing="0">
       <tr>
        <td valign="top" nowrap=""><b>#</b></td>
        <td>&nbsp;</td>
        <td>- return the row count
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>*</b></td>
        <td>&nbsp;</td>
        <td>- return all rows as lists (i.e. a list of lists)
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>* *</b></td>
        <td>&nbsp;</td>
        <td>- return all values in row-wise order
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>r *</b></td>
        <td>&nbsp;</td>
        <td>- return all values for row <var>r</var>
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>* c</b></td>
        <td>&nbsp;</td>
        <td>- return all values for column <var>c</var>
        </td>
       </tr>
      </table>
     </blockquote>
     </p>
     <p>If no arguments are specified, all data is returned as in the <q>* *</q> case.
     </p>
     <p>When neither row nor column is <q>*</q>, then a single value is returned
  else the result is a list.
     </p>
     <p>Columns can be specified by name or by position.
  A negative row or column number is taken as indexing from the end.
     </p>
    </dd>
    <dt>
     <tt><b>::ratcl::vopen</b> ?<var>type</var>? <var>arg</var></tt>
    </dt>
    <dd>
     <p>Load a view from a file, a channel, or a string and return it.
     </p>
     <p>The <var>type</var> argument determines which mode is used:
     </p>
     <p>
     <blockquote>
      <table cellspacing="0">
       <tr>
        <td valign="top" nowrap=""><b>-data</b></td>
        <td>&nbsp;</td>
        <td><var>arg</var> is a string produced by the <b>save</b> operator, see below
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>-file</b></td>
        <td>&nbsp;</td>
        <td><var>arg</var> is the name of the file to open (as on-demand loaded memory map)
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>-from</b></td>
        <td>&nbsp;</td>
        <td><var>arg</var> is a Tcl channel which will be read until EOF
        </td>
       </tr>
      </table>
     </blockquote>
     </p>
     <p>When <var>type</var> is omitted, it defaults to <q>-file</q>.
     </p>
    </dd>
    <dt>
     <tt><b>::ratcl::view</b> <var>v</var> <var>op</var> ?<var>...</var>? ?<var>|...</var>?</tt>
    </dt>
    <dd>
     <p>This is the interface to all view operators.
  The <var>v</var> argument specifies which view to use,
  while <var>op</var> is one of a range of possible operators to apply.
  Some operators take further arguments.
     </p>
     <p>If the result is a view, then further operators can be applied to it
  by adding a pipe symbol (<q>|</q>) followed by that next operator as 
  well as any arguments it needs.
  This sequence can be repeated as often as needed.
  The result of the last operator is returned.
     </p>
     <p>Each of the operators will now be described, but note that they must
  all either start with <q><b>view</b> <var>v</var></q> when used in Tcl, or
  follow a <q>|</q> pipe symbol when part of an operator sequence.
  The descriptions below use <var>(v)</var> as placeholder for either case.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>append</b> <var>w</var></tt>
    </dt>
    <dd>
     <p>Append the rows in view <var>w</var> to <var>v</var>.
  Shorthand for <q><var>(v)</var> insert [get <var>v</var> #] <var>w</var></q>.
  This is a state-modifying operation.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>as</b> <var>cmd</var></tt>
    </dt>
    <dd>
     <p>Create an alias named <var>cmd</var>, which can be used as shorthand for
  the <q><var>view $v</var></q> prefix.
     </p>
     <p>This is also useful in cases where view references risk shimmering
  and getting lost (i.e. Tcl traces and Tk bindings).
  The resulting command has global scope like any alias,
  and will continue to exist until explicitly deleted in Tcl.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>blocked</b></tt>
    </dt>
    <dd>
     <p>Return a view which handles Metakit's <q>blocked</q> views
  (<var>v</var> must have a single subview column called <q>_B</q>).
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>clone</b></tt>
    </dt>
    <dd>
     <p>Return a view with the same structure as <var>v</var> but no rows.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>commit</b> <var>filename</var></tt>
    </dt>
    <dd>
     <p>This is an <i>experimental</i> operator for now,
  which uses the <b>Mk4tcl</b> extension to apply changes made by
  <b>append</b>, <b>delete</b>, <b>insert</b>, <b>replace</b>, and <b>set</b>.
     </p>
     <p>The <var>filename</var> must be the same as given to <b>vopen</b>.
  After commit, all views loaded from file become <i>invalid</i>.
     </p>
     <p>See also <b>mk4name</b>, which has te be used for all the views
  which could be changed and will be committed.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>concat</b> <var>w</var></tt>
    </dt>
    <dd>
     <p>Return a view with all rows from <var>v</var> followed by all rows from
  <var>w</var>.
  Both views must have the same structure.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>counts</b> <var>col</var></tt>
    </dt>
    <dd>
     <p>Return a list with the counts of each subview in column <var>col</var> of
  view <var>v</var>.
  The returned list has as many values as there are rows in <var>v</var>.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>delete</b> <var>start</var> <var>count</var></tt>
    </dt>
    <dd>
     <p>Delete <var>count</var> rows from <var>start</var>.
  This is a state-modifying operation.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>describe</b></tt>
    </dt>
    <dd>
     <p>Return a string which describes the internal structure of view <var>v</var>.
  When passed to puts, this will display as a nested tree representation.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>divide</b> <var>w</var></tt>
    </dt>
    <dd>
     <p>Relational division operator.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>do</b> <var>cmds</var></tt>
    </dt>
    <dd>
     <p>This is a convenience operator which allows writing long pipelines
  of commands using newlines instead.
  It takes a single <var>cmds</var> argument,
  ignores all lines starting with a "#",
  replaces all newlines with the "|" symbol,
  and then evaluates the result.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>dump</b> ?<var>maxrows</var>?</tt>
    </dt>
    <dd>
     <p>Convert a view to a table-like textual representation,
  which can be shown using <b>puts</b>.
  Return only the first <var>maxrows</var>, the default is 20.
  The result is a string with no trailing newline.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>each</b> <var>aname</var> <var>body</var></tt>
    </dt>
    <dd>
     <p>Iterate over all rows, setting the Tcl array <var>aname</var> to that row before
  evaluating <var>body</var> as a Tcl script.
  There is one array item for each column in <var>v</var>.
  There is also an array item <q>#</q> containing the current row index
  and an item <q>^</q> which is set to <var>v</var>.
  The access mechanism is based on Tcl traces.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>except</b> <var>w</var></tt>
    </dt>
    <dd>
     <p>Set difference, omit all rows from <var>v</var> which are also in <var>w</var>.
  Both views must have the same structure.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>extend</b> <var>name1</var> <var>expr1</var> ?<var>...</var>?</tt>
    </dt>
    <dd>
     <p>Return a view by adding one or more new columns <var>name</var>,
  which are calculated from their respective <var>expr</var>.
  The expression syntax is described below.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>first</b> <var>count</var></tt>
    </dt>
    <dd>
     <p>Return a view containing the first <var>count</var> rows of <var>v</var>.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>freeze</b></tt>
    </dt>
    <dd>
     <p>Make sure a view consists of actual data.
  This will construct a copy if the input view was not in column-wise
  format or if the input view is based on other view operators.
  Subviews are also frozen recursively.
  Return either a new view or the original if it already had the right shape.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>get</b> ?<var>...</var>?</tt>
    </dt>
    <dd>
     <p>Shorthand for <q><b>::ratcl::vget</b> <var>v</var> ...</q>.
  This operator version is more convenient in a pipeline.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>group</b> <var>cols...</var> <var>gcol</var></tt>
    </dt>
    <dd>
     <p>Return a view grouped by <var>cols</var>,
  adding a new subview column called <var>gcol</var> at the end
  to hold all remaining columns.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>html</b></tt>
    </dt>
    <dd>
     <p>Convert a view to a fancy HTML table.
  Return that HTML snippet.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>info</b> ?<var>type</var>?</tt>
    </dt>
    <dd>
     <p>Obtain information about <var>v</var>.
  Possible values for <var>type</var> are:
     </p>
     <p>
     <blockquote>
      <table cellspacing="0">
       <tr>
        <td valign="top" nowrap=""><b>arity</b></td>
        <td>&nbsp;</td>
        <td>return the number of operands or zero if not a view operator
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>args</b></td>
        <td>&nbsp;</td>
        <td>return the operands of this view operator
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>names</b></td>
        <td>&nbsp;</td>
        <td>return a list of all the column names
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>tag</b></td>
        <td>&nbsp;</td>
        <td>return the name of this view structure or operation
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>types</b></td>
        <td>&nbsp;</td>
        <td>return a list of all the column types
        </td>
       </tr>
       <tr>
        <td valign="top" nowrap=""><b>width</b></td>
        <td>&nbsp;</td>
        <td>return the number of columns
        </td>
       </tr>
      </table>
     </blockquote>
     </p>
     <p>If omitted, a tagged list with all the above is returned.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>insert</b> <var>start</var> <var>w</var></tt>
    </dt>
    <dd>
     <p>Insert the rows in view <var>w</var> into <var>v</var>, at position <var>start</var>.
  Both views must have the same structure.
  This is a state-modifying operation.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>intersect</b> <var>w</var></tt>
    </dt>
    <dd>
     <p>Set intersection, return only rows from <var>v</var> which are also in
  <var>w</var>.
  Both views must have the same structure.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>join</b> <var>w</var> <var>jcol</var></tt>
    </dt>
    <dd>
     <p>Perform a natural join on <var>v</var> and <var>w</var>,
  adding a new subview column called <var>jcol</var> to hold the join groups.
  If <var>v</var> and <var>w</var> have no columns in common,
  this becomes a cross product.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>join_i</b> <var>w</var></tt>
    </dt>
    <dd>
     <p>Inner join.
  Shorthand for <q><var>(v)</var> join <var>w</var> _J_ | ungroup _J_</q>.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>join_l</b> <var>w</var> ?<var>vals...</var>?</tt>
    </dt>
    <dd>
     <p>Left outer join.
  Unlike <b>join_i</b>,
  this does not drop rows from <var>v</var> if there are no matching rows 
  in <var>w</var>, but fills in the missing values.
  If <var>vals...</var> is present (one value per non-join column in <var>w</var>),
  these will be used instead.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>last</b> <var>count</var></tt>
    </dt>
    <dd>
     <p>Return a view containing the last <var>count</var> rows of <var>v</var>.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>mapcols</b> ?<var>-omit</var>? <var>cols...</var></tt>
    </dt>
    <dd>
     <p>Return a view with the columns specified in <var>cols</var>.
  If the <var>-omit</var> option is present,
  then map all but the specified <var>cols</var> instead.
     </p>
     <p>Unlike <b>project</b>, duplicate rows will not be removed.
  Columns can be specified by name or by position,
  negative values are end-relative.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>maprow</b> <var>map</var></tt>
    </dt>
    <dd>
     <p>Return a view with row numbers specified in the <var>map</var> list.
  The map may be any sequence of valid row numbers,
  and may therefore be a subset and/or contain duplicates.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>mk4name</b> <var>name</var></tt>
    </dt>
    <dd>
     <p>Return the view found as top-level view in a database opened from file.
     </p>
     <p>This is like doing <q><var>(v)</var> get 0 <var>name</var></q>,
  but it sets up some additional information to allow changes
  to be written back using <b>commit</b>.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>pair</b> <var>w</var></tt>
    </dt>
    <dd>
     <p>Return a view with all items from view <var>w</var> tacked onto the end of
  each row, if <var>w</var> has less rows, it is repeated as often as needed,
  if it has more, then the remaining rows are ignored.
  The columns in <var>w</var> must all be different from the ones in <var>v</var>.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>pass</b></tt>
    </dt>
    <dd>
     <p>Return <var>v</var>, this is essentially the identity operation.
  Used only in very special cases (e.g. to "seal off" mutable views),
  and as baseline for timing comparisons.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>pick</b> <var>flags</var></tt>
    </dt>
    <dd>
     <p>The <var>flags</var> argument is a list of integer values.
  Return ony those rows in <var>v</var> for which the corresponding
  entry in <var>flags</var> is not zero.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>product</b> <var>w</var></tt>
    </dt>
    <dd>
     <p>Return the cartesian product of <var>v</var> with <var>w</var>,
  i.e. rows with all possible combinations
  with the rows on <var>w</var> varying most rapidly.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>project</b> ?<var>-omit</var>? <var>cols...</var></tt>
    </dt>
    <dd>
     <p>Relational projection.
  If the <var>-omit</var> option is present,
  then project all but the specified <var>cols</var> instead.
  This uses <b>mapcols</b> and <b>unique</b>.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>rename</b> <var>old1</var> <var>new1</var> ?<var>...</var>?</tt>
    </dt>
    <dd>
     <p>Rename one or more columns.
  The original column can be specified either by name or by position,
  negative values are end-relative.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>repeat</b> <var>count</var></tt>
    </dt>
    <dd>
     <p>Return a view with <var>count</var> copies of <var>v</var>, end to end.
  See also <b>spread</b>.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>replace</b> <var>start</var> <var>w</var></tt>
    </dt>
    <dd>
     <p>Replace rows in <var>v</var> by the rows in view <var>w</var>,
  from position <var>start</var>.
  Both views must have the same structure.
  This is a state-modifying operation.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>reverse</b></tt>
    </dt>
    <dd>
     <p>Reverse the rows in a view.
  Shorthand for <q><var>(v)</var> take -[get <var>v</var> #]</q>.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>save</b> ?<var>-to</var>? ?<var>arg</var>?</tt>
    </dt>
    <dd>
     <p>Save a view and all its subviews to string, file, or channel.
     </p>
     <p>Without arguments, save as binary string and return it.
  This requires either the <q>TclVFS</q> or the <q>Memchan</q> package.
     </p>
     <p>With one argument, <var>arg</var> is taken as the name of
  the file to save to.  Existing file contents will be overwritten.
  Return the number of bytes written.
     </p>
     <p>With the <q>-to</q> option, use <var>arg</var> as the channel to save to.
  The channel will be left in binary mode, no seeks will be performed.
  Return the number of bytes written.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>set</b> <var>row</var> ?<var>col1</var>? ?<var>val1</var>? ...</tt>
    </dt>
    <dd>
     <p>Change one or more values in the specified <var>row</var>,
  where <var>col1</var> can be specified by name or by position,
  and <var>val1</var> must be of the correct type for that column.
  This is a state-modifying operation.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>slice</b> <var>start</var> <var>count</var> <var>step</var></tt>
    </dt>
    <dd>
     <p>Return a view with <var>count</var> rows taken from <var>v</var>,
  starting at row position <var>start</var>, and advancing to successive rows
  by <var>step</var>.
  The step may also be zero or negative.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>sort</b> ?<var>cols...</var>?</tt>
    </dt>
    <dd>
     <p>Return a view sorted on the specified <var>cols</var> in lexicographic order.
  If no columns are specified, sort on all columns.
  Sorting is stable, so multiple sorts can be combined from last to first
  and <b>reverse</b> can be used to switch to descending order.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>spread</b> <var>count</var></tt>
    </dt>
    <dd>
     <p>Return a view with each row copied <var>count</var> times.
  See also <b>repeat</b>.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>tag</b> <var>tcol</var></tt>
    </dt>
    <dd>
     <p>Add a new column called <var>tcol</var>, containing the integer row number.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>take</b> <var>n</var></tt>
    </dt>
    <dd>
     <p>Return a view with <var>n</var> rows <q>taken</q> from <var>v</var>,
  start from the end if <var>n</var> is negative.
  Wrap around if more rows are requested than the size of the view.
  If <var>v</var> is empty, then so is the result.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>ungroup</b> <var>col</var></tt>
    </dt>
    <dd>
     <p>Return a view where a <var>col</var> of subviews is expanded (<q>flattened</q>),
  this is the inverse of <b>group</b>.
  The main view columns and the columns in subview <var>col</var> must all have
  different names,
  <var>col</var> itself is omitted from the result.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>union</b> <var>w</var></tt>
    </dt>
    <dd>
     <p>Set union, return all rows of <var>v</var> followed by all rows in <var>w</var>
  which were not already in <var>v</var>.
  Both views must have the same structure.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>unique</b> ?<var>cols...</var>?</tt>
    </dt>
    <dd>
     <p>Return a view, omitting duplicate rows.
  If <var>cols</var> are specified, then consider only those columns
  to establish uniqueness of rows and keep the first such row.
     </p>
    </dd>
    <dt>
     <tt><var>(v)</var> <b>where</b> <var>condition</var></tt>
    </dt>
    <dd>
     <p>Return a view with only rows matching <var>condition</var>.
     </p>
    </dd>
   </dl>
  </blockquote>
  <h3>EXPRESSIONS</h3>
  <blockquote>
   <p>The <b>extend</b> and <b>where</b> operators take
  an expression as argument, which must be protected by braces in Tcl.
  In the case of <q>where</q>,
  a non-zero result and a non-empty string and a non-empty subview
  are all considered as <q>true</q> condition.
   </p>
   <p>Expressions are parsed according to the usual algebraic conventions, allowing
  all the common arithmetic and comparison operators, as well as Tcl's <q>&&</q>,
  <q>||</q>, and such.
  The syntax has been made as much like Tcl's <b>expr</b> command as possible,
  including the precedence of +, -, *, /, and the other operators.
  Strings must be enclosed in double quotes.
   </p>
   <p>Unlike Tcl's <q>expr</q>, identifiers are treated as <i>column names</i>, not
  strings or variables.
   </p>
   <p>Simple Tcl variables and fixed array elements can be inserted as
  <q>$foo</q> and <q>$foo(bar)</q>, respectively.
  These references are expanded at the time of definition.
  The default is to treat these variable references as strings.
  To handle expansion as integers or views,
  append <b>:I</b> or <b>:V</b>, respectively.
   </p>
   <p>A small number of functions are defined: <q>count</q>, <q>sum</q>,
  <q>min</q>, <q>max</q>, <q>avg</q>, and <q>valid</q> (which returns 1 if its
  argument is not null).
  Additional functions can be defined in Tcl using the <b>vfun</b> command.
  Functions are called as <q>name(...)</q>, with comma-separated arguments.
   </p>
  </blockquote>
  <h3>STATE</h3>
  <blockquote>
   <p>The <b>append</b>, <b>delete</b>, <b>insert</b>, <b>replace</b>, and <b>set</b> operators
  alter the state of a view.
  This means that all changes made will carry over to the next
  operations and remain visible.
   </p>
   <p>This is done without actually modifying the original views.
  It's all smoke and mirrors, using a "mutable view layer" which tracks all
  changes and presents views as if they were copies with all changes applied.
  The reason for this approach will become clear in future versions of Ratcl.
   </p>
  </blockquote>
  <h3>EXAMPLES</h3>
  <blockquote>
   <p>Here is an interactive <q>tclsh</q> session which sets up a view
  with some data and print it out:
   </p>
   <pre width="81n">&nbsp; % package require ratcl
  1.0
  % namespace import ratcl::*
  % set V [vdef A B C:I {one un 1 twenty vingt 20}&#93;
  ^1
  % view $V dump
    A       B      C
    ------  -----  --
    one     un      1
    twenty  vingt  20
  % view $V get
  one un 1 twenty vingt 20
  % view $V get 1 *
  twenty vingt 20
  % view $V get * 1
  un vingt
  %</pre>
   <p>Inspect various view properties:
   </p>
   <pre width="81n">&nbsp; % view $V get #
  2
  % view $V info width
  3
  % view $V info names
  A B C
  % view $V info types
  S S I
  %</pre>
   <p>Some view operations:
   </p>
   <pre width="81n">&nbsp; % view $V sort B | dump
    A       B      C
    ------  -----  --
    twenty  vingt  20
    one     un      1
  % view $V project C A | dump
    C   A
    --  ------
     1  one
    20  twenty
  % view $V take -1 | dump
    A       B      C
    ------  -----  --
    twenty  vingt  20
  %</pre>
   <p>Combine multiple operations into a sequence:
   </p>
   <pre width="81n">&nbsp; % view $V sort B | project C A | dump
    C   A
    --  ------
    20  twenty
     1  one
  %</pre>
   <p>The same, using an alternate notation:
   </p>
   <pre width="81n">&nbsp; % view $V do {
      # this does the same as the previous example
      sort B
      project C A
      dump
    }
    C   A
    --  ------
    20  twenty
     1  one
  %</pre>
   <p>Add a calculated column, based on a Tcl variable:
   </p>
   <pre width="81n">&nbsp; % set n 10
  10
  % view $V extend D:I { $n:I + 20 * C } | dump
    A       B      C   D
    ------  -----  --  ---
    one     un      1   30
    twenty  vingt  20  410
  %</pre>
   <p>Execute Tcl commands via callbacks:
   </p>
   <pre width="81n">&nbsp; % vfun len I string length
  % vfun upper S string toupper
  % view $V extend D:I { len(A) * C } E { upper(B) } | dump
    A       B      C   D    E
    ------  -----  --  ---  -----
    one     un      1    3  UN
    twenty  vingt  20  120  VINGT
  %</pre>
   <p>Extract results into a Tcl array:
   </p>
   <pre width="81n">&nbsp; % array set a [view $V project C A | get&#93;
  % parray a
  a(1)  = one
  a(20) = twenty
  %</pre>
   <p>Release the view, it will be freed once all references
  are gone from Tcl and Ratcl.
   </p>
   <pre width="81n">&nbsp; % unset V
  %</pre>
  </blockquote>
  <h3>WEBSITE</h3>
  <blockquote>
   <p>See <a href="http://www.vlerq.org/">http://www.vlerq.org/</a>.</p>
  </blockquote>
  <h3>KEYWORDS</h3>
  <blockquote>
   <p>ratcl, thrive, thrill, vlerq, relational algebra, tcl, metakit</p>
  </blockquote>
 </body>
</html>