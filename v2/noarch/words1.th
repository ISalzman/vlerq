0 exit
exec -1 syst 
immed 1 Wi Wl b!
noop exit
]] -1 (to) Wt exit
: 2 (to) Wt 0 syst ]] exit
, Wc ! 1 +to Wc exit
; (lit) exit , 0 (to) Wt exit
[[ immed
: eval 'exit 'S 1 syst 'S 1 syst 0 syst [[ Gj -3 box , ]] ;
: (tok) 0 syst ;
: heval 1 syst ;
: quit 2 syst ;
: .p 3 syst ;
: readf 4 syst ;
: usec 5 syst ;
: getenv 6 syst ;
: fseek 7 syst ;
: fread 8 syst ;
: fwrite 9 syst ;
: constant (tok) ! ;
: variable Ww (tok) ! 1 +to Ww ;
: ? dup .p ;
: sp " " .p ;
: nl "\n" .p ;
: branch! tuck - 1- swap dup @ rot box swap ! ;
: jmp, Wc Gj , ;
: cnd, Wc Gc , ;
: tst, Wc Gt , ;
: ?if tst, ; immed
: if cnd, ; immed
: then Wc swap branch! ; immed
: else jmp, Wc rot branch! ; immed
: begin Wc ; immed
: while cnd, swap ; immed
: again jmp, branch! ; immed
: until cnd, branch! ; immed
: repeat jmp, branch! Wc swap branch! ; immed
: token Wc -1 (to) Wt (tok) 0 (to) Wt dup (to) Wc @ ;
: to Wt if (lit) (to) , else token work ! then ; immed
: lit Wt if (lit) (lit) , else token then ; immed
xini
: @xfor Wc 1- xfor over @ box swap ! ; immed
: $beg* dup 0< if dup tlen else dup b2o swap then dup ;
: $end* 2r> 2r> drop rrot drop >r ;
: rep* >r $beg* drop 2>r 0 @xfor $end* drop ;
: fnd* >r $beg* drop 2>r 1 @xfor r> b2i 2r> 2drop ;
: cnt* >r $beg* b2p nvec rbox 2>r 2 @xfor $end* tlen ;
: bit* >r $beg* 7 + 3 >> nbuf rbox 2>r 3 @xfor $end* ;
: sel* >r $beg* nvec rbox 2>r 4 @xfor $end* b2o ;
: seq* >r $beg* 2 << nbuf rbox 2>r 5 @xfor $end* b2o ;
: map* >r $beg* nvec rbox 2>r 6 @xfor $end* b2o ;
: maq* >r $beg* 2 << nbuf rbox 2>r 7 @xfor $end* b2o ;
: tfin! -5 b! ;
: ttag! -4 b! ;
: tadr! -3 b! ;
: tdat! -2 b! ;
: tlen! -1 b! ;
: { Wt -1 to Wt Wc ; immed
: (cb) lit exit , Wc over - over to Wc dup nvec over 1- over tlen! dup >r
 b2p swap vcpy 2drop to Wt r> Ge over setg b2p Wt if lit lit , , then ; 
: } (cb) ; immed
: vrev dup tlen swap { not over + @ } map* nip ;
: pack lit drop map* vrev ;
: ( Wt if { r> Wd 2>r } , else Wd >r begin (tok) again then ; immed
: ) Wt if { 2r> swap >r Wd swap - pack } , else 2r> 2drop Wd r> - pack then ;
 immed
{ 1 1 begin dup 2* while 2* swap 1+ swap repeat } exec
 constant highbit constant bits/int
1 nvec tcnt b2i constant bytes/box
 Ww b2i constant var0
 Wd b2i constant dsp0
: depth Wd dsp0 - b2i ;
: tmax tcnt b2i bytes/box div ;
: nil? Wn p= ;
: ?? .p ': .p .p sp ;
: s? Wd 'Wd ?? ;
: p2end dup tlen box ;
: end2p dup b2i over tlen! b2o ;
: sgn dup 0> if 0> else 0< neg then ;
: 1pck 1 pack ;
: mao Gi swap setg ;
: ,nip -1 +to Wc Wc @ Wc 1- ! ; immed
: custg over tadr! Gu over setg ;
: ref? tget Gi tget = ;
: bye 0 quit ;
: ?dup dup ?if then ;
: dip swap >r exec r> ;
: def? find Wv < b2i ;
: cdef b2p c@ constant ;
 'B cdef B' 'I cdef I' 'S cdef S' 'V cdef V'
 '[ cdef [' '] cdef ]' ', cdef ,' ': cdef :'
: ^meta ttag ;
: ^ownr tadr ;
: ^type dup tdat 0 b@ ljmp ;
: ^count dup tdat 1 b@ ljmp ;
: ^at over tdat 2 b@ ljmp ;
: ^Mut dup tdat 3 b@ ljmp ;
: ^info ^meta 2 ^at ;
: ncoli { 0 ^at over s= } fnd* nip ;
: ncol dup str? if over ^info ncoli else
 dup 0< if over ^info + then then ;
: ncols swap p2end { @ ncol } map* nip ;
: getcell >r box r> ncol ^at ;
: fixsz dup ^count box ;
variable MutF
: mkcommon 
 2>r over ttag! r> over tlen! Wn over tadr! r> b2p over tdat! dup mao ;
: mkrowview 
 { { drop 'row } ,nip
 { tlen b2i } ,nip
 { >r dup tmax over tlen div over * box r> + @ } ,nip
 { MutF ljmp } ,nip
 } mkcommon fixsz ;
: mkcolview 
 { { drop 'col } ,nip
 { tlen b2i } ,nip
 { over rbox o( @ rbox exec exec )o } ,nip
 { MutF ljmp } ,nip
 } mkcommon fixsz ;
: mkfunview 
 { { o( tlen 0 b@ exec )o } ,nip
 { o( 8 b@ exec )o } ,nip
 { swap o( 9 b@ exec )o } ,nip
 { MutF ljmp } ,nip
 } mkcommon b2o ;
: mkmutview 
 { { drop noop 'mut } ,nip
 { o( 8 b@ exec )o } ,nip
 { swap o( 9 b@ exec )o } ,nip
 noop
 } mkcommon b2o ;
: typ2i b2p c@ 63 and ;
: typ2s 64 + 1 nbuf tuck b2p c! dup ++ ;
: typ= xor 31 and 0= ;
: typn? 32 and 0<> ; #nullable?
variable Dict0 variable Dict1 variable D,0 variable D,1
 ( 'keys 'I typ2i -1 'dups 'I typ2i -1 'cols 'V typ2i 1 ) Wn 3 mkrowview to D,0
 ( 'name 'S typ2i -1 'type 'I typ2i -1 'subv 'V typ2i 0 ) Wn 3 mkrowview to D,1
 ( 0 1 D,0 ) Wn 1 mkrowview b2p to Dict0
 ( 1 0 D,1 ) Wn 1 mkrowview b2p to Dict1
 Dict0 dup D,1 8 b! dup Dict0 ttag! dup Dict1 ttag! D,0 tadr! 
 Dict1 dup D,0 8 b! dup D,0 ttag! dup D,1 ttag! D,1 tadr! 
 Dict0 to D,0 Dict1 to D,1
: mktopmeta 
 D,1 over tlen 3 div mkrowview 3 pack D,0 1 mkrowview b2p dup dup 2 ^at tadr! ;
: mkvdef 0 1 rot mktopmeta rot mkrowview ;
: fixvdef ^meta rrot swap ^info swap 3 * 2+ b! ;
variable Mvnone 0 ( ) ( ) mkvdef ^meta 0 over tlen! to Mvnone
: getcol swap fixsz { over ^at } map* nip ;
: ^getcol ncol getcol ;
: getrow box dup ^info { 2dup ^at nip } map* nip ;
: getall fixsz dup dup ^info * nvec b2p swap
 { dup getrow { @ over ! 1+ } rep* } rep* dup b2i over tlen! b2o ;
: ^width ^info b2i ;
: ^names ^info 0 getcol ;
: ^types ^info 1 getcol { @ typ2s } map* ;
variable Smk
: mseek Smk rbox to Smk ;
: mkb Smk 1 +to Smk c@ 0xFF and ;
: mk2be mkb 8 << mkb or ;
: mk4be mk2be 16 << mk2be or ;
: big4 0xF and 16 << 16 << mk4be 0xFFFFFFFF and + ;
: peek4 -4 +to Smk mkb 3 +to Smk big4 ;
: skroot Smk p2end 4 - mseek peek4 mseek ;
: mkroot p2end 16 - to Smk Wn -1001 box mkb 128 = if
 3 +to Smk peek4 neg 16 - Smk rbox
 dup tlen tuck + swap nsha b2p to Smk
 mkb mkb + 150 = mkb 26 = and if skroot drop Smk then then ;
: mkv 0 begin 128 * mkb tuck + swap 128 and until 128 - ;
: symc mkb dup [' <> over ]' <> * over ,' <> * over :' <> * ;
: tok 41 nbuf begin 1+ symc while over c! repeat swap end2p swap ;
: mdef dup int? if -1 else V' swap then swap 63 and swap
 3 pack b2p swap 3 vcpy nip ;
: pars 360 nvec b2p
 begin tok [' = if pars else mkb then mdef mkb ,' <> until
 dup b2p over nvec b2p rot vcpy
 nip b2o D,1 over tmax 3 div mkrowview fixsz
 0 1 rot 3 pack D,0 1 mkrowview b2p ;
 "340512/23041./1230.4/12.30./012.3./012..3/01.2.." constant wtab
: $wbit over 8 < over 7 < * ;
: $wmap swap 1- 7 * + 1- wtab rbox c@ 7 and ;
: bigend '1234 b2p i@ 255 and 0x34 = ;
: $reve dup 5 >= neg Smk bigend box c@ 76 = * if 2+ then ;
: $wdiv 8 * swap div log2 1- ;
: aintw dup 0= if nip exit then $wbit if $wmap else $wdiv then 1+ $reve ;
variable Iget
 ( xv0z xv1u xv2u xv3u xv4i xv5i xv6i xv5r xv6r ) to Iget
: $mkv2 mkv dup if mkv else 0 then Smk rbox ;
: icol ^count $mkv2 over nsha rrot aintw Iget rbox @ over setg ;
: BorS dup B' typ= swap S' typ= or ;
: vskip mkv if mkv else 0 then ;
: $nskp typn? if vskip mkv 2drop then ;
: $cskp BorS if vskip if vskip drop then then vskip drop ;
: loadv mkv drop dup nil? if drop mkv drop pars -1 +to Smk then mkv 
 over 2 ^at { Smk >r over if dup 1 ^at dup $nskp $cskp then drop r> } map*
 rrot mkcolview ;
: $sinc rot swap -2 box dup @ swap ++ exec + swap ;
: $sall >r
 begin dup while 1- over r> dup 1+ >r ! r@ $sinc repeat 2drop r> ;
: $sdec tuck tlen dup if swap tlen + over tlen! else 2drop then ;
: $smap over dup tdat rbox exec nsha $sdec ;
: $smi1 mkv + $mkv2 swap nsha 2dup $sdec drop over ! 1+ ;
: $smit b2p begin over Smk > while $smi1 repeat ;
: $smem $mkv2 ?if dup mseek + swap $smit then 2drop ;
: $icol 2 pick if icol then ;
: $scol Wo ^count Wo $icol b2p over nvec b2p tuck tdat! $sall dup $smem ;
: oinfo Wo ^info Wo box ;
: $vc vskip mseek oinfo 2 ^at Wo ^count { drop dup loadv } map* nip ;
: $sc S' typ= neg vskip Smk rbox $scol tuck tlen!
 { dup @ dup 0< if nip else $smap then } custg ;
: $ic Wo icol ;
variable Ffixn { #Wo=v Wo tlen! drop } to Ffixn
: $cfix2 
 dup V' typ= if $vc else dup BorS if dup $sc else $ic then then nip ;
: colfix oinfo 1 ^at dup typn? if Wo tlen swap 
 $mkv2 swap nsha mkv Wo tlen! rrot $cfix2 rrot Ffixn exec else $cfix2 then ;
: mkopen mkroot dup nil? 0= if
 { dup Wo @ box to Smk colfix dup Wo ! over box exec nip } custg
 to Smk Wn loadv b2o then ;
: mkfopen xmmf exec dup str? if mkopen else drop Wn -1000 box then ;
: skfind over fixsz { 0 ^at over cmp 0= } fnd* nip box ;
: findez skfind dup ^count over = if drop Wn else
 dup 3 ^at swap 1 ^at over tlen over =
 if drop else nbuf swap xdez exec then then ;
Ww 100 box constant infv
Ww 101 box constant exef
Ww 102 box constant argv
variable Exe
{ infv 0 b@ 'Vq s= if exef mkfopen dup -1 >= if
 b2p 'dirs ncol ^at b2p dup to Exe 2 ^at 'boot.th findez eval then then } exec
