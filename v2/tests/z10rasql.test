#!/usr/bin/tclsh
# z10rasql.test -=- test suite for the rasql parser
# %renumber<^test >%

set uses {thrill ratcl rasql}
source [file join [file dirname [info script]] initests.tcl]

array set Q {
  0 {
    SELECT * FROM frequents
  }
  1 {
    SELECT * FROM frequents
     WHERE drinker = 'norm'
  }
  2 {
    SELECT drinker FROM likes
     UNION
    SELECT drinker FROM frequents
  }
  3 {
    SELECT drinker FROM likes
    EXCEPT
    SELECT drinker FROM frequents
  }
  4 {
    SELECT * FROM frequents
     WHERE drinker>'norm' OR drinker<'b'
  }
  5 {
    SELECT *
      FROM frequents AS f, serves AS s
     WHERE f.bar = s.bar
  }
  6 {
    SELECT *
      FROM frequents AS f, serves AS s
     WHERE f.bar = s.bar AND
       NOT EXISTS ( SELECT l.drinker, l.beer
		      FROM likes l
		     WHERE l.drinker=f.drinker AND s.beer=l.beer )
  }
  7 {
    SELECT SUM(quantity) AS total, AVG(quantity),
	   COUNT(*) AS tcount, total/tcount
      FROM serves
  }
  8 {
      SELECT bar, SUM(quantity) AS total, AVG(quantity),
	     COUNT(*) AS beers, total/beers
	FROM serves
       WHERE beer <> 'bud'
    GROUP BY bar
      HAVING total>500 OR beers>3
    ORDER BY 2, bar
  }
  9 {
      SELECT l.drinker, l.beer, COUNT(*), SUM(l.perday*f.perweek)
	FROM likes l, frequents f
       WHERE l.drinker=f.drinker
    GROUP BY l.drinker, l.beer
    ORDER BY 4 DESC, l.drinker, l.beer
  }
}

test 0 {parse trivial select} {
  ::thrill::sqlparse $Q(0)
} {sel star {frequents {}} {} {} {} {}}

test 1 {} {
  ::thrill::sqlparse $Q(1)
} {sel star {frequents {}} {= {sym drinker} {str 'norm'}} {} {} {}}

test 2 {} {
  ::thrill::sqlparse $Q(2)
} {uni {sel {{sym drinker} {}} {likes {}} {} {} {} {}}\
	{sel {{sym drinker} {}} {frequents {}} {} {} {} {}}}

test 3 {} {
  ::thrill::sqlparse $Q(3)
} {exc {sel {{sym drinker} {}} {likes {}} {} {} {} {}}\
	{sel {{sym drinker} {}} {frequents {}} {} {} {} {}}}

test 4 {} {
  ::thrill::sqlparse $Q(4)
} {sel star {frequents {}} {or {> {sym drinker} {str 'norm'}}\
				{< {sym drinker} {str 'b'}}} {} {} {}}

test 5 {} {
  ::thrill::sqlparse $Q(5)
} {sel star {frequents f serves s} {= {dot f bar} {dot s bar}} {} {} {}}

test 6 {} {
  ::thrill::sqlparse $Q(6)
} {sel star {frequents f serves s} {and {= {dot f bar} {dot s bar}}\
    {0= {exi {sel {{dot l drinker} {} {dot l beer} {}} {likes l}\
      {and {= {dot l drinker} {dot f drinker}}\
	    {= {dot s beer} {dot l beer}}} {} {} {}}}}} {} {} {}}

test 7 {parse trivial select} {
  ::thrill::sqlparse $Q(7)
} {sel {{sum {sym quantity}} total {avg {sym quantity}} {}\
	  num tcount {div {sym total} {sym tcount}} {}} {serves {}} {} {} {} {}}

test 8 {parse trivial select} {
  ::thrill::sqlparse $Q(8)
} {sel {{sym bar} {} {sum {sym quantity}} total {avg {sym quantity}} {}\
    num beers {div {sym total} {sym beers}} {}} {serves {}}\
    {<> {sym beer} {str 'bud'}}\
    {{sym bar} {}} {or {> {sym total} {int 500}}\
			{> {sym beers} {int 3}}}\
    {sort {int 2} sort {sym bar}}}

test 9 {parse trivial select} {
  ::thrill::sqlparse $Q(9)
} {sel {{dot l drinker} {} {dot l beer} {} num {}\
    {sum {* {dot l perday} {dot f perweek}}} {}} {likes l frequents f}\
    {= {dot l drinker} {dot f drinker}}\
    {{dot l drinker} {} {dot l beer} {}} {}\
    {desc {int 4} sort {dot l drinker} sort {dot l beer}}}

test 10 {parse nonsense} {
  list [catch { 
    ::thrill::sqlparse {select blah blah blah from all over the place}
  } e] $e
} {1 -1}

test 11 {open test data file} {
  set db [vopen ../noarch/gtest.db]
  list [view $db info names] [view $db info types] [view $db get #]
} {{frequents likes serves} {V V V} 1}

test 12 {simplest query} {
  set q [view $db get 0 frequents | sql { SELECT * }]
  list [view $q info names] [view $q get #] [view $q first 3 | get]
} {{drinker bar perweek} 10 {adam lolas 1 woody cheers 5 sam cheers 5}}

test 13 {simple query} {
  set q [view $db sql $Q(0)]
  list [view $q info names] [view $q get #] [view $q first 3 | get]
} {{drinker bar perweek} 10 {adam lolas 1 woody cheers 5 sam cheers 5}}

test 14 {simple condition} {
  set q [view $db sql $Q(1)]
  list [view $q info names] [view $q get #] [view $q get]
} {{drinker bar perweek} 3 {norm cheers 3 norm joes 1 norm lolas 2}}

test 15 {union and projections} {
  set q [view $db sql $Q(2)]
  list [view $q info names] [view $q get #] [view $q get]
} {drinker 8 {adam wilt sam norm nan woody lola pierre}}

test 16 {except and projections} {
  set q [view $db sql $Q(3)]
  list [view $q info names] [view $q get #] [view $q get]
} {drinker 1 nan}

test 17 {compound conditions} {
  set q [view $db sql $Q(4)]
  list [view $q info names] [view $q get #] [view $q get]
} {{drinker bar perweek} 6 {adam lolas 1 woody cheers 5 sam cheers 5\
			    wilt joes 2 woody lolas 1 pierre frankies 0}}

test 18 {compound condition display} {
  # this example shows that SQL translation is not (yet!) being done lazily
  view $db sql $Q(4) | describe
} {\
 -maprow
  +-view
  | +-drinker:S
  | +-bar:S
  | +-perweek:I
  +-vec}

test 19 {data stack is empty} {
  vfinish
} {}

cleanupTests

# vim: set ft=tcl :
