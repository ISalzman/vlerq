#!/usr/bin/tclsh
# z28null.test -=- test suite for nullable columns
# %renumber<^test >%

set uses {thrill ratcl}
source [file join [file dirname [info script]] initests.tcl]

test 0 {thrive vm has been set up} {
  regexp {^::thrive_\d+$} $::thrill::v::ws
} 1

test 1 {set up view without null data} {
  set v [vdef A:S B:I {a 0 "" 0x111111 b 0 "" 0x222222 c 0}]
  list [view $v info names] [view $v info types] [view $v get]
} {{A B} {S I} {a 0 {} 1118481 b 0 {} 2236962 c 0}}

test 2 {save view without null data} {
  set s [view $v save z28temp.db]
  #puts [exec hexdump -C z28temp.db]
  return $s
} 74

test 3 {load back without null data} {
  set v [vopen z28temp.db]
  catch { file delete z28temp.db }
  list [view $v info names] [view $v info types] [view $v get]
} {{A B} {S I} {a 0 {} 1118481 b 0 {} 2236962 c 0}}

test 4 {save view with nullable col but no nulls} {
  set v [vdef A:S B:i {a 0 "" 0x111111 b 0 "" 0x222222 c 0}]
  set s [view $v save z28temp2.db]
  #puts [exec hexdump -C z28temp2.db]
  return $s
} 78

test 5 {load back with nullable col but no nulls} {
  #thrill::vcall { 2 to Wq Wn }
  set v [vopen z28temp2.db]
  catch { file delete z28temp2.db }
  list [view $v info names] [view $v info types] [view $v get]
} {{A B} {S i} {a 0 {} 1118481 b 0 {} 2236962 c 0}}

test 6 {set up view with null data} {
  set v [vdef A:s B:i {a "" "" 0x111111 b "" "" 0x222222 c ""}]
  list [view $v info names] [view $v info types] [view $v get]
} {{A B} {s i} {a {} {} 1118481 b {} {} 2236962 c {}}}

test 7 {call the valid function} {
  view $v extend va:I valid(A) vb:I valid(B) | get
} {a {} 1 0 {} 1118481 0 1 b {} 1 0 {} 2236962 0 1 c {} 1 0}

test 8 {save view with null data} {
  set s [view $v save z28temp3.db]
  #puts [exec hexdump -C z28temp3.db]
  return $s
} 66

test 9 {load back with null data} {
  set v [vopen z28temp3.db]
  catch { file delete z28temp3.db }
  list [view $v info names] [view $v info types] [view $v get]
} {{A B} {s i} {a {} {} 1118481 b {} {} 2236962 c {}}}

test 10 {save 10,000 ints without nulls} {
  set b [split [string repeat 0 10000] ""]
  set v [vdef I:I [lreplace $b 123 124 1118481 2236962]]
  set s [view $v save z28temp4.db]
  #puts [exec hexdump -C z28temp4.db]
  catch { file delete z28temp4.db }
  return $s
} 40035

test 11 {save 10,000 ints with nulls} {
  set b [string map {0 {""}} $b]
  set v [vdef I:i [lreplace $b 123 124 1118481 2236962]]
  set s [view $v save z28temp5.db]
  #puts [exec hexdump -C z28temp5.db]
  return $s
} 50

test 12 {load back 10,000 ints with nulls} {
  set v [vopen z28temp5.db]
  catch { file delete z28temp5.db }
  list [view $v info names] [view $v info types] [view $v get #]
} {I i 10000}

test 13 {verify some results after loading} {
  set w [view $v slice 120 8 1]
  list [view $v first 3 | get ] [view $w get] [view $v last 3 | get]
} {{{} {} {}} {{} {} {} 1118481 2236962 {} {} {}} {{} {} {}}}

test 14 {empty nullable} {
  set v [vdef A:s {}]
  set s [view $v save z28temp6.db]
  #puts [exec hexdump -C z28temp6.db]
  catch { file delete z28temp6.db }
  return $s
} 31

test 15 {one null} {
  set v [vdef A:s {""}]
  set s [view $v save z28temp7.db]
  #puts [exec hexdump -C z28temp7.db]
  catch { file delete z28temp7.db }
  return $s
} 36

test 16 {two nulls} {
  set v [vdef A:s {"" ""}]
  set s [view $v save z28temp8.db]
  #puts [exec hexdump -C z28temp8.db]
  catch { file delete z28temp8.db }
  return $s
} 36

test 17 {data stack is empty} {
  vfinish
} {}

cleanupTests

# vim: set ft=tcl :
