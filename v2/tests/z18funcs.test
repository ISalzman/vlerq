#!/usr/bin/tclsh
# z18funcs.test -=- test suite for functions and callbacks
# %renumber<^test >%

set uses {thrill ratcl}
source [file join [file dirname [info script]] initests.tcl]

test 0 {setup test data} {
  set R [vdef A B C   {a b c d a f c b d}]
  set S [vdef D E F   {b g a d a f}]
  set T [vdef A B C D {a b c d a b e f b c e f e d c d e d e f a b d e}]
  set U [vdef C D E   {c d e c d f d e f}]
  set V [vdef C D     {c d e f}]
  set W [vdef A B C   {1 2 3 a b c}]
  set X [vdef D E:I F {a 100 aa b 20 bb c 3 cc}]
  set Y [vdef D       {y}]
  set Z [vdef E       {}]
  return
} {}

test 1 {input data} {
  view $X get
} {a 100 aa b 20 bb c 3 cc}

test 2 {uppercase} {
  view $X extend U { upper(D) } | get
} {a 100 aa A b 20 bb B c 3 cc C}

test 3 {uppercase const} {
  view $X extend U { upper("abc") } | get
} {a 100 aa ABC b 20 bb ABC c 3 cc ABC}

test 4 {join to set up a nested view} {
  set v [view $T join $U J]
  list [view $v info names] [view $v info types] [view $v mapcols -omit 4 | get]
} {{A B C D J} {S S S S V} {a b c d a b e f b c e f e d c d e d e f a b d e}}

test 5 {subview counts} {
  view $v extend C:I { count(J) } | mapcols -omit 4 | get
} {a b c d 2 a b e f 0 b c e f 0 e d c d 2 e d e f 0 a b d e 1}

test 6 {numeric subview setup} {
  set w [vdef S:V [list $X]]
  view $w ungroup S | get
} {a 100 aa b 20 bb c 3 cc}

test 7 {numeric subview} {
  set w [vdef S:V [list $X]]
  view $w extend T:I { sum(S.E) } | mapcols -omit 0 | get
} 123

test 8 {minimum} {
  set w [vdef S:V [list $X]]
  view $w extend T:I { min(S.E) } | mapcols -omit 0 | get
} 3

test 9 {maximum} {
  set w [vdef S:V [list $X]]
  view $w extend T:I { max(S.E) } | mapcols -omit 0 | get
} 100

test 10 {average} {
  set w [vdef S:V [list $X]]
  view $w extend T:I { avg(S.E) } | mapcols -omit 0 | get
} 41

test 11 {callback} {
  vfun myfoo S foo bar
  proc foo {args} { return $args }
  view $W calc Z { myfoo(A,1+2,B) } | get
} {{bar 1 3 2} {bar a 3 b}}

test 12 {int callback} {
  vfun mybar I expr
  view $X calc Z { mybar("2*3")+E } | get
} {106 26 9}

test 13 {string length} {
  vfun mylen S string length
  set v [vdef A {a bb 1 " 1" "1 " ccc}]
  view $v calc Z { mylen(A) } | get
} {1 2 1 2 2 3}

test 14 {var & fun mix} {
  # this test makes sure spaces are kept even if the value looks like an int
  array set a {0 a 1 bb 2 1 3 " 1" 4 "1 " 5 ccc}
  set r {}
  foreach x {a bb 1 " 1" "1 " ccc} {
    lappend r [view [vdef 1] calc Z { mylen($x) } | get]
  }
  set r
} {1 2 1 2 2 3}

test 15 {count mutated subview} {
  set v [vdef A {B C:I} {a {1 2}}]
  view $v get 0 B | insert 0 [vdef C:I {3 4 0}]
  view $v extend D:I { count(B) } | mapcols A D | get
} {a 5}

test 16 {min of mutated subview} {
  view $v extend D:I { min(B.C) } | mapcols A D | get
} {a 0}

test 17 {max of mutated subview} {
  view $v extend D:I { max(B.C) } | mapcols A D | get
} {a 4}

test 18 {avg of mutated subview} {
  view $v extend D:I { avg(B.C) } | mapcols A D | get
} {a 2}

test 19 {sum of mutated subview} {
  view $v extend D:I { sum(B.C) } | mapcols A D | get
} {a 10}

test 20 {function with view input before} {
  view $T group A B G | ungroup G | get
} {a b c d a b e f a b d e b c e f e d c d e d e f}

test 21 {function with view input after} {
  vfun flip V myflip
  proc myflip {v} { view $v reverse }
  view $T group A B G | extend H:V flip(G) | mapcols -omit G | ungroup H | get
} {a b d e a b e f a b c d b c e f e d e f e d c d}

test 22 {data stack is empty} {
  vfinish
} {}

cleanupTests

# vim: set ft=tcl :
