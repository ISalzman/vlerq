#!/usr/bin/tclsh
# z20bitmap.test -=- test suite for bitmap operations
# %renumber<^test >%

set uses {thrill ratcl}
source [file join [file dirname [info script]] initests.tcl]
interp alias {} vcall {} ::thrill::vcall

test 0 {bit counts} xbit {
  foreach x {"" 0 00 000 0000 00000 000000 000001 111111 444444 abcdef} {
    lappend r [vcall { p2end b.count } S $x]
  }
  set r
} {0 2 4 6 8 10 12 13 18 18 21}

test 1 {bit nth} -constraints xbit -body {
  vcall {
    "000000" 15 { sp over rbox b.nth1 .p } rep* drop nl
    "111111" 15 { sp over rbox b.nth1 .p } rep* drop nl
    "444444" 15 { sp over rbox b.nth1 .p } rep* drop nl
    "abcdef" 15 { sp over rbox b.nth1 .p } rep* drop nl
    Wn
  }
} -output {\
 4 5 12 13 20 21 28 29 36 37 44 45 -1 -1 -1
 0 4 5 8 12 13 16 20 21 24 28 29 32 36 37
 2 4 5 10 12 13 18 20 21 26 28 29 34 36 37
 0 5 6 9 13 14 16 17 21 22 26 29 30 32 34
}

test 2 {top bit} -constraints xbit -body {
  vcall {
    32 { sp 1 swap << b.topbit .p } rep* nl
    32 { sp 1 swap << 1+ b.topbit .p } rep* nl
    32 { sp 1 swap << 1- b.topbit .p } rep* nl
    Wn
  }
} -output {\
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\
  16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\
  16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14\
  15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
}

test 3 {dumpb} -body {
 vcall { 'aA012345 dumpb nl Wn }
} -output {\
  01100001 01000001 00110000 00110001 00110010 00110011 00110100 00110101
}

test 4 {compressed bitmap starting with 0} -constraints xbit -body {
  vcall {
    4 { 1 swap <<
      sp 47 { over and } bit* nip dup tlen .p dup dumpb nl b.pack
      sp dup tadr b2i .p dup dumpb nl
      { sp over b2i over b2i ./. } bruns nl
    } rep*
    Wn
  }
} -output {\
 23 10101010 10101010 10101010 10101010 10101010 00101010
 48 01111111 11111111 11111111 11111111 11111111 11111111
 1/1 3/1 5/1 7/1 9/1 11/1 13/1 15/1 17/1 19/1 21/1 23/1 25/1\
  27/1 29/1 31/1 33/1 35/1 37/1 39/1 41/1 43/1 45/1
 23 11001100 11001100 11001100 11001100 11001100 01001100
 71 00100100 10010010 01001001 00100100 10010010 01001001\
  00100100 10010010 01001010
 2/2 6/2 10/2 14/2 18/2 22/2 26/2 30/2 34/2 38/2 42/2 46/1
 23 11110000 11110000 11110000 11110000 11110000 01110000
 59 00010000 10000100 00100001 00001000 01000010 00010000\
  10000100 01100000
 4/4 12/4 20/4 28/4 36/4 44/3
 23 00000000 11111111 00000000 11111111 00000000 01111111
 41 00001000 00010000 00100000 01000000 10000011 10000000
 8/8 24/8 40/7
}

test 5 {compressed bitmap starting with 1} -constraints xbit -body {
  vcall {
    4 { 1 swap <<
      sp 47 { over and 0= } bit* nip dup tlen .p dup dumpb nl b.pack
      sp dup tadr b2i .p dup dumpb nl
      { sp over b2i over b2i ./. } bruns nl
    } rep*
    Wn
  }
} -output {\
 24 01010101 01010101 01010101 01010101 01010101 01010101
 48 11111111 11111111 11111111 11111111 11111111 11111111
 0/1 2/1 4/1 6/1 8/1 10/1 12/1 14/1 16/1 18/1 20/1 22/1 24/1\
  26/1 28/1 30/1 32/1 34/1 36/1 38/1 40/1 42/1 44/1 46/1
 24 00110011 00110011 00110011 00110011 00110011 00110011
 71 10100100 10010010 01001001 00100100 10010010 01001001\
  00100100 10010010 01001010
 0/2 4/2 8/2 12/2 16/2 20/2 24/2 28/2 32/2 36/2 40/2 44/2
 24 00001111 00001111 00001111 00001111 00001111 00001111
 59 10010000 10000100 00100001 00001000 01000010 00010000\
  10000100 01100000
 0/4 8/4 16/4 24/4 32/4 40/4
 24 11111111 00000000 11111111 00000000 11111111 00000000
 41 10001000 00010000 00100000 01000000 10000011 10000000
 0/8 16/8 32/8
}

test 6 {try v2i} {
  vcall { ( 123 234 345 ) v2i lit i@ map* }
} {123 234 345}

test 7 {lowest and highest} {
  vcall { ( 2 -1 4 3 ) v2i b.lohi 2 pack }
} {-1 4}

test 8 {signed precision} {
  set r {}
  foreach x {0 1 2 3 4 15 16 126 127 128 129 -129 -128 -127 -17 -16 -3 -2 -1} {
    lappend r [vcall sprec I $x]
  }
  set r
} {0 1 2 2 3 4 5 7 7 8 8 -9 -8 -8 -6 -5 -3 -2 -1}

test 9 {choose bit width} {
  set r1 {}
  set r7 {}
  set r8 {}
  foreach x {0 1 2 3 4 15 16 126 127 128 129 -129 -128 -127 -17 -16 -3 -2 -1} {
    lappend r1 [vcall { v2i bwidth } (I) $x] 
    lappend r7 [vcall { v2i bwidth } (I) [list $x $x $x $x $x $x $x]]
    lappend r8 [vcall { v2i bwidth } (I) [list $x $x $x $x $x $x $x $x]]
  }
  list $r1 $r7 $r8
} {{0 4 4 4 4 4 4 4 4 5 5 5 4 4 4 4 4 4 4}\
   {0 4 4 4 4 4 4 4 4 5 5 5 4 4 4 4 4 4 4}\
   {0 1 2 2 3 3 4 4 4 5 5 5 4 4 4 4 4 4 4}}

test 10 {choose tricky bit widths} {
  set r1 {}
  set r7 {}
  set r8 {}
  foreach x {0 1 2 3 4 15 16 127 128 32767 32768 -32769 -32768 -129 -128 } {
    lappend r1 [vcall { v2i bwidth } (I) $x] 
    lappend r7 [vcall { v2i bwidth } (I) [list $x $x $x $x $x $x $x]]
    lappend r8 [vcall { v2i bwidth } (I) [list $x $x $x $x $x $x $x $x]]
  }
  list $r1 $r7 $r8
} {{0 4 4 4 4 4 4 4 5 5 6 6 5 5 4}\
   {0 4 4 4 4 4 4 4 5 5 6 6 5 5 4}\
   {0 1 2 2 3 3 4 4 5 5 6 6 5 5 4}}

test 11 {32-bit ints to 16-bit ints} {
  vcall {
    ( 1234 -1234 0 -1 32768 ) v2i 5 b.convi
    b2o xv5i over setg lit exec map* 
  }
} {1234 -1234 0 -1 -32768}

test 12 {32-bit ints to 8-bit ints} {
  vcall {
    ( 1 2 34 123 -1 -123 -128 127 0 9 ) v2i 4 b.convi
    b2o lit c@ map* 
  }
} {1 2 34 123 -1 -123 -128 127 0 9}

test 13 {32-bit ints to 4-bit ints} {
  vcall {
    ( 0 1 2 3 4 5 6 7 15 14 13 12 11 ) v2i 3 b.convi
    b2o xv3u over setg lit exec map* 
  }
} {0 1 2 3 4 5 6 7 15 14 13 12 11}

test 14 {32-bit ints to 2-bit ints} {
  vcall {
    ( 0 1 1 2 0 0 3 1 2 0 1 2 3 0 0 0 0 0 3 ) v2i 2 b.convi
    b2o xv2u over setg lit exec map* 
  }
} {0 1 1 2 0 0 3 1 2 0 1 2 3 0 0 0 0 0 3}

test 15 {32-bit ints to 1-bit ints} {
  vcall {
    ( 1 0 1 1 0 1 1 1 0 0 1 0 1 0 0 1 1 1 0 0 0 0 1 1 1 0 1 1 0 ) v2i 1 b.convi
    b2o xv1u over setg lit exec map* 
  }
} {1 0 1 1 0 1 1 1 0 0 1 0 1 0 0 1 1 1 0 0 0 0 1 1 1 0 1 1 0}

test 16 {count 1 bits} {
  vcall {
    ( 1 0 1 1 0 1 1 1 0 0 1 0 1 0 0 1 1 1 0 0 0 0 1 1 1 0 1 1 0 ) v2i 1 b.convi
    bcount 
  }
} 16

test 17 {32-bit ints to compressed bitmap} -body {
  vcall {
    ( 1 0 1 1 0 1 1 1 0 0 1 0 1 0 0 1 1 1 0 0 0 0 1 1 1 0 1 1 0 ) v2i 1 b.convi
    p2end dup bcount over tlen!
    sp dup tlen .p dup dumpb nl b.pack
    sp dup tadr b2i .p dup dumpb nl
    { sp over b2i over b2i ./. } bruns nl
    Wn
  }
} -output {\
 16 11101101 10010100 11000011 00001101
 35 11101010 11010111 01001100 10001110 10100000
 0/1 2/2 5/3 10/1 12/1 15/3 22/3 26/2
}

test 18 {data stack is empty} {
  vfinish
} {}

cleanupTests

# vim: set ft=tcl :
