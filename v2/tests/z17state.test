#!/usr/bin/tclsh
# z17state.test -=- test suite for handling of view states
# %renumber<^test >%

set uses {thrill ratcl}
source [file join [file dirname [info script]] initests.tcl]

test 0 {setup test data} {
  set R [vdef A B C   {a b c d a f c b d}]
  set S [vdef D E F   {b g a d a f}]
  set T [vdef A B C D {a b c d a b e f b c e f e d c d e d e f a b d e}]
  set U [vdef C D E   {c d e c d f d e f}]
  set V [vdef C D     {c d e f}]
  set W [vdef A B C   {1 2 3 a b c}]
  set X [vdef D E:I F {a 100 aa b 20 bb c 3 cc}]
  set Y [vdef D       {y}]
  set Z [vdef E       {}]
  return
} {}

test 1 {input data} {
  view $R get
} {a b c d a f c b d}

test 2 {state wrapper} {
  view [::thrill::vcall ^Mut V $R] get
} {a b c d a f c b d}

test 3 {set one} {
  view $R set 1 C XYZ
  view $R get
} {a b c d a XYZ c b d}

test 4 {set another, same mutable view} {
  view $R set 2 1 ZYX | get
} {a b c d a XYZ c ZYX d}

test 5 {append rows} {
  view $R insert 3 $W 
  view $R get
} {a b c d a XYZ c ZYX d 1 2 3 a b c}

test 6 {append more rows} {
  view $R insert 5 $W | get
} {a b c d a XYZ c ZYX d 1 2 3 a b c 1 2 3 a b c}

test 7 {delete end rows} {
  view $R delete 4 3 
  view $R get
} {a b c d a XYZ c ZYX d 1 2 3}

test 8 {change inserted} {
  view $R set 3 1 VW | get
} {a b c d a XYZ c ZYX d 1 VW 3}

test 9 {change orig} {
  view $R set 0 1 TU | get
} {a TU c d a XYZ c ZYX d 1 VW 3}

test 10 {del middle} {
  view $R delete 2 1 | get
} {a TU c d a XYZ 1 VW 3}

test 11 {ins middle} {
  view $R insert 2 $W | get
} {a TU c d a XYZ 1 2 3 a b c 1 VW 3}

test 12 {del start} {
  view $R delete 0 3 | get
} {a b c 1 VW 3}

test 13 {ins start} {
  view $R insert 0 $W | get
} {1 2 3 a b c a b c 1 VW 3}

test 14 {concat} {
  view $R concat $R | get
} {1 2 3 a b c a b c 1 VW 3 1 2 3 a b c a b c 1 VW 3}

test 15 {set multiple} {
  view $R set 1 A A C CC B BBB | get
} {1 2 3 A BBB CC a b c 1 VW 3}

test 16 {set without getting a mutable view first} {
  view $S set 1 2 ZYX 
  view $S get
} {b g a d a ZYX}

test 17 {append} {
  view $R append $W | get
} {1 2 3 A BBB CC a b c 1 VW 3 1 2 3 a b c}

test 18 {replace} {
  view $R replace 2 $W | get
} {1 2 3 A BBB CC 1 2 3 a b c 1 2 3 a b c}

test 19 {subview op on mutated view and subview} {
  set v [view [vdef id {children id} {}] append \
	      [vdef id {children id} [list root {}]]]
  view $v get 0 children | insert 0 [vdef id node1]
  view $v extend c:I { count(children) } | mapcols id c | get
} {root 1}

test 20 {subview op on mutated subview} {
  set v [vdef id {children id} {root {}}]
  view $v get 0 children | insert 0 [vdef id node1]
  view $v extend c:I { count(children) } | mapcols id c | get
} {root 1}

test 21 {subview op on subview created via grouping} {
  set v [vdef id parent {node1 root}]
  view $v group parent children | \
    extend c:I { count(children) } | mapcols parent c | get
} {root 1}

test 22 {subview op on constructed subview} {
  set v [vdef id {children id} [list root node1]]
  view $v  extend c:I { count(children) } | mapcols id c | get
} {root 1}

test 23 {data stack is empty} {
  vfinish
} {}

cleanupTests

# vim: set ft=tcl :
