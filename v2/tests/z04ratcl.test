#!/usr/bin/tclsh
# z04ratcl.test -=- test suite for the ratcl interface to thrill
# %renumber<^test >%

set uses {thrill ratcl}
source [file join [file dirname [info script]] initests.tcl]
interp alias {} vcall {} ::thrill::vcall 

test 0 {thrive vm has been set up} {
  regexp {^::thrive_\d+$} $::thrill::v::ws
} 1

test 1 {view with no columns} {
  vcall { dup ^count swap ^info b2i 2 pack } V [vdef 123]
} {123 0}

test 2 {view with one column} {
  vcall { dup ^count swap ^info b2i 2 pack } V [vdef A {x y z}]
} {3 1}

test 3 {view with one row} {
  vcall { dup ^count swap ^info b2i 2 pack } V [vdef A B C {x y z}]
} {1 3}

test 4 {view with two rows and three cols} {
  vcall { dup ^count swap ^info b2i 2 pack } V [vdef A B C {1 2 3 4 5 6}]
} {2 3}

test 5 {view size and width} {
  set x [vdef A B C {1 2 3 4 5 6}]
  list [view $x get #] [view $x info width]
} {2 3}

test 6 {view get all} {
  set x [vdef A B C {1 2 3 4 5 6}]
  view $x get
} {1 2 3 4 5 6}

test 7 {view get each row} {
  set x [vdef A B C {1 2 3 4 5 6}]
  list [view $x get 0] [view $x get 1]
} {{1 2 3} {4 5 6}}

test 8 {view get one cell by coord} {
  set x [vdef A B C {1 2 3 4 5 6}]
  view $x get 1 2
} 6

test 9 {view get relative row} {
  set x [vdef A B C {1 2 3 4 5 6}]
  list [view $x get -2] [view $x get -1]
} {{1 2 3} {4 5 6}}

test 10 {view get one cell by relative coord} {
  set x [vdef A B C {1 2 3 4 5 6}]
  view $x get -1 -2
} 5

test 11 {view get one cell by col name} {
  set x [vdef A B C {1 2 3 4 5 6}]
  view $x get 1 B
} 5

test 12 {view get a list o lists} {
  set x [vdef A B C {1 2 3 4 5 6}]
  view $x get *
} {{1 2 3} {4 5 6}}

test 13 {setup test data} {
  set R [vdef A B C   {a b c d a f c b d}]
  set S [vdef D E F   {b g a d a f}]
  set T [vdef A B C D {a b c d a b e f b c e f e d c d e d e f a b d e}]
  set U [vdef C D E   {c d e c d f d e f}]
  set V [vdef C D     {c d e f}]
  set W [vdef A B C   {1 2 3 a b c}]
  set X [vdef D E:I F {a 100 aa b 20 bb c 3 cc}]
  set Y [vdef D       {y}]
  set Z [vdef E       {}]
  return
} {}

test 14 {row counts} {
  set r {}
  foreach x {R S T U V W X Y Z} {
    lappend r [view [set $x] get #]
  }
  set r
} {3 2 6 3 2 2 3 1 0}

test 15 {column counts} {
  set r {}
  foreach x {R S T U V W X Y Z} {
    lappend r [view [set $x] info width]
  }
  set r
} {3 3 4 3 2 3 3 1 1}

test 16 {column names} {
  set r {}
  foreach x {R S T U V W X Y Z} {
    lappend r [view [set $x] info names]
  }
  set r
} {{A B C} {D E F} {A B C D} {C D E} {C D} {A B C} {D E F} D E}

test 17 {column types} {
  set r {}
  foreach x {R S T U V W X Y Z} {
    lappend r [view [set $x] info types]
  }
  set r
} {{S S S} {S S S} {S S S S} {S S S} {S S} {S S S} {S I S} S S}

test 18 {text display} {
  view $W | dump
} { \
  A  B  C
  -  -  -
  1  2  3
  a  b  c}

test 19 {text display alignment} {
  set x { a bbb cc 1 222 33 aaa b c 111 2 3 aa bb cc 11 22 33 }
  view [vdef A BB CCC D:I EE:I FFF:I $x] | dump
} { \
  A    BB   CCC  D    EE   FFF
  ---  ---  ---  ---  ---  ---
  a    bbb  cc     1  222   33
  aaa  b    c    111    2    3
  aa   bb   cc    11   22   33}

test 20 {view from ints} {
  view [vdef M:I {1 22 333}] | dump
} { \
  M  
  ---
    1
   22
  333}

test 21 {view from strings} {
  view [vdef M {4 55 666}] | dump
} { \
  M  
  ---
  4  
  55 
  666}

test 22 {cursor setup} {
  view $W cursor c
  lsort [array names c]
} {# A B C ^}

test 23 {cursor access} {
  view $W cursor c
  list $c(#) $c(A) $c(B) $c(C)
} {0 1 2 3}

test 24 {cursor seek} {
  view $W cursor c
  set c(#) 1
  list $c(#) $c(A) $c(B) $c(C)
} {1 a b c}

test 25 {cursor view} {
  view $W cursor c
  view $c(^) get
} {1 2 3 a b c}

test 26 {view each} {
  set r {}
  view $W each c { lappend r $c(C) $c(B) $c(A) }
  set r
} {3 2 1 c b a}

test 27 {view each continue} {
  set r {}
  view $R each c {
    if {$c(#) == 1} continue
    lappend r $c(C) $c(B) $c(A)
  }
  set r
} {c b a d b c}

test 28 {view each break} {
  set r {}
  view $R each c {
    if {$c(#) == 1} break
    lappend r $c(C) $c(B) $c(A)
  }
  set r
} {c b a}

test 29 {view each return} {
  set r {}
  set e [catch {
    view $R each c {
      if {$c(#) == 1} { return bye }
      lappend r $c(C) $c(B) $c(A)
    }
  } m]
  list $e $m $r
#TODO This *should* actually return code 2, but the view + m_each nesting
#     probably causes this code to be lost ... I don't know how to fix it!
#     Summary: a return inside a view-each loop is like a break for now :(
} {0 bye {c b a}}

test 30 {view each error} {
  set r {}
  set e [catch {
    view $R each c {
      if {$c(#) == 1} { error oops }
      lappend r $c(C) $c(B) $c(A)
    }
  } m]
  list $e $m $r
} {1 oops {c b a}}

test 31 {multi-line commands} {
  view $R do {
    sort B
    take 5
    reverse
    get
  }
} {a b c d a f c b d a b c d a f}

test 32 {multi-line embedded} {
  view $R sort B | do {
    take 5
    reverse
  } | get
} {a b c d a f c b d a b c d a f}

test 33 {multi-line mix} {
  view $R do {
    sort B
    take 5 | reverse
  } | get
} {a b c d a f c b d a b c d a f}

test 34 {multi-line with comments} {
  view $R do {
    # this is a comment
    sort B
    # so is this, even with { and "
    take \
      5
    # but we need to balance the }'s
    reverse | get
  }
} {a b c d a f c b d a b c d a f}

test 35 {multi-line with variable} {
  set v [vdef X Y {1 a 2 b 3 c}]
  set n 1
  view $v do {
    project Y
    get $n
  }
} b

test 36 {multi-line with call} {
  set n 0
  view $v do {
    project Y
    get [incr n]
  }
} b

test 37 {multi-line with variable in condition} {
  set n 2
  view $v do {
    where { X == $n }
    get
  }
} {2 b}

test 38 {data stack is empty} {
  vfinish
} {}

cleanupTests

# vim: set ft=tcl :
