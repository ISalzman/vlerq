#!/usr/bin/tclsh
# z14mutable.test -=- test suite for mutable views
# %renumber<^test >%

set uses {thrill ratcl}
source [file join [file dirname [info script]] initests.tcl]

test 0 {setup test data} {
  set R [vdef A B C   {a b c d a f c b d}]
  set S [vdef D E F   {b g a d a f}]
  set T [vdef A B C D {a b c d a b e f b c e f e d c d e d e f a b d e}]
  set U [vdef C D E   {c d e c d f d e f}]
  set V [vdef C D     {c d e f}]
  set W [vdef A B C   {1 2 3 a b c}]
  set X [vdef D E:I F {a 100 aa b 20 bb c 3 cc}]
  set Y [vdef D       {y}]
  set Z [vdef E       {}]
  return
} {}

test 1 {input data} {
  view $R get
} {a b c d a f c b d}

test 2 {mutable wrapper} {
  set v [::thrill::vcall ^Mut V $R]
  view $v get
} {a b c d a f c b d}

test 3 {set one} {
  set w [::thrill::vcall ^vset VIaS $v 1 C XYZ]
  view $w get
} {a b c d a XYZ c b d}

test 4 {set another, same mutable view} {
  ::thrill::vcall ^vset VIaS $w 2 1 ZYX
  view $w get
} {a b c d a XYZ c ZYX d}

test 5 {append rows} {
  ::thrill::vcall ^insert VIV $w 3 $W
  view $w get
} {a b c d a XYZ c ZYX d 1 2 3 a b c}

test 6 {append more rows} {
  ::thrill::vcall ^insert VIV $w 5 $W
  view $w get
} {a b c d a XYZ c ZYX d 1 2 3 a b c 1 2 3 a b c}

test 7 {delete end rows} {
  ::thrill::vcall ^delete VII $w 4 3
  view $w get
} {a b c d a XYZ c ZYX d 1 2 3}

test 8 {change inserted} {
  ::thrill::vcall ^vset VIaS $w 3 1 VW
  view $w get
} {a b c d a XYZ c ZYX d 1 VW 3}

test 9 {change orig} {
  ::thrill::vcall ^vset VIaS $w 0 1 TU
  view $w get
} {a TU c d a XYZ c ZYX d 1 VW 3}

test 10 {del middle} {
  ::thrill::vcall ^delete VII $w 2 1
  view $w get
} {a TU c d a XYZ 1 VW 3}

test 11 {ins middle} {
  ::thrill::vcall ^insert VIV $w 2 $W
  view $w get
} {a TU c d a XYZ 1 2 3 a b c 1 VW 3}

test 12 {del start} {
  ::thrill::vcall ^delete VII $w 0 3
  view $w get
} {a b c 1 VW 3}

test 13 {ins start} {
  ::thrill::vcall ^insert VIV $w 0 $W
  view $w get
} {1 2 3 a b c a b c 1 VW 3}

test 14 {set string col when first col is int} {
    view [vdef a:I b {1 c}] set 0 b d | get 0 b
} d

test 15 {set string col when first col is string} {
    view [vdef a b {e c}] set 0 b d | get 0 b
} d

test 16 {set string col when 2nd col is int} {
    view [vdef a b:I c {d 1 e}] set 0 c f | get 0 c
} f

test 17 {related to ticket #32 - passes} {
  set v [vdef A {}]
  set w [vdef A x]
  for {set x 0} {$x < 100} {incr x} {
    view $v append $w
  }
  view $v get #
} 100

test 18 {related to ticket #32 - call stack overflow} {
  # problem was the use of ^concat in ^Ins to build up inserted view
  set v [vdef A {}]
  set w [vdef A x]
  for {set x 0} {$x < 100} {incr x} {
    #puts $x-[time { view $v where {A=="x"} }]
    view $v append $w
  }
  view $v where {A=="x"}
  view $v get #
} 100

test 19 {ticket #33, mutated subview survives across saves} memchan {
  set v [vdef id {c id} {root {}}]
  view $v get 0 c | append [vdef id blah]
  list [view $v calc c:I {count(c)} | get] \
       [view [vopen -data [view $v save]] calc c:I {count(c)} | get]
} {1 1}

test 20 {constructed subview survives across saves} memchan {
  set v [vdef id {c id} {root blah}]
  list [view $v calc c:I {count(c)} | get] \
       [view [vopen -data [view $v save]] calc c:I {count(c)} | get]
} {1 1}

test 21 {data stack is empty} {
  vfinish
} {}

cleanupTests

# vim: set ft=tcl :
