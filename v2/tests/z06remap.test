#!/usr/bin/tclsh
# z06remap.test -=- test suite for the ratcl view operators for remapping/order
# %renumber<^test >%

set uses {thrill ratcl}
source [file join [file dirname [info script]] initests.tcl]

test 0 {setup test data} {
  set R [vdef A B C   {a b c d a f c b d}]
  set S [vdef D E F   {b g a d a f}]
  set T [vdef A B C D {a b c d a b e f b c e f e d c d e d e f a b d e}]
  set U [vdef C D E   {c d e c d f d e f}]
  set V [vdef C D     {c d e f}]
  set W [vdef A B C   {1 2 3 a b c}]
  set X [vdef D E:I F {a 100 aa b 20 bb c 3 cc}]
  set Y [vdef D       {y}]
  set Z [vdef E       {}]
  return
} {}

test 1 {sort strings} {
  set v [view $R sort] 
  list [view $v info names] [view $v info types] [view $v get]
} {{A B C} {S S S} {a b c c b d d a f}}

test 2 {sort reversed strings} {
  set v [view $R reverse | sort] 
  list [view $v info names] [view $v info types] [view $v get]
} {{A B C} {S S S} {a b c c b d d a f}}

test 3 {sort strings and int} {
  set v [view $X sort] 
  list [view $v info names] [view $v info types] [view $v get]
} {{D E F} {S I S} {a 100 aa b 20 bb c 3 cc}}

test 4 {sort on strings} {
  set v [view $R sort B] 
  list [view $v info names] [view $v info types] [view $v get]
} {{A B C} {S S S} {d a f a b c c b d}}

test 5 {sort on integers by column name} {
  set v [view $X sort E] 
  list [view $v info names] [view $v info types] [view $v get]
} {{D E F} {S I S} {c 3 cc b 20 bb a 100 aa}}

test 6 {sort on integers by column position} {
  set v [view $X sort 1] 
  list [view $v info names] [view $v info types] [view $v get]
} {{D E F} {S I S} {c 3 cc b 20 bb a 100 aa}}

test 7 {sort on integers by relative column position} {
  set v [view $X sort -2] 
  list [view $v info names] [view $v info types] [view $v get]
} {{D E F} {S I S} {c 3 cc b 20 bb a 100 aa}}

test 8 {make sure sort is stable} {
  set v [vdef A B:I {A 3 A 1 A 2 B 1 D 1 D 2 C 1 C 2 C 3}]
  view $v sort B | reverse | sort A | get
} {A 3 A 2 A 1 B 1 C 3 C 2 C 1 D 2 D 1}

test 9 {unique on unique} {
  set v [view $R unique] 
  list [view $v info names] [view $v info types] [view $v get]
} {{A B C} {S S S} {a b c d a f c b d}}

test 10 {unique on dups} {
  set v [view [vdef A B C D {e d e f e d e f e d e f}] unique] 
  list [view $v info names] [view $v info types] [view $v get]
} {{A B C D} {S S S S} {e d e f}}

test 11 {unique on first col} {
  set v [vdef A B {a 0 b 1 c 2 a 3 a 4 b 5 d 6 d 7 e 8}]
  view $v unique A | get
} {a 0 b 1 c 2 d 6 e 8}

test 12 {unique on second col} {
  set v [vdef A B {0 a 1 b 2 c 3 a 4 a 5 b 6 d 7 d 8 e}]
  view $v unique B | get
} {0 a 1 b 2 c 6 d 8 e}

test 13 {unique on two cols} {
  set v [vdef A B C {A a 0 A a 1 B b 2 B c 3 B c 4 C c 5}]
  view $v unique A B | get
} {A a 0 B b 2 B c 3 C c 5}

test 14 {unique on two cols reversed} {
  set v [vdef A B C {A a 0 A a 1 B b 2 B c 3 B c 4 C c 5}]
  view $v unique B A | get
} {A a 0 B b 2 B c 3 C c 5}

test 15 {union} {
  set v [view $R union $W] 
  list [view $v info names] [view $v info types] [view $v get]
} {{A B C} {S S S} {a b c d a f c b d 1 2 3}}

test 16 {union different columns} -body {
  view $R union $S
} -returnCodes {1} -result {not same columns}

test 17 {except} {
  set v [view $R except $W] 
  list [view $v info names] [view $v info types] [view $v get]
} {{A B C} {S S S} {d a f c b d}}

test 18 {except different columns} -body {
  view $R except $S
} -returnCodes {1} -result {not same columns}

test 19 {intersect} {
  set v [view $R intersect $W] 
  list [view $v info names] [view $v info types] [view $v get]
} {{A B C} {S S S} {a b c}}

test 20 {intersect different columns} -body {
  view $R intersect $S
} -returnCodes {1} -result {not same columns}

  # union works, all dups are dropped
test 21 {dups in union match} {
  set v [vdef D {x x x y y z}] 
  view $v union $Y | get
} {x y z}

test 22 {dups in union no match} {
  set v [vdef D {x x x a a z}] 
  view $v union $Y | get
} {x a z y}

test 23 {dups in union to self} {
  set v [vdef D {x x x y y z}] 
  view $v union $v | get
} {x y z}

  # except only works for unique entries
test 24 {dups in except match} {
  set v [vdef D {x x x y y z}] 
  view $v except $Y | get
} {z}

test 25 {dups in except no match} {
  set v [vdef D {x x x a a z}] 
  view $v except $Y | get
} {z}

test 26 {dups in except to self} {
  set v [vdef D {x x x y y z}] 
  view $v except $v | get
} {}

  # intersect is useless when there are duplicates
test 27 {dups in intersect match} {
  set v [vdef D {x x x y y z}] 
  view $v intersect $Y | get
} {x x y y}

test 28 {dups in intersect no match} {
  set v [vdef D {x x x a a z}] 
  view $v intersect $Y | get
} {x x a}

test 29 {dups in intersect to self} {
  set v [vdef D {x x x y y z}] 
  view $v intersect $v | get
} {x x y x x x y y z}

test 30 {pick} {
  view $T pick {0 1 0 1 1 0} | get
} {a b e f e d c d e d e f}

test 31 {data stack is empty} {
  vfinish
} {}

cleanupTests

# vim: set ft=tcl :
