#!/usr/bin/env tclkit
# %renumber<^\s*test >%

# save module tests

source [file join [file dir [info script]] initests.tcl]

test 0 {load package} {
    package require vq
} $version

test 1 {} {
    vq meta2desc 3
} {}

test 2 {} {
    vq meta2desc ""
} name:S,type:I,subt:T

test 3 {} {
    vq load [vq emit 7]
} 7

test 4 {} {
    vq load [vq emit ""]
} {data {mdef {name type:I subt:T}} 0}

test 5 {} {
    vq load [vq emit [vq iota 5 N]]
} {data {mdef N:I} 5 {0 1 2 3 4}}

test 6 {} {
    vq load [vq emit [vq open ../data/alltypes.db]]
} {data {mdef {{v {i0:I i1:I i2:I i4:I i8:I i16:I i32:I l:L f:F d:D s b:B}}}} 1\
    {{data {mdef {i0:I i1:I i2:I i4:I i8:I i16:I i32:I l:L f:F d:D s b:B}} 5\
        {0 0 0 0 0}\
        {1 0 1 0 1}\
        {1 2 1 0 3}\
        {1 6 13 12 3}\
        {-127 -106 -51 -36 -125}\
        {-32767 -32746 -32435 -28324 22787}\
        {1 22 333 4444 55555}\
        {111 222222 333333333 444444444444 555555555555555}\
        {1.5 22.5 333.5 4444.5 55555.5}\
        {11.1 2222.1 333333.1 44444444.1 5555555555.1}\
        {s1 s22 s333 s4444 s55555}\
        {b11 b2222 b333333 b44444444 b5555555555}}}}

test 7 {} {
    set v [vq emit 123]
    string length $v
} 27

test 8 {} {
    vq load $v
} 123

test 9 {} -body {
    binary scan $v H* w
    regsub -all {..} $w {& }
} -match glob -result {4? 4? 1a 00 00 00 00 1b 80 80 fb 80 00 00 00 00\
                       00 00 0b 80 00 00 03 00 00 00 08 }

test 10 {} {
    set v [vq emit [vq data {mdef A} 3 {a b c}]]
    string length $v
} 42

test 11 {} {
    vq load $v
} {data {mdef A} 3 {a b c}}

test 12 {} -body {
    binary scan $v H* w
    regsub -all {..} $w {& }
} -match glob -result {4? 4? 1a 00 00 00 00 2a 61 00 62 00 63 00 2a 80\
                       83 41 3a 53 83 86 88 81 8e 80 80 00 00 00 00 00\
                       00 1a 80 00 00 0b 00 00 00 0f }
                       
test 13 {fix binary input conversion: used Tcl string i.s.o. bytearray} {
    binary scan [vq emit [vq data {mdef A:B} 1 \xAB\xAC\xAD\xAE\xAF]] H* w
    regsub -all {..} [string replace $w 0 3 4?4?] {& }
} {4? 4? 1a 00 00 00 00 29 ab ac ad ae af 05 80 83\
   41 3a 42 81 85 88 81 8d 80 80 00 00 00 00 00 00\
   19 80 00 00 0b 00 00 00 0e }
    
test 14 {fix to preserve null bytes inside B fields} {
    binary scan [vq emit [vq data {mdef A:B} 1 \xAB\x00\xAC\x00\xAD]] H* w
    regsub -all {..} [string replace $w 0 3 4?4?] {& }
} {4? 4? 1a 00 00 00 00 29 ab 00 ac 00 ad 05 80 83\
   41 3a 42 81 85 88 81 8d 80 80 00 00 00 00 00 00\
   19 80 00 00 0b 00 00 00 0e }

test 15 {} {
    set y {data {mdef {{v A} {w {}} {x {B C}}}} 1
      {{data {mdef A} 3 {a aa aaa}}} 123 {{data {mdef {B C}} 2 {b bb} {c cc}}}}
    set z [vq emit $y]
    binary scan $z H* w
    regsub -all {..} [string replace $w 0 3 4?4?] {& }
} {4? 4? 1a 00 00 00 00 63 61 00 61 61 00 61 61 61\
   00 32 04 80 83 89 88 82 91 80 80 80 fb 62 00 62\
   62 00 32 63 00 63 63 00 32 80 82 85 9d 81 a2 80\
   85 a3 81 a8 80 80 95 76 5b 41 3a 53 5d 2c 77 3a\
   54 2c 78 5b 42 3a 53 2c 43 3a 53 5d 81 87 93 83\
   9a 8c a9 80 00 00 00 00 00 00 53 80 00 00 1e 00\
   00 00 35 }
     
test 16 {} {
    set z [vq emit {data {mdef {{A B}}} 2 {{data {mdef B} 2 {1 2}} 
                                           {data {mdef B} 3 {3 4 5}}}}]
    binary scan $z H* w
    regsub -all {..} [string replace $w 0 3 4?4?] {& }
} {4? 4? 1a 00 00 00 00 3d 31 00 32 00 22 33 00 34\
   00 35 00 2a 80 82 84 88 81 8c 80 80 83 86 8d 81\
   93 80 80 86 41 5b 42 3a 53 5d 82 8e 94 80 00 00\
   00 00 00 00 2d 80 00 00 0b 00 00 00 22 }

test 17 {} {
    set z [vq emit {data {mdef A:T} 2 {{data {mdef B} 2 {1 2}} 
                                       {data {mdef C} 3 {3 4 5}}}}]
    binary scan $z H* w
    regsub -all {..} [string replace $w 0 3 4?4?] {& }
} {4? 4? 1a 00 00 00 00 42 31 00 32 00 22 33 00 34\
   00 35 00 2a 80 83 42 3a 53 82 84 88 81 8c 80 80\
   83 43 3a 53 83 86 8d 81 93 80 80 83 41 3a 54 82\
   96 94 80 00 00 00 00 00 00 32 80 00 00 08 00 00\
   00 2a }
                         
test 18 {} {
    vq load $z
} {data {mdef A:T} 2 {{data {mdef B} 2 {1 2}} {data {mdef C} 3 {3 4 5}}}}

test 19 {0-bit ints} {
    vq load [vq emit [vq data {mdef A:I} 3 {0 0 0}]]
} {data {mdef A:I} 3 {0 0 0}}

test 20 {1-bit ints} {
    vq load [vq emit [vq data {mdef A:I} 9 {0 1 1 0 1 0 0 0 1}]]
} {data {mdef A:I} 9 {0 1 1 0 1 0 0 0 1}}

test 21 {2-bit ints} {
    vq load [vq emit [vq data {mdef A:I} 7 {0 1 2 3 2 1 0}]]
} {data {mdef A:I} 7 {0 1 2 3 2 1 0}}

test 22 {4-bit ints} {
    vq load [vq emit [vq data {mdef A:I} 6 {0 1 14 15 2 13}]]
} {data {mdef A:I} 6 {0 1 14 15 2 13}}
    
test 23 {8-bit ints} {
    vq load [vq emit [vq data {mdef A:I} 4 {0 -1 100 -100}]]
} {data {mdef A:I} 4 {0 -1 100 -100}}
    
test 24 {16-bit ints} {
    vq load [vq emit [vq data {mdef A:I} 3 {1234 2345 3456}]]
} {data {mdef A:I} 3 {1234 2345 3456}}
    
test 25 {32-bit ints} {
    vq load [vq emit [vq data {mdef A:I} 3 {123456 0 -654321}]]
} {data {mdef A:I} 3 {123456 0 -654321}}
    
test 26 {64-bit ints} {
    vq load [vq emit [vq data {mdef A:L} 2 {12345678901 23456789012}]]
} {data {mdef A:L} 2 {12345678901 23456789012}}

test 27 {32-bit floats} {
    vq load [vq emit [vq data {mdef A:F} 3 {1.25 2.5 3.75}]]
} {data {mdef A:F} 3 {1.25 2.5 3.75}}

test 28 {64-bit floats} {
    vq load [vq emit [vq data {mdef A:D} 2 {1234567.25 2345678.75}]]
} {data {mdef A:D} 2 {1234567.25 2345678.75}}

test 29 {} {
    set v [vq iota 10000 A]
    vq meta $v
} {mdef A:I}
    
test 30 {} {
    string length [vq emit $v]
} 20035

test 31 {F117, 2006-12-16} {
    set z [vq emit [vq data {mdef A} 2 {1 {}}]]
    binary scan $z H* w
    regsub -all {..} [string replace $w 0 3 4?4?] {& }
} {4? 4? 1a 00 00 00 00 26 31 00 02 80 83 41 3a 53\
     82 82 88 81 8a 80 80 00 00 00 00 00 00 16 80 00\
     00 0b 00 00 00 0b }
    
test 32 {F117, 2006-12-16} {
    vq load [vq emit [vq data {mdef A} 2 {1 {}}]]
} {data {mdef A} 2 {1 {}}}
    
test 33 {} {
    vq load [vq emit [vq data {mdef A} 2 {{} 1}]]
} {data {mdef A} 2 {{} 1}}

::tcltest::cleanupTests
