#!/usr/bin/env tclkit
# %renumber<^\s*test >%

source [file join [file dir [info script]] initests.tcl]

test 0 {} {
    package require tvq
} $version

test 1 {perform a basic call} {
    lvq "gi" type 123
} number

test 2 {check Lua version} {
    lvq "ggs" rawget _G _VERSION
} {Lua 5.1}

test 3 {} skip {
    lvq "gs" print "Hello from Tcl!"
} {}

proc luas {s} { lvq "o" [lvq "gs" loadstring $s] }  ;# evaluate string in lua
luas { package.loaded['lvq.core'] = lvq }           ;# emulate module setup
lvq "ggsc" rawset _G tcl ""                         ;# define a 'tcl' callback

test 4 {run the lvq.lua wrapper} {
    # emulate a require, but from a specific file
    lvq os [lvq "gs" loadfile "../lvq/src/lvq.lua"] lvq
} {}

test 5 {lua error handling} {
    list [catch { lvq "gt" assert 0 } e] $e
} {1 {assertion failed!}}

test 6 {string evaluation in lua} {
    luas { return 1+2*3 }
} 7

test 7 {} skip {
    lvq "gs" dofile "../lvq/tests/test.lua"
} {}

test 8 {tcl callback} {
    lvq "gss" tcl return "a b c"
} "a b c"

test 9 {errors in tcl callback} {
    list [catch { lvq "gs" tcl set } e] $e
} {1 {tvq: wrong # args: should be "set varName ?newValue?"}}

test 10 {output in tcl callback} -body {
    lvq "gss" tcl puts "Hello from Lua!"
} -output "Hello from Lua!\n"

test 11 {error in lua} {
    list [catch { lvq "g" io } e] $e
} {1 {attempt to call a table value}}

test 12 {fetch entry from vops table} -body {
    lvq "gv" tostring meta
} -match glob -result {function: 0x*}

::tcltest::cleanupTests
